(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,57999,(e,t,n)=>{var r=function(e){"use strict";var t,n=Object.prototype,r=n.hasOwnProperty,a=Object.defineProperty||function(e,t,n){e[t]=n.value},s="function"==typeof Symbol?Symbol:{},i=s.iterator||"@@iterator",o=s.asyncIterator||"@@asyncIterator",l=s.toStringTag||"@@toStringTag";function u(e,t,n){return Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}),e[t]}try{u({},"")}catch(e){u=function(e,t,n){return e[t]=n}}function h(e,n,r,s){var i,o,l,u,h=Object.create((n&&n.prototype instanceof g?n:g).prototype);return a(h,"_invoke",{value:(i=e,o=r,l=new T(s||[]),u=d,function(e,n){if(u===c)throw Error("Generator is already running");if(u===f){if("throw"===e)throw n;return E()}for(l.method=e,l.arg=n;;){var r=l.delegate;if(r){var a=function e(n,r){var a=r.method,s=n.iterator[a];if(t===s)return(r.delegate=null,"throw"===a&&n.iterator.return&&(r.method="return",r.arg=t,e(n,r),"throw"===r.method))?m:("return"!==a&&(r.method="throw",r.arg=TypeError("The iterator does not provide a '"+a+"' method")),m);var i=p(s,n.iterator,r.arg);if("throw"===i.type)return r.method="throw",r.arg=i.arg,r.delegate=null,m;var o=i.arg;return o?o.done?(r[n.resultName]=o.value,r.next=n.nextLoc,"return"!==r.method&&(r.method="next",r.arg=t),r.delegate=null,m):o:(r.method="throw",r.arg=TypeError("iterator result is not an object"),r.delegate=null,m)}(r,l);if(a){if(a===m)continue;return a}}if("next"===l.method)l.sent=l._sent=l.arg;else if("throw"===l.method){if(u===d)throw u=f,l.arg;l.dispatchException(l.arg)}else"return"===l.method&&l.abrupt("return",l.arg);u=c;var s=p(i,o,l);if("normal"===s.type){if(u=l.done?f:"suspendedYield",s.arg===m)continue;return{value:s.arg,done:l.done}}"throw"===s.type&&(u=f,l.method="throw",l.arg=s.arg)}})}),h}function p(e,t,n){try{return{type:"normal",arg:e.call(t,n)}}catch(e){return{type:"throw",arg:e}}}e.wrap=h;var d="suspendedStart",c="executing",f="completed",m={};function g(){}function y(){}function x(){}var b={};u(b,i,function(){return this});var w=Object.getPrototypeOf,v=w&&w(w($([])));v&&v!==n&&r.call(v,i)&&(b=v);var k=x.prototype=g.prototype=Object.create(b);function N(e){["next","throw","return"].forEach(function(t){u(e,t,function(e){return this._invoke(t,e)})})}function I(e,t){var n;a(this,"_invoke",{value:function(a,s){function i(){return new t(function(n,i){!function n(a,s,i,o){var l=p(e[a],e,s);if("throw"===l.type)o(l.arg);else{var u=l.arg,h=u.value;return h&&"object"==typeof h&&r.call(h,"__await")?t.resolve(h.__await).then(function(e){n("next",e,i,o)},function(e){n("throw",e,i,o)}):t.resolve(h).then(function(e){u.value=e,i(u)},function(e){return n("throw",e,i,o)})}}(a,s,n,i)})}return n=n?n.then(i,i):i()}})}function S(e){var t={tryLoc:e[0]};1 in e&&(t.catchLoc=e[1]),2 in e&&(t.finallyLoc=e[2],t.afterLoc=e[3]),this.tryEntries.push(t)}function C(e){var t=e.completion||{};t.type="normal",delete t.arg,e.completion=t}function T(e){this.tryEntries=[{tryLoc:"root"}],e.forEach(S,this),this.reset(!0)}function $(e){if(e){var n=e[i];if(n)return n.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var a=-1,s=function n(){for(;++a<e.length;)if(r.call(e,a))return n.value=e[a],n.done=!1,n;return n.value=t,n.done=!0,n};return s.next=s}}return{next:E}}function E(){return{value:t,done:!0}}return y.prototype=x,a(k,"constructor",{value:x,configurable:!0}),a(x,"constructor",{value:y,configurable:!0}),y.displayName=u(x,l,"GeneratorFunction"),e.isGeneratorFunction=function(e){var t="function"==typeof e&&e.constructor;return!!t&&(t===y||"GeneratorFunction"===(t.displayName||t.name))},e.mark=function(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,x):(e.__proto__=x,u(e,l,"GeneratorFunction")),e.prototype=Object.create(k),e},e.awrap=function(e){return{__await:e}},N(I.prototype),u(I.prototype,o,function(){return this}),e.AsyncIterator=I,e.async=function(t,n,r,a,s){void 0===s&&(s=Promise);var i=new I(h(t,n,r,a),s);return e.isGeneratorFunction(n)?i:i.next().then(function(e){return e.done?e.value:i.next()})},N(k),u(k,l,"Generator"),u(k,i,function(){return this}),u(k,"toString",function(){return"[object Generator]"}),e.keys=function(e){var t=Object(e),n=[];for(var r in t)n.push(r);return n.reverse(),function e(){for(;n.length;){var r=n.pop();if(r in t)return e.value=r,e.done=!1,e}return e.done=!0,e}},e.values=$,T.prototype={constructor:T,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(C),!e)for(var n in this)"t"===n.charAt(0)&&r.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=t)},stop:function(){this.done=!0;var e=this.tryEntries[0].completion;if("throw"===e.type)throw e.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var n=this;function a(r,a){return o.type="throw",o.arg=e,n.next=r,a&&(n.method="next",n.arg=t),!!a}for(var s=this.tryEntries.length-1;s>=0;--s){var i=this.tryEntries[s],o=i.completion;if("root"===i.tryLoc)return a("end");if(i.tryLoc<=this.prev){var l=r.call(i,"catchLoc"),u=r.call(i,"finallyLoc");if(l&&u){if(this.prev<i.catchLoc)return a(i.catchLoc,!0);else if(this.prev<i.finallyLoc)return a(i.finallyLoc)}else if(l){if(this.prev<i.catchLoc)return a(i.catchLoc,!0)}else if(u){if(this.prev<i.finallyLoc)return a(i.finallyLoc)}else throw Error("try statement without catch or finally")}}},abrupt:function(e,t){for(var n=this.tryEntries.length-1;n>=0;--n){var a=this.tryEntries[n];if(a.tryLoc<=this.prev&&r.call(a,"finallyLoc")&&this.prev<a.finallyLoc){var s=a;break}}s&&("break"===e||"continue"===e)&&s.tryLoc<=t&&t<=s.finallyLoc&&(s=null);var i=s?s.completion:{};return(i.type=e,i.arg=t,s)?(this.method="next",this.next=s.finallyLoc,m):this.complete(i)},complete:function(e,t){if("throw"===e.type)throw e.arg;return"break"===e.type||"continue"===e.type?this.next=e.arg:"return"===e.type?(this.rval=this.arg=e.arg,this.method="return",this.next="end"):"normal"===e.type&&t&&(this.next=t),m},finish:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var n=this.tryEntries[t];if(n.finallyLoc===e)return this.complete(n.completion,n.afterLoc),C(n),m}},catch:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var n=this.tryEntries[t];if(n.tryLoc===e){var r=n.completion;if("throw"===r.type){var a=r.arg;C(n)}return a}}throw Error("illegal catch attempt")},delegateYield:function(e,n,r){return this.delegate={iterator:$(e),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=t),m}},e}(t.exports);try{regeneratorRuntime=r}catch(e){"object"==typeof globalThis?globalThis.regeneratorRuntime=r:Function("r","regeneratorRuntime = r")(r)}},36714,(e,t,n)=>{"use strict";t.exports=(e,t)=>`${e}-${t}-${Math.random().toString(16).slice(3,8)}`},12598,(e,t,n)=>{"use strict";let r=e.r(36714),a=0;t.exports=({id:e,action:t,payload:n={}})=>{let s=e;return void 0===s&&(s=r("Job",a),a+=1),{id:s,action:t,payload:n}}},77949,(e,t,n)=>{"use strict";let r=!1;n.logging=!1,n.setLogging=e=>{r=e},n.log=(...t)=>r?console.log.apply(e.e,t):null},4360,(e,t,n)=>{"use strict";let r=e.r(12598),{log:a}=e.r(77949),s=e.r(36714),i=0;t.exports=()=>{let t=s("Scheduler",i),n={},o={},l=[];i+=1;let u=()=>Object.keys(n).length,h=()=>{if(0!==l.length){let e=Object.keys(n);for(let t=0;t<e.length;t+=1)if(void 0===o[e[t]]){l[0](n[e[t]]);break}}};return{addWorker:e=>(n[e.id]=e,a(`[${t}]: Add ${e.id}`),a(`[${t}]: Number of workers=${u()}`),h(),e.id),addJob:async(n,...s)=>{if(0===u())throw Error(`[${t}]: You need to have at least one worker before adding jobs`);return new Promise((i,u)=>{let p=r({action:n,payload:s});l.push(async t=>{l.shift(),o[t.id]=p;try{i(await t[n].apply(e.e,[...s,p.id]))}catch(e){u(e)}finally{delete o[t.id],h()}}),a(`[${t}]: Add ${p.id} to JobQueue`),a(`[${t}]: JobQueue length=${l.length}`),h()})},terminate:async()=>{Object.keys(n).forEach(async e=>{await n[e].terminate()}),l=[]},getQueueLen:()=>l.length,getNumWorkers:u}}},53283,(e,t,n)=>{"use strict";var r=e.i(70795);t.exports=e=>{let t={};return("undefined"!=typeof WorkerGlobalScope?t.type="webworker":"object"==typeof document?t.type="browser":"object"==typeof r.default&&(t.type="node"),void 0===e)?t:t[e]}},13307,(e,t,n)=>{"use strict";let r="browser"===e.r(53283)("type")?e=>new URL(e,window.location.href).href:e=>e;t.exports=e=>{let t={...e};return["corePath","workerPath","langPath"].forEach(n=>{e[n]&&(t[n]=r(t[n]))}),t}},18061,(e,t,n)=>{"use strict";t.exports={TESSERACT_ONLY:0,LSTM_ONLY:1,TESSERACT_LSTM_COMBINED:2,DEFAULT:3}},59180,e=>{e.v({name:"tesseract.js",version:"7.0.0",description:"Pure Javascript Multilingual OCR",main:"src/index.js",type:"commonjs",types:"src/index.d.ts",unpkg:"dist/tesseract.min.js",jsdelivr:"dist/tesseract.min.js",scripts:{start:"node scripts/server.js",build:"rimraf dist && webpack --config scripts/webpack.config.prod.js && rollup -c scripts/rollup.esm.mjs","profile:tesseract":"webpack-bundle-analyzer dist/tesseract-stats.json","profile:worker":"webpack-bundle-analyzer dist/worker-stats.json",prepublishOnly:"npm run build",wait:"rimraf dist && wait-on http://localhost:3000/dist/tesseract.min.js",test:"npm-run-all -p -r start test:all","test:all":"npm-run-all wait test:browser test:node:all","test:browser":"karma start karma.conf.js","test:node":"nyc mocha --exit --bail --require ./scripts/test-helper.mjs","test:node:all":"npm run test:node -- ./tests/*.test.mjs",lint:"eslint src","lint:fix":"eslint --fix src",postinstall:"opencollective-postinstall || true"},browser:{"./src/worker/node/index.js":"./src/worker/browser/index.js"},author:"",contributors:["jeromewu"],license:"Apache-2.0",devDependencies:{"@babel/core":"^7.21.4","@babel/eslint-parser":"^7.21.3","@babel/preset-env":"^7.21.4","@rollup/plugin-commonjs":"^24.1.0",acorn:"^8.8.2","babel-loader":"^9.1.2",buffer:"^6.0.3",cors:"^2.8.5",eslint:"^7.32.0","eslint-config-airbnb-base":"^14.2.1","eslint-plugin-import":"^2.27.5","expect.js":"^0.3.1",express:"^4.18.2",mocha:"^10.2.0","npm-run-all":"^4.1.5",karma:"^6.4.2","karma-chrome-launcher":"^3.2.0","karma-firefox-launcher":"^2.1.2","karma-mocha":"^2.0.1","karma-webpack":"^5.0.0",nyc:"^15.1.0",rimraf:"^5.0.0",rollup:"^3.20.7","wait-on":"^7.0.1",webpack:"^5.79.0","webpack-bundle-analyzer":"^4.8.0","webpack-cli":"^5.0.1","webpack-dev-middleware":"^6.0.2","rollup-plugin-sourcemaps":"^0.6.3"},dependencies:{"bmp-js":"^0.1.0","idb-keyval":"^6.2.0","is-url":"^1.2.4","node-fetch":"^2.6.9","opencollective-postinstall":"^2.0.3","regenerator-runtime":"^0.13.3","tesseract.js-core":"^7.0.0","wasm-feature-detect":"^1.8.0",zlibjs:"^0.3.1"},overrides:{"@rollup/pluginutils":"^5.0.2"},repository:{type:"git",url:"https://github.com/naptha/tesseract.js.git"},bugs:{url:"https://github.com/naptha/tesseract.js/issues"},homepage:"https://github.com/naptha/tesseract.js",collective:{type:"opencollective",url:"https://opencollective.com/tesseractjs"}})},49567,(e,t,n)=>{"use strict";t.exports={workerBlobURL:!0,logger:()=>{}}},80880,(e,t,n)=>{"use strict";let r=e.r(59180).version;t.exports={...e.r(49567),workerPath:`https://cdn.jsdelivr.net/npm/tesseract.js@v${r}/dist/worker.min.js`}},75485,(e,t,n)=>{"use strict";t.exports=({workerPath:e,workerBlobURL:t})=>{let n;if(Blob&&URL&&t){let t=new Blob([`importScripts("${e}");`],{type:"application/javascript"});n=new Worker(URL.createObjectURL(t))}else n=new Worker(e);return n}},80848,(e,t,n)=>{"use strict";t.exports=e=>{e.terminate()}},23498,(e,t,n)=>{"use strict";t.exports=(e,t)=>{e.onmessage=({data:e})=>{t(e)}}},36834,(e,t,n)=>{"use strict";t.exports=async(e,t)=>{e.postMessage(t)}},73364,(e,t,n)=>{"use strict";let r=e=>new Promise((t,n)=>{let r=new FileReader;r.onload=()=>{t(r.result)},r.onerror=({target:{error:{code:e}}})=>{n(Error(`File could not be read! Code=${e}`))},r.readAsArrayBuffer(e)}),a=async e=>{let t=e;if(void 0===e)return"undefined";if("string"==typeof e)if(/data:image\/([a-zA-Z]*);base64,([^"]*)/.test(e))t=atob(e.split(",")[1]).split("").map(e=>e.charCodeAt(0));else{let n=await fetch(e);t=await n.arrayBuffer()}else if("undefined"!=typeof HTMLElement&&e instanceof HTMLElement)"IMG"===e.tagName&&(t=await a(e.src)),"VIDEO"===e.tagName&&(t=await a(e.poster)),"CANVAS"===e.tagName&&await new Promise(n=>{e.toBlob(async e=>{t=await r(e),n()})});else if("undefined"!=typeof OffscreenCanvas&&e instanceof OffscreenCanvas){let n=await e.convertToBlob();t=await r(n)}else(e instanceof File||e instanceof Blob)&&(t=await r(e));return new Uint8Array(t)};t.exports=a},92884,(e,t,n)=>{"use strict";let r=e.r(80880),a=e.r(75485),s=e.r(80848),i=e.r(23498);t.exports={defaultOptions:r,spawnWorker:a,terminateWorker:s,onMessage:i,send:e.r(36834),loadImage:e.r(73364)}},95602,(e,t,n)=>{"use strict";let r=e.r(13307),a=e.r(12598),{log:s}=e.r(77949),i=e.r(36714),o=e.r(18061),{defaultOptions:l,spawnWorker:u,terminateWorker:h,onMessage:p,loadImage:d,send:c}=e.r(92884),f=0;t.exports=async(e="eng",t=o.LSTM_ONLY,n={},m={})=>{let g,y,x=i("Worker",f),{logger:b,errorHandler:w,...v}=r({...l,...n}),k={},N="string"==typeof e?e.split("+"):e,I=t,S=m,C=[o.DEFAULT,o.LSTM_ONLY].includes(t)&&!v.legacyCore,T=new Promise((e,t)=>{y=e,g=t}),$=u(v);$.onerror=e=>{g(e.message)},f+=1;let E=({id:e,action:t,payload:n})=>new Promise((r,a)=>{s(`[${x}]: Start ${e}, action=${t}`),k[`${t}-${e}`]={resolve:r,reject:a},c($,{workerId:x,jobId:e,action:t,payload:n})}),A=(e,t)=>E(a({id:t,action:"loadLanguage",payload:{langs:e,options:{langPath:v.langPath,dataPath:v.dataPath,cachePath:v.cachePath,cacheMethod:v.cacheMethod,gzip:v.gzip,lstmOnly:[o.DEFAULT,o.LSTM_ONLY].includes(I)&&!v.legacyLang}}})),R=(e,t,n,r)=>E(a({id:r,action:"initialize",payload:{langs:e,oem:t,config:n}})),F=async(e,t={},n={text:!0},r)=>E(a({id:r,action:"recognize",payload:{image:await d(e),options:t,output:n}})),_=async(e,t)=>{if(C)throw Error("`worker.detect` requires Legacy model, which was not loaded.");return E(a({id:t,action:"detect",payload:{image:await d(e)}}))},D=async()=>(null!==$&&(h($),$=null),Promise.resolve());p($,({workerId:e,jobId:t,status:n,action:r,data:a})=>{let i=`${r}-${t}`;if("resolve"===n)s(`[${e}]: Complete ${t}`),k[i].resolve({jobId:t,data:a}),delete k[i];else if("reject"===n)if(k[i].reject(a),delete k[i],"load"===r&&g(a),w)w(a);else throw Error(a);else"progress"===n&&b({...a,userJobId:t})});let O={id:x,worker:$,load:()=>console.warn("`load` is depreciated and should be removed from code (workers now come pre-loaded)"),writeText:(e,t,n)=>E(a({id:n,action:"FS",payload:{method:"writeFile",args:[e,t]}})),readText:(e,t)=>E(a({id:t,action:"FS",payload:{method:"readFile",args:[e,{encoding:"utf8"}]}})),removeFile:(e,t)=>E(a({id:t,action:"FS",payload:{method:"unlink",args:[e]}})),FS:(e,t,n)=>E(a({id:n,action:"FS",payload:{method:e,args:t}})),reinitialize:(e="eng",t,n,r)=>{if(C&&[o.TESSERACT_ONLY,o.TESSERACT_LSTM_COMBINED].includes(t))throw Error("Legacy model requested but code missing.");let a=t||I;I=a;let s=n||S;S=s;let i=("string"==typeof e?e.split("+"):e).filter(e=>!N.includes(e));return(N.push(...i),i.length>0)?A(i,r).then(()=>R(e,a,s,r)):R(e,a,s,r)},setParameters:(e={},t)=>E(a({id:t,action:"setParameters",payload:{params:e}})),recognize:F,detect:_,terminate:D};return E(a({id:void 0,action:"load",payload:{options:{lstmOnly:C,corePath:v.corePath,logging:v.logging}}})).then(()=>A(e)).then(()=>R(e,t,m)).then(()=>y(O)).catch(()=>{}),T}},75558,(e,t,n)=>{"use strict";let r=e.r(95602);t.exports={recognize:async(e,t,n)=>{let a=await r(t,1,n);return a.recognize(e).finally(async()=>{await a.terminate()})},detect:async(e,t)=>{let n=await r("osd",0,t);return n.detect(e).finally(async()=>{await n.terminate()})}}},39496,(e,t,n)=>{"use strict";t.exports={AFR:"afr",AMH:"amh",ARA:"ara",ASM:"asm",AZE:"aze",AZE_CYRL:"aze_cyrl",BEL:"bel",BEN:"ben",BOD:"bod",BOS:"bos",BUL:"bul",CAT:"cat",CEB:"ceb",CES:"ces",CHI_SIM:"chi_sim",CHI_TRA:"chi_tra",CHR:"chr",CYM:"cym",DAN:"dan",DEU:"deu",DZO:"dzo",ELL:"ell",ENG:"eng",ENM:"enm",EPO:"epo",EST:"est",EUS:"eus",FAS:"fas",FIN:"fin",FRA:"fra",FRK:"frk",FRM:"frm",GLE:"gle",GLG:"glg",GRC:"grc",GUJ:"guj",HAT:"hat",HEB:"heb",HIN:"hin",HRV:"hrv",HUN:"hun",IKU:"iku",IND:"ind",ISL:"isl",ITA:"ita",ITA_OLD:"ita_old",JAV:"jav",JPN:"jpn",KAN:"kan",KAT:"kat",KAT_OLD:"kat_old",KAZ:"kaz",KHM:"khm",KIR:"kir",KOR:"kor",KUR:"kur",LAO:"lao",LAT:"lat",LAV:"lav",LIT:"lit",MAL:"mal",MAR:"mar",MKD:"mkd",MLT:"mlt",MSA:"msa",MYA:"mya",NEP:"nep",NLD:"nld",NOR:"nor",ORI:"ori",PAN:"pan",POL:"pol",POR:"por",PUS:"pus",RON:"ron",RUS:"rus",SAN:"san",SIN:"sin",SLK:"slk",SLV:"slv",SPA:"spa",SPA_OLD:"spa_old",SQI:"sqi",SRP:"srp",SRP_LATN:"srp_latn",SWA:"swa",SWE:"swe",SYR:"syr",TAM:"tam",TEL:"tel",TGK:"tgk",TGL:"tgl",THA:"tha",TIR:"tir",TUR:"tur",UIG:"uig",UKR:"ukr",URD:"urd",UZB:"uzb",UZB_CYRL:"uzb_cyrl",VIE:"vie",YID:"yid"}},53806,(e,t,n)=>{"use strict";t.exports={OSD_ONLY:"0",AUTO_OSD:"1",AUTO_ONLY:"2",AUTO:"3",SINGLE_COLUMN:"4",SINGLE_BLOCK_VERT_TEXT:"5",SINGLE_BLOCK:"6",SINGLE_LINE:"7",SINGLE_WORD:"8",CIRCLE_WORD:"9",SINGLE_CHAR:"10",SPARSE_TEXT:"11",SPARSE_TEXT_OSD:"12",RAW_LINE:"13"}},24533,(e,t,n)=>{"use strict";e.r(57999);let r=e.r(4360),a=e.r(95602),s=e.r(75558),i=e.r(39496),o=e.r(18061),l=e.r(53806),{setLogging:u}=e.r(77949);t.exports={languages:i,OEM:o,PSM:l,createScheduler:r,createWorker:a,setLogging:u,...s}},53373,(e,t,n)=>{t.exports=a;var r=null;try{r=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(e){}function a(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function s(e){return!0===(e&&e.__isLong__)}a.prototype.__isLong__,Object.defineProperty(a.prototype,"__isLong__",{value:!0}),a.isLong=s;var i={},o={};function l(e,t){var n,r,a;if(t)return(e>>>=0,(a=0<=e&&e<256)&&(r=o[e]))?r:(n=h(e,(0|e)<0?-1:0,!0),a&&(o[e]=n),n);return(e|=0,(a=-128<=e&&e<128)&&(r=i[e]))?r:(n=h(e,e<0?-1:0,!1),a&&(i[e]=n),n)}function u(e,t){if(isNaN(e))return t?b:x;if(t){if(e<0)return b;if(e>=m)return I}else{if(e<=-g)return S;if(e+1>=g)return N}return e<0?u(-e,t).neg():h(e%f|0,e/f|0,t)}function h(e,t,n){return new a(e,t,n)}a.fromInt=l,a.fromNumber=u,a.fromBits=h;var p=Math.pow;function d(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return x;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return d(e.substring(1),t,n).neg();for(var r,a=u(p(n,8)),s=x,i=0;i<e.length;i+=8){var o=Math.min(8,e.length-i),l=parseInt(e.substring(i,i+o),n);if(o<8){var h=u(p(n,o));s=s.mul(h).add(u(l))}else s=(s=s.mul(a)).add(u(l))}return s.unsigned=t,s}function c(e,t){return"number"==typeof e?u(e,t):"string"==typeof e?d(e,t):h(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}a.fromString=d,a.fromValue=c;var f=0x100000000,m=0xffffffffffffffff,g=0x8000000000000000,y=l(0x1000000),x=l(0);a.ZERO=x;var b=l(0,!0);a.UZERO=b;var w=l(1);a.ONE=w;var v=l(1,!0);a.UONE=v;var k=l(-1);a.NEG_ONE=k;var N=h(-1,0x7fffffff,!1);a.MAX_VALUE=N;var I=h(-1,-1,!0);a.MAX_UNSIGNED_VALUE=I;var S=h(0,-0x80000000,!1);a.MIN_VALUE=S;var C=a.prototype;C.toInt=function(){return this.unsigned?this.low>>>0:this.low},C.toNumber=function(){return this.unsigned?(this.high>>>0)*f+(this.low>>>0):this.high*f+(this.low>>>0)},C.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(!this.eq(S))return"-"+this.neg().toString(e);else{var t=u(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}for(var a=u(p(e,6),this.unsigned),s=this,i="";;){var o=s.div(a),l=(s.sub(o.mul(a)).toInt()>>>0).toString(e);if((s=o).isZero())return l+i;for(;l.length<6;)l="0"+l;i=""+l+i}},C.getHighBits=function(){return this.high},C.getHighBitsUnsigned=function(){return this.high>>>0},C.getLowBits=function(){return this.low},C.getLowBitsUnsigned=function(){return this.low>>>0},C.getNumBitsAbs=function(){if(this.isNegative())return this.eq(S)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&(e&1<<t)==0;t--);return 0!=this.high?t+33:t+1},C.isZero=function(){return 0===this.high&&0===this.low},C.eqz=C.isZero,C.isNegative=function(){return!this.unsigned&&this.high<0},C.isPositive=function(){return this.unsigned||this.high>=0},C.isOdd=function(){return(1&this.low)==1},C.isEven=function(){return(1&this.low)==0},C.equals=function(e){return s(e)||(e=c(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&this.high===e.high&&this.low===e.low},C.eq=C.equals,C.notEquals=function(e){return!this.eq(e)},C.neq=C.notEquals,C.ne=C.notEquals,C.lessThan=function(e){return 0>this.comp(e)},C.lt=C.lessThan,C.lessThanOrEqual=function(e){return 0>=this.comp(e)},C.lte=C.lessThanOrEqual,C.le=C.lessThanOrEqual,C.greaterThan=function(e){return this.comp(e)>0},C.gt=C.greaterThan,C.greaterThanOrEqual=function(e){return this.comp(e)>=0},C.gte=C.greaterThanOrEqual,C.ge=C.greaterThanOrEqual,C.compare=function(e){if(s(e)||(e=c(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},C.comp=C.compare,C.negate=function(){return!this.unsigned&&this.eq(S)?S:this.not().add(w)},C.neg=C.negate,C.add=function(e){s(e)||(e=c(e));var t,n,r=this.high>>>16,a=65535&this.high,i=this.low>>>16,o=65535&this.low,l=e.high>>>16,u=65535&e.high,p=e.low>>>16,d=65535&e.low,f=0,m=0;return t=0+((n=0+(o+d))>>>16),n&=65535,t+=i+p,m+=t>>>16,t&=65535,m+=a+u,f+=m>>>16,m&=65535,f+=r+l,h(t<<16|n,(f&=65535)<<16|m,this.unsigned)},C.subtract=function(e){return s(e)||(e=c(e)),this.add(e.neg())},C.sub=C.subtract,C.multiply=function(e){if(this.isZero())return x;if(s(e)||(e=c(e)),r)return h(r.mul(this.low,this.high,e.low,e.high),r.get_high(),this.unsigned);if(e.isZero())return x;if(this.eq(S))return e.isOdd()?S:x;if(e.eq(S))return this.isOdd()?S:x;if(this.isNegative())if(e.isNegative())return this.neg().mul(e.neg());else return this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(y)&&e.lt(y))return u(this.toNumber()*e.toNumber(),this.unsigned);var t,n,a=this.high>>>16,i=65535&this.high,o=this.low>>>16,l=65535&this.low,p=e.high>>>16,d=65535&e.high,f=e.low>>>16,m=65535&e.low,g=0,b=0;return t=0+((n=0+l*m)>>>16),n&=65535,t+=o*m,b+=t>>>16,t&=65535,t+=l*f,b+=t>>>16,t&=65535,b+=i*m,g+=b>>>16,b&=65535,b+=o*f,g+=b>>>16,b&=65535,b+=l*d,g+=b>>>16,b&=65535,g+=a*m+i*f+o*d+l*p,h(t<<16|n,(g&=65535)<<16|b,this.unsigned)},C.mul=C.multiply,C.divide=function(e){if(s(e)||(e=c(e)),e.isZero())throw Error("division by zero");if(r){var t,n,a;return this.unsigned||-0x80000000!==this.high||-1!==e.low||-1!==e.high?h((this.unsigned?r.div_u:r.div_s)(this.low,this.high,e.low,e.high),r.get_high(),this.unsigned):this}if(this.isZero())return this.unsigned?b:x;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return b;if(e.gt(this.shru(1)))return v;a=b}else{if(this.eq(S))if(e.eq(w)||e.eq(k))return S;else return e.eq(S)?w:(t=this.shr(1).div(e).shl(1)).eq(x)?e.isNegative()?w:k:(n=this.sub(e.mul(t)),a=t.add(n.div(e)));if(e.eq(S))return this.unsigned?b:x;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();a=x}for(n=this;n.gte(e);){for(var i=Math.ceil(Math.log(t=Math.max(1,Math.floor(n.toNumber()/e.toNumber())))/Math.LN2),o=i<=48?1:p(2,i-48),l=u(t),d=l.mul(e);d.isNegative()||d.gt(n);)t-=o,d=(l=u(t,this.unsigned)).mul(e);l.isZero()&&(l=w),a=a.add(l),n=n.sub(d)}return a},C.div=C.divide,C.modulo=function(e){return(s(e)||(e=c(e)),r)?h((this.unsigned?r.rem_u:r.rem_s)(this.low,this.high,e.low,e.high),r.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},C.mod=C.modulo,C.rem=C.modulo,C.not=function(){return h(~this.low,~this.high,this.unsigned)},C.and=function(e){return s(e)||(e=c(e)),h(this.low&e.low,this.high&e.high,this.unsigned)},C.or=function(e){return s(e)||(e=c(e)),h(this.low|e.low,this.high|e.high,this.unsigned)},C.xor=function(e){return s(e)||(e=c(e)),h(this.low^e.low,this.high^e.high,this.unsigned)},C.shiftLeft=function(e){return(s(e)&&(e=e.toInt()),0==(e&=63))?this:e<32?h(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):h(0,this.low<<e-32,this.unsigned)},C.shl=C.shiftLeft,C.shiftRight=function(e){return(s(e)&&(e=e.toInt()),0==(e&=63))?this:e<32?h(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):h(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},C.shr=C.shiftRight,C.shiftRightUnsigned=function(e){if(s(e)&&(e=e.toInt()),0==(e&=63))return this;var t=this.high;return e<32?h(this.low>>>e|t<<32-e,t>>>e,this.unsigned):32===e?h(t,0,this.unsigned):h(t>>>e-32,0,this.unsigned)},C.shru=C.shiftRightUnsigned,C.shr_u=C.shiftRightUnsigned,C.toSigned=function(){return this.unsigned?h(this.low,this.high,!1):this},C.toUnsigned=function(){return this.unsigned?this:h(this.low,this.high,!0)},C.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},C.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},C.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},a.fromBytes=function(e,t,n){return n?a.fromBytesLE(e,t):a.fromBytesBE(e,t)},a.fromBytesLE=function(e,t){return new a(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},a.fromBytesBE=function(e,t){return new a(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},89472,(e,t,n)=>{!function(t,n,r){function a(e){var t,n=this,r=(t=0xefc8249d,function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));t=r>>>0,r-=t,r*=t,t=r>>>0,r-=t,t+=0x100000000*r}return(t>>>0)*23283064365386963e-26});n.next=function(){var e=2091639*n.s0+23283064365386963e-26*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1)}function s(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function i(e,t){var n=new a(e),r=t&&t.state,i=n.next;return i.int32=function(){return 0x100000000*n.next()|0},i.double=function(){return i()+(2097152*i()|0)*11102230246251565e-32},i.quick=i,r&&("object"==typeof r&&s(r,n),i.state=function(){return s(n,{})}),i}if(n&&n.exports)n.exports=i;else if(r&&r.amd)e.r,void 0!==i&&e.v(i);else this.alea=i}(e.e,t,"function"==typeof define&&define)},6322,(e,t,n)=>{!function(t,n,r){function a(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=n.charCodeAt(r),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function i(e,t){var n=new a(e),r=t&&t.state,i=function(){return(n.next()>>>0)/0x100000000};return i.double=function(){do var e=((n.next()>>>11)+(n.next()>>>0)/0x100000000)/2097152;while(0===e)return e},i.int32=n.next,i.quick=i,r&&("object"==typeof r&&s(r,n),i.state=function(){return s(n,{})}),i}if(n&&n.exports)n.exports=i;else if(r&&r.amd)e.r,void 0!==i&&e.v(i);else this.xor128=i}(e.e,t,"function"==typeof define&&define)},49439,(e,t,n)=>{!function(t,n,r){function a(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^(e^e<<1))|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function i(e,t){var n=new a(e),r=t&&t.state,i=function(){return(n.next()>>>0)/0x100000000};return i.double=function(){do var e=((n.next()>>>11)+(n.next()>>>0)/0x100000000)/2097152;while(0===e)return e},i.int32=n.next,i.quick=i,r&&("object"==typeof r&&s(r,n),i.state=function(){return s(n,{})}),i}if(n&&n.exports)n.exports=i;else if(r&&r.amd)e.r,void 0!==i&&e.v(i);else this.xorwow=i}(e.e,t,"function"==typeof define&&define)},8047,(e,t,n)=>{!function(t,n,r){function a(e){var t=this;t.next=function(){var e,n,r=t.x,a=t.i;return e=r[a],e^=e>>>7,n=e^e<<24^((e=r[a+1&7])^e>>>10)^((e=r[a+3&7])^e>>>3)^((e=r[a+4&7])^e<<7),e=r[a+7&7],e^=e<<13,n^=e^e<<9,r[a]=n,t.i=a+1&7,n};var n,r=e,a=[];if(r===(0|r))a[0]=r;else for(n=0,r=""+r;n<r.length;++n)a[7&n]=a[7&n]<<15^r.charCodeAt(n)+a[n+1&7]<<13;for(;a.length<8;)a.push(0);for(n=0;n<8&&0===a[n];++n);for(8==n?a[7]=-1:a[n],t.x=a,t.i=0,n=256;n>0;--n)t.next()}function s(e,t){return t.x=e.x.slice(),t.i=e.i,t}function i(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,i=function(){return(n.next()>>>0)/0x100000000};return i.double=function(){do var e=((n.next()>>>11)+(n.next()>>>0)/0x100000000)/2097152;while(0===e)return e},i.int32=n.next,i.quick=i,r&&(r.x&&s(r,n),i.state=function(){return s(n,{})}),i}if(n&&n.exports)n.exports=i;else if(r&&r.amd)e.r,void 0!==i&&e.v(i);else this.xorshift7=i}(e.e,t,"function"==typeof define&&define)},72469,(e,t,n)=>{!function(t,n,r){function a(e){var t=this;t.next=function(){var e,n,r=t.w,a=t.X,s=t.i;return t.w=r=r+0x61c88647|0,n=a[s+34&127],e=a[s=s+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=a[s]=n^e,t.i=s,n+(r^r>>>16)|0},!function(e,t){var n,r,a,s,i,o=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),a=0,s=-32;s<l;++s)t&&(r^=t.charCodeAt((s+32)%t.length)),0===s&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,s>=0&&(i=i+0x61c88647|0,a=0==(n=o[127&s]^=r+i)?a+1:0);for(a>=128&&(o[127&(t&&t.length||0)]=-1),a=127,s=512;s>0;--s)r=o[a+34&127],n=o[a=a+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[a]=r^n;e.w=i,e.X=o,e.i=a}(t,e)}function s(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function i(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,i=function(){return(n.next()>>>0)/0x100000000};return i.double=function(){do var e=((n.next()>>>11)+(n.next()>>>0)/0x100000000)/2097152;while(0===e)return e},i.int32=n.next,i.quick=i,r&&(r.X&&s(r,n),i.state=function(){return s(n,{})}),i}if(n&&n.exports)n.exports=i;else if(r&&r.amd)e.r,void 0!==i&&e.v(i);else this.xor4096=i}(e.e,t,"function"==typeof define&&define)},5348,(e,t,n)=>{!function(t,n,r){function a(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,a=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^a,a=a-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^a,t.a=a-e|0},t.a=0,t.b=0,t.c=-0x61c88647,t.d=0x517cc1b7,e===Math.floor(e)?(t.a=e/0x100000000|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=n.charCodeAt(r),t.next()}function s(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function i(e,t){var n=new a(e),r=t&&t.state,i=function(){return(n.next()>>>0)/0x100000000};return i.double=function(){do var e=((n.next()>>>11)+(n.next()>>>0)/0x100000000)/2097152;while(0===e)return e},i.int32=n.next,i.quick=i,r&&("object"==typeof r&&s(r,n),i.state=function(){return s(n,{})}),i}if(n&&n.exports)n.exports=i;else if(r&&r.amd)e.r,void 0!==i&&e.v(i);else this.tychei=i}(e.e,t,"function"==typeof define&&define)},4572,(e,t,n)=>{!function(n,r,a){var s,i="random",o=a.pow(256,6),l=a.pow(2,52),u=2*l;function h(e,t,h){var m=[],g=c(function e(t,n){var r,a=[],s=typeof t;if(n&&"object"==s)for(r in t)try{a.push(e(t[r],n-1))}catch(e){}return a.length?a:"string"==s?t:t+"\0"}((t=!0==t?{entropy:!0}:t||{}).entropy?[e,f(r)]:null==e?function(){try{var e;return s&&(e=s.randomBytes)?e=e(256):(e=new Uint8Array(256),(n.crypto||n.msCrypto).getRandomValues(e)),f(e)}catch(e){var t=n.navigator,a=t&&t.plugins;return[+new Date,n,a,n.screen,f(r)]}}():e,3),m),y=new p(m),x=function(){for(var e=y.g(6),t=o,n=0;e<l;)e=(e+n)*256,t*=256,n=y.g(1);for(;e>=u;)e/=2,t/=2,n>>>=1;return(e+n)/t};return x.int32=function(){return 0|y.g(4)},x.quick=function(){return y.g(4)/0x100000000},x.double=x,c(f(y.S),r),(t.pass||h||function(e,t,n,r){return(r&&(r.S&&d(r,y),e.state=function(){return d(y,{})}),n)?(a[i]=e,t):e})(x,g,"global"in t?t.global:this==a,t.state)}function p(e){var t,n=e.length,r=this,a=0,s=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);a<256;)i[a]=a++;for(a=0;a<256;a++)i[a]=i[s=255&s+e[a%n]+(t=i[a])],i[s]=t;(r.g=function(e){for(var t,n=0,a=r.i,s=r.j,i=r.S;e--;)t=i[a=255&a+1],n=256*n+i[255&(i[a]=i[s=255&s+t])+(i[s]=t)];return r.i=a,r.j=s,n})(256)}function d(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function c(e,t){for(var n,r=e+"",a=0;a<r.length;)t[255&a]=255&(n^=19*t[255&a])+r.charCodeAt(a++);return f(t)}function f(e){return String.fromCharCode.apply(0,e)}if(c(a.random(),r),t.exports){t.exports=h;try{s={}}catch(e){}}else if("function"==typeof define&&define.amd)e.r,void 0!==h&&e.v(h);else a["seed"+i]=h}("undefined"!=typeof self?self:e.e,[],Math)},80586,(e,t,n)=>{var r=e.r(89472),a=e.r(6322),s=e.r(49439),i=e.r(8047),o=e.r(72469),l=e.r(5348),u=e.r(4572);u.alea=r,u.xor128=a,u.xorwow=s,u.xorshift7=i,u.xor4096=o,u.tychei=l,t.exports=u},34437,e=>{"use strict";let t,n,r,a,s,i,o,l;var u,h,p,d,c,f,m,g,y,x,b,w,v,k,N,I,S,C,T,$,E,A,R,F,_,D,O,M,L,z,P,B=e.i(8250),W=e.i(50067),U=e.i(74456),j=e.i(40487),V=e.i(83951);let G=({initialUrl:e="https://www.google.com",onUrlChange:t,omnibarUrl:n})=>{let[r,a]=(0,W.useState)(e),[s,i]=(0,W.useState)(!0),[o,l]=(0,W.useState)(!1),u=(0,W.useRef)(!1);return(0,W.useEffect)(()=>{if(u.current=!0,window.electronAPI){l(!0),window.electronAPI.navigateTo(e);let n=setInterval(async()=>{if(u.current)try{let e=await window.electronAPI.getCurrentUrl();e&&e!==r&&(a(e),t?.(e))}catch(e){console.error("Error polling URL:",e)}},1e3);return setTimeout(()=>i(!1),800),()=>{u.current=!1,clearInterval(n)}}l(!1),i(!1),a(e)},[e,t]),(0,W.useEffect)(()=>{n&&n!==r&&(window.electronAPI?(window.electronAPI.navigateTo(n),i(!0),setTimeout(()=>i(!1),500)):a(n))},[n]),(0,B.jsxs)("div",{className:"w-full h-full relative overflow-hidden bg-[#050510]",children:[(0,B.jsx)(V.AnimatePresence,{children:s&&(0,B.jsxs)(j.motion.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},className:"absolute inset-0 z-50 flex flex-col items-center justify-center bg-[#050510] text-deep-space-text",children:[(0,B.jsxs)("div",{className:"relative w-16 h-16 mb-4",children:[(0,B.jsx)("div",{className:"absolute inset-0 border-4 border-deep-space-accent-neon/20 rounded-full"}),(0,B.jsx)("div",{className:"absolute inset-0 border-4 border-deep-space-accent-neon rounded-full border-t-transparent animate-spin"})]}),(0,B.jsx)("p",{className:"text-sm font-medium tracking-widest uppercase animate-pulse",children:"Navigating"})]})}),o?(0,B.jsxs)("div",{className:"w-full h-full flex flex-col items-center justify-center pointer-events-none opacity-10",children:[(0,B.jsx)("span",{className:"text-6xl mb-4",children:"ðŸ–¥ï¸"}),(0,B.jsx)("p",{className:"text-white/40 text-sm font-light",children:"Desktop View Rendering..."})]}):(0,B.jsx)("iframe",{src:r,className:"w-full h-full border-0 bg-white",title:"Browser Content",sandbox:"allow-same-origin allow-scripts allow-forms allow-popups"})]})},H={google:{name:"Google",url:"https://www.google.com/search?q="},duckduckgo:{name:"DuckDuckGo",url:"https://duckduckgo.com/?q="},bing:{name:"Bing",url:"https://www.bing.com/search?q="}},q=({selectedEngine:e,setSelectedEngine:t})=>(0,B.jsxs)("div",{className:"space-y-2",children:[(0,B.jsx)("label",{className:"block text-[10px] uppercase font-bold tracking-widest text-white/40",children:"Default Engine"}),(0,B.jsx)("div",{className:"grid grid-cols-1 gap-1.5",children:Object.entries(H).map(([n,r])=>(0,B.jsxs)("button",{onClick:()=>t(n),className:`w-full px-3 py-2 flex items-center justify-between rounded-xl border transition-all ${e===n?"bg-white/10 border-white/20 text-white":"bg-transparent border-transparent text-white/40 hover:bg-white/5"}`,children:[(0,B.jsx)("span",{className:"text-xs",children:r.name}),e===n&&(0,B.jsx)("span",{className:"text-[10px] text-deep-space-accent-neon",children:"â—"})]},n))})]}),K=({theme:e,setTheme:t,backgroundImage:n,setBackgroundImage:r})=>(0,B.jsxs)("div",{className:"space-y-4",children:[(0,B.jsxs)("div",{className:"space-y-2",children:[(0,B.jsx)("label",{className:"block text-[10px] uppercase font-bold tracking-widest text-white/40",children:"Theme"}),(0,B.jsx)("div",{className:"grid grid-cols-3 gap-2",children:["dark","light","system"].map(n=>(0,B.jsx)("button",{onClick:()=>t(n),className:`py-1.5 rounded-lg border text-[10px] uppercase font-bold tracking-wider transition-all ${e===n?"bg-deep-space-accent-neon/20 border-deep-space-accent-neon/40 text-deep-space-accent-neon shadow-[0_0_10px_rgba(0,255,255,0.1)]":"bg-white/5 border-white/5 text-white/30 hover:bg-white/10"}`,children:n},n))})]}),(0,B.jsxs)("div",{className:"space-y-2",children:[(0,B.jsx)("label",{className:"block text-[10px] uppercase font-bold tracking-widest text-white/40",children:"Canvas Overlay"}),(0,B.jsx)("input",{type:"text",placeholder:"Image URL...",className:"w-full bg-black/20 border border-white/5 rounded-lg px-3 py-2 text-xs text-white placeholder:text-white/10 focus:border-deep-space-accent-neon/30 outline-none transition-all",value:n,onChange:e=>r(e.target.value)})]})]});var X=e.i(70795);let Y=({backend:e,setBackend:t,mysqlConfig:n,setMysqlConfig:r})=>{let a=X.default.env.NEXT_PUBLIC_BACKEND_STRATEGY;if(a)return(0,B.jsxs)("div",{className:"p-4 rounded-xl bg-deep-space-accent-neon/5 border border-deep-space-accent-neon/20",children:[(0,B.jsx)("p",{className:"text-[10px] font-bold uppercase tracking-widest text-deep-space-accent-neon mb-1",children:"Backup Strategy"}),(0,B.jsxs)("p",{className:"text-xs text-white/60",children:["Managed by Administrator (",a,")"]})]});let s=e=>{let{name:t,value:n}=e.target;r(e=>({...e,[t]:n}))};return(0,B.jsxs)("div",{className:"space-y-4",children:[(0,B.jsxs)("div",{className:"space-y-2",children:[(0,B.jsx)("label",{className:"block text-[10px] uppercase font-bold tracking-widest text-white/40",children:"Data Strategy"}),(0,B.jsx)("div",{className:"grid grid-cols-2 gap-2",children:["firebase","mysql"].map(n=>(0,B.jsx)("button",{onClick:()=>t(n),className:`py-1.5 rounded-lg border text-[10px] uppercase font-bold tracking-wider transition-all ${e===n?"bg-deep-space-accent-neon/20 border-deep-space-accent-neon/40 text-deep-space-accent-neon":"bg-white/5 border-white/5 text-white/30 hover:bg-white/10"}`,children:n},n))})]}),"mysql"===e&&(0,B.jsxs)("div",{className:"space-y-2 pt-2 border-t border-white/5",children:[["host","user","database"].map(e=>(0,B.jsx)("input",{type:"text",name:e,placeholder:`MySQL ${e.charAt(0).toUpperCase()+e.slice(1)}`,className:"w-full bg-black/20 border border-white/5 rounded-lg px-3 py-2 text-xs text-white placeholder:text-white/10 focus:border-deep-space-accent-neon/30 outline-none",value:n[e]||"",onChange:s},e)),(0,B.jsx)("input",{type:"password",name:"password",placeholder:"MySQL Password",className:"w-full bg-black/20 border border-white/5 rounded-lg px-3 py-2 text-xs text-white placeholder:text-white/10 focus:border-deep-space-accent-neon/30 outline-none",value:n.password||"",onChange:s})]})]})};class Z{id="openai-compatible";name="OpenAI Compatible";apiKey;baseUrl;model;constructor(e){e&&this.init(e)}init(e){this.apiKey=e.apiKey,this.baseUrl=e.baseUrl||"https://api.openai.com/v1",this.model=e.model||"gpt-3.5-turbo"}async generateContent(e,t){return this.generateChatContent([{role:"user",content:e}],t)}async generateChatContent(e,t){if(!this.apiKey)return{error:"API key is not configured for OpenAI Compatible provider."};if(!this.baseUrl)return{error:"Base URL is not configured for OpenAI Compatible provider."};if(!this.model)return{error:"Model is not configured for OpenAI Compatible provider."};try{let n={"Content-Type":"application/json",Authorization:`Bearer ${this.apiKey}`,...t?.headers},r=JSON.stringify({model:this.model,messages:e.map(e=>({role:e.role,content:e.content})),...t?.body}),a=await fetch(`${this.baseUrl}/chat/completions`,{method:"POST",headers:n,body:r});if(!a.ok){let e=await a.json();return{error:`OpenAI Compatible API error: ${a.status} - ${e.error?.message||a.statusText}`}}let s=await a.json();return{text:s.choices[0]?.message?.content||""}}catch(e){return{error:`Network or other error: ${e.message}`}}}}var J=e.i(45766),Q=e.i(40370);let ee=(0,Q.default)("cloud",[["path",{d:"M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z",key:"p7xjir"}]]),et=(0,Q.default)("settings",[["path",{d:"M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915",key:"1i5ecw"}],["circle",{cx:"12",cy:"12",r:"3",key:"1v7zrd"}]]),en=(0,Q.default)("save",[["path",{d:"M15.2 3a2 2 0 0 1 1.4.6l3.8 3.8a2 2 0 0 1 .6 1.4V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z",key:"1c8476"}],["path",{d:"M17 21v-7a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v7",key:"1ydtos"}],["path",{d:"M7 3v4a1 1 0 0 0 1 1h7",key:"t51u73"}]]);var er=e.i(38870);let ea=(0,Q.default)("database",[["ellipse",{cx:"12",cy:"5",rx:"9",ry:"3",key:"msslwz"}],["path",{d:"M3 5V19A9 3 0 0 0 21 19V5",key:"1wlel7"}],["path",{d:"M3 12A9 3 0 0 0 21 12",key:"mv7ke4"}]]),es=e=>{let t=(0,U.useAppStore)(),[n,r]=(0,W.useState)([]),[a,s]=(0,W.useState)(null),[i,o]=(0,W.useState)({}),[l,u]=(0,W.useState)(!1),[h,p]=(0,W.useState)(null),d=(0,W.useMemo)(()=>new Z,[]);(0,W.useEffect)(()=>{(async()=>{if(window.electronAPI)try{let e=await window.electronAPI.getAvailableLLMProviders();if(e&&e.length>0){r(e);let n="local"===t.aiProvider?"local":e[0].id;s(n);return}}catch(e){console.warn("Electron LLM API failed, falling back to local:",e)}r([{id:"openai-compatible",name:"OpenAI (Cloud)"},{id:"local",name:"Browser AI (Local TF.js)"}]),s("local"===t.aiProvider?"local":"openai-compatible")})()},[t.aiProvider]);let c=async e=>{let n=e.target.value;s(n),t.setAIProvider(n),window.electronAPI&&await window.electronAPI.setActiveLLMProvider(n)},f=e=>{let{name:t,value:n}=e.target;o(e=>({...e,[t]:n}))},m=async()=>{a&&(window.electronAPI?p(await window.electronAPI.configureLLMProvider(a,i)?"Config Saved":"Failed to Save"):(d.init(i),p("Local Config Saved")),setTimeout(()=>p(null),3e3))};return(0,B.jsxs)("div",{className:"border border-white/5 rounded-2xl overflow-hidden glass-dark transition-all",children:[(0,B.jsxs)("button",{onClick:()=>u(!l),className:"w-full flex items-center justify-between p-4 hover:bg-white/5 transition-colors",children:[(0,B.jsxs)("div",{className:"flex items-center gap-2",children:[(0,B.jsx)(et,{size:14,className:"text-white/40"}),(0,B.jsx)("span",{className:"text-white/60 text-[10px] font-black uppercase tracking-widest",children:"Ecosystem Settings"})]}),(0,B.jsx)("span",{className:`text-[10px] text-white/30 transform transition-transform duration-300 ${l?"rotate-180":""}`,children:"â–¼"})]}),(0,B.jsx)(V.AnimatePresence,{children:l&&(0,B.jsx)(j.motion.div,{initial:{height:0,opacity:0},animate:{height:"auto",opacity:1},exit:{height:0,opacity:0},className:"overflow-hidden border-t border-white/5",children:(0,B.jsxs)("div",{className:"p-4 space-y-6 custom-scrollbar max-h-[450px] overflow-y-auto",children:[(0,B.jsx)(K,{...e}),(0,B.jsx)(q,{...e}),(0,B.jsx)(Y,{...e}),(0,B.jsxs)("div",{className:"space-y-4 pt-4 border-t border-white/5",children:[(0,B.jsxs)("div",{className:"flex items-center gap-2 mb-2",children:[(0,B.jsx)(ee,{size:12,className:"text-deep-space-accent-neon"}),(0,B.jsx)("label",{className:"block text-[10px] uppercase font-black tracking-widest text-white/40",children:"AI Orchestration"})]}),(0,B.jsx)("select",{className:"w-full bg-black/40 border border-white/10 rounded-xl px-3 py-3 text-xs text-white focus:outline-none focus:ring-1 focus:ring-deep-space-accent-neon/50 transition-all font-bold",value:a||"",onChange:c,children:n.map(e=>(0,B.jsx)("option",{value:e.id,children:e.name},e.id))}),(0,B.jsxs)("div",{className:"p-4 rounded-2xl bg-white/[0.02] border border-white/5",children:["local"===a?(0,B.jsxs)("div",{className:"space-y-3",children:[(0,B.jsxs)("div",{className:"flex items-center gap-3 text-deep-space-accent-neon mb-2",children:[(0,B.jsx)(J.Cpu,{size:16}),(0,B.jsx)("span",{className:"text-[10px] font-black uppercase tracking-widest",children:"Local Neural Engine"})]}),(0,B.jsx)("p",{className:"text-[10px] text-white/30 uppercase tracking-widest leading-relaxed",children:"Using on-device TensorFlow.js & WebGPU. No data leaves your machine. High privacy, low latency."}),(0,B.jsxs)("div",{className:"flex items-center gap-2 py-2 px-3 bg-white/5 rounded-lg border border-white/5",children:[(0,B.jsx)(er.Shield,{size:10,className:"text-green-400"}),(0,B.jsx)("span",{className:"text-[9px] font-bold text-white/60 uppercase",children:"E2E Privacy Verified"})]})]}):(0,B.jsxs)("div",{className:"space-y-3",children:[(0,B.jsx)("input",{type:"password",name:"apiKey",placeholder:"Cloud API Key",className:"w-full bg-black/20 border border-white/5 rounded-lg px-3 py-2.5 text-xs text-white placeholder:text-white/10 focus:border-deep-space-accent-neon/30 outline-none transition-all",value:i.apiKey||"",onChange:f}),(0,B.jsx)("input",{type:"text",name:"baseUrl",placeholder:"Base URL (Optional)",className:"w-full bg-black/20 border border-white/5 rounded-lg px-3 py-2.5 text-xs text-white placeholder:text-white/10 focus:border-deep-space-accent-neon/30 outline-none transition-all",value:i.baseUrl||"",onChange:f}),(0,B.jsx)("input",{type:"text",name:"model",placeholder:"Model (e.g. gpt-4o)",className:"w-full bg-black/20 border border-white/5 rounded-lg px-3 py-2.5 text-xs text-white placeholder:text-white/10 focus:border-deep-space-accent-neon/30 outline-none transition-all",value:i.model||"",onChange:f})]}),(0,B.jsxs)("button",{onClick:m,className:"w-full mt-4 py-3 bg-deep-space-accent-neon/10 border border-deep-space-accent-neon/20 hover:bg-deep-space-accent-neon/20 text-deep-space-accent-neon text-[10px] font-black uppercase tracking-widest rounded-xl transition-all flex items-center justify-center gap-2",children:[(0,B.jsx)(en,{size:12}),h||"Save Intelligence Config"]})]})]}),(0,B.jsxs)("div",{className:"pt-4 border-t border-white/5 flex items-center justify-between",children:[(0,B.jsxs)("div",{className:"flex items-center gap-2",children:[(0,B.jsx)(ea,{size:12,className:"text-white/40"}),(0,B.jsx)("span",{className:"text-[10px] uppercase font-black tracking-widest text-white/30",children:"Vault Status"})]}),(0,B.jsx)("span",{className:"text-[10px] font-black text-green-500 uppercase tracking-widest",children:"Secure"})]})]})})})]})};var ei=e.i(83885);let eo=()=>(0,B.jsxs)("div",{className:"flex items-center gap-3",children:[(0,B.jsx)("div",{className:"flex gap-1.5",children:[0,1,2].map(e=>(0,B.jsx)(j.motion.div,{className:"w-1.5 h-1.5 bg-deep-space-accent-neon rounded-full",animate:{scale:[1,1.5,1],opacity:[.3,1,.3]},transition:{duration:1,repeat:1/0,delay:.2*e,ease:"easeInOut"}},e))}),(0,B.jsx)("span",{className:"text-[10px] font-bold uppercase tracking-widest text-deep-space-accent-neon/60",children:"Assistant is thinking"})]}),el=(0,Q.default)("search",[["path",{d:"m21 21-4.34-4.34",key:"14j7rj"}],["circle",{cx:"11",cy:"11",r:"8",key:"4ej97u"}]]),eu=(0,Q.default)("image",[["rect",{width:"18",height:"18",x:"3",y:"3",rx:"2",ry:"2",key:"1m3agn"}],["circle",{cx:"9",cy:"9",r:"2",key:"af1f0g"}],["path",{d:"m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21",key:"1xmnt7"}]]),eh=(0,Q.default)("plus",[["path",{d:"M5 12h14",key:"1ays0h"}],["path",{d:"M12 5v14",key:"s699le"}]]),ep=({onSelect:e})=>(0,B.jsxs)("div",{className:"p-4 bg-white/5 border border-white/5 rounded-2xl space-y-3",children:[(0,B.jsxs)("div",{className:"flex items-center justify-between text-[10px] font-bold uppercase tracking-widest text-white/30",children:[(0,B.jsxs)("div",{className:"flex items-center gap-2",children:[(0,B.jsx)(eu,{size:12}),(0,B.jsx)("span",{children:"Visual Assets"})]}),(0,B.jsx)("button",{className:"hover:text-white",children:(0,B.jsx)(el,{size:10})})]}),(0,B.jsx)("div",{className:"grid grid-cols-3 gap-2",children:["https://images.unsplash.com/photo-1451187580459-43490279c0fa?q=80&w=200&auto=format&fit=crop","https://images.unsplash.com/photo-1518770660439-4636190af475?q=80&w=200&auto=format&fit=crop","https://images.unsplash.com/photo-1550751827-4bd374c3f58b?q=80&w=200&auto=format&fit=crop"].map((t,n)=>(0,B.jsxs)(j.motion.div,{whileHover:{scale:1.05},className:"relative group cursor-pointer",onClick:()=>e(t),children:[(0,B.jsx)("img",{src:t,className:"w-full aspect-square object-cover rounded-lg border border-white/10",alt:"suggested"}),(0,B.jsx)("div",{className:"absolute inset-0 bg-deep-space-accent-neon/20 opacity-0 group-hover:opacity-100 flex items-center justify-center transition-opacity rounded-lg",children:(0,B.jsx)(eh,{size:16,className:"text-white"})})]},n))})]}),ed=e=>{let t=(0,U.useAppStore)(),[n,r]=(0,W.useState)([]),[a,s]=(0,W.useState)(""),[i,o]=(0,W.useState)(!1),[l,u]=(0,W.useState)(null),[h,p]=(0,W.useState)(null),d=(0,W.useRef)(null);(0,W.useEffect)(()=>{d.current?.scrollIntoView({behavior:"smooth"})},[n]),(0,W.useEffect)(()=>{let e=ei.default.onAuthStateChanged(e=>{p(e),window.electronAPI&&window.electronAPI.setUserId(e?e.uid:null)});return()=>e()},[]);let c=async e=>{let i=e||a.trim();if(!i)return;let l={role:"user",content:i};r(e=>[...e,l]),e||s(""),o(!0),u(null);try{if(window.electronAPI){let e=await window.electronAPI.generateChatContent([...n,l]);if(e.error)u(e.error);else if(e.text){let n=e.text;if(n.includes("NAVIGATE:")){let e=n.match(/NAVIGATE:\s*(https?:\/\/[^\s]+)/);e&&(t.setCurrentUrl(e[1]),t.setActiveView("browser"),n=n.replace(/NAVIGATE:\s*[^\s]+/,"ðŸŒ Navigating to specified address..."))}n.includes("CODING_MODE: ON")&&(t.setCodingMode(!0),n=n.replace("CODING_MODE: ON","ðŸš€ Switching to Coding Dashboard...")),r(e=>[...e,{role:"model",content:n}])}}else u("AI Engine not connected.")}catch(e){u(`Response Error: ${e.message}`)}finally{o(!1)}};return e.isCollapsed?(0,B.jsxs)("div",{className:"flex flex-col items-center h-full py-2 space-y-6",children:[(0,B.jsx)("button",{onClick:e.toggleCollapse,className:"w-10 h-10 flex items-center justify-center rounded-xl bg-white/5 hover:bg-white/10 text-white/40 hover:text-deep-space-accent-neon transition-all",children:(0,B.jsx)("span",{className:"text-xl",children:"ðŸ“Š"})}),(0,B.jsx)("div",{className:"flex-1"}),(0,B.jsx)("button",{onClick:e.toggleStudentMode,className:`w-12 h-12 flex items-center justify-center rounded-2xl transition-all ${e.studentMode?"bg-deep-space-accent-neon text-deep-space-bg neon-glow":"bg-white/5 text-white/40 hover:bg-white/10"}`,children:(0,B.jsx)("span",{className:"text-2xl",children:"ðŸŽ“"})})]}):(0,B.jsxs)("div",{className:"flex flex-col h-full gap-6",children:[(0,B.jsxs)("header",{className:"flex items-center justify-between",children:[(0,B.jsxs)("div",{className:"flex items-center gap-3",children:[(0,B.jsx)("div",{className:"w-8 h-8 rounded-lg bg-deep-space-accent-neon flex items-center justify-center text-deep-space-bg font-bold shadow-[0_0_20px_rgba(0,255,255,0.4)]",children:t.appName.charAt(0)}),(0,B.jsxs)("h2",{className:"text-lg font-bold tracking-tight text-white",children:[t.appName," AI"]})]}),(0,B.jsx)("button",{onClick:e.toggleCollapse,className:"p-2 text-white/20 hover:text-white transition-colors",children:(0,B.jsx)("span",{className:"text-sm",children:e.isCollapsed?"right"===e.side?"â—€":"â–¶":"right"===e.side?"â–¶":"â—€"})})]}),(0,B.jsxs)("div",{className:"flex-1 overflow-y-auto custom-scrollbar pr-2 space-y-6",children:[0===n.length?(0,B.jsxs)("div",{className:"h-full flex flex-col items-center justify-center text-center px-4 animate-in fade-in duration-700",children:[(0,B.jsx)("div",{className:"w-16 h-16 rounded-3xl glass-vibrant flex items-center justify-center mb-6 text-3xl shadow-2xl shadow-deep-space-accent-neon/20 animate-pulse",children:"âœ¨"}),(0,B.jsxs)("h3",{className:"text-white font-bold mb-2",children:["How can ",t.appName," help?"]}),(0,B.jsxs)("p",{className:"text-white/30 text-xs leading-relaxed max-w-[200px]",children:["I can summarize ",t.tabs.find(e=>e.id===t.activeTabId)?.title||"pages",", write code, or organize your research."]})]}):n.map((e,n)=>(0,B.jsxs)(j.motion.div,{initial:{opacity:0,y:10},animate:{opacity:1,y:0},className:`flex flex-col ${"user"===e.role?"items-end":"items-start"}`,children:[(0,B.jsxs)("div",{className:`max-w-[95%] p-4 rounded-3xl text-sm leading-relaxed backdrop-blur-md ${"user"===e.role?"bg-deep-space-primary/30 text-white border border-white/10 rounded-tr-none":"bg-white/[0.03] text-white/90 border border-white/5 rounded-tl-none"}`,children:[e.content,"model"===e.role&&(e.content.toLowerCase().includes("story")||e.content.toLowerCase().includes("email"))&&(0,B.jsx)("div",{className:"mt-4",children:(0,B.jsx)(ep,{onSelect:e=>s(t=>t+`
![image](${e})`)})})]}),(0,B.jsx)("span",{className:"text-[10px] uppercase font-black tracking-widest text-white/10 mt-2 px-1",children:"user"===e.role?"Local User":`${t.appName} Intelligence`})]},n)),i&&(0,B.jsx)("div",{className:"flex flex-col items-start translate-x-1",children:(0,B.jsx)("div",{className:"bg-white/[0.03] border border-white/10 p-4 rounded-3xl rounded-tl-none backdrop-blur-xl",children:(0,B.jsx)(eo,{})})}),l&&(0,B.jsxs)("div",{className:"p-3 bg-red-500/10 border border-red-500/20 rounded-xl text-[11px] text-red-400",children:["âš ï¸ ",l]}),(0,B.jsx)("div",{ref:d})]}),(0,B.jsxs)("footer",{className:"space-y-4",children:[(0,B.jsxs)("div",{className:"flex gap-2",children:[(0,B.jsx)("button",{onClick:()=>c("Summarize the main points of this page"),className:"flex-1 text-[10px] font-bold uppercase tracking-widest py-2 px-3 rounded-lg border border-white/5 bg-white/5 text-white/40 hover:bg-white/10 hover:text-white transition-all overflow-hidden whitespace-nowrap",children:"Summarize"}),(0,B.jsx)("button",{onClick:()=>c("Explain the technical content here"),className:"flex-1 text-[10px] font-bold uppercase tracking-widest py-2 px-3 rounded-lg border border-white/5 bg-white/5 text-white/40 hover:bg-white/10 hover:text-white transition-all overflow-hidden whitespace-nowrap",children:"Explain"})]}),(0,B.jsxs)("div",{className:"relative",children:[(0,B.jsx)("textarea",{value:a,onChange:e=>s(e.target.value),onKeyDown:e=>{"Enter"!==e.key||e.shiftKey||(e.preventDefault(),c())},placeholder:"Ask anything...",className:"w-full bg-black/40 border border-white/10 rounded-2xl p-4 pr-12 text-sm text-white placeholder:text-white/20 focus:outline-none focus:ring-1 focus:ring-deep-space-accent-neon/50 resize-none h-24 transition-all"}),(0,B.jsx)("button",{onClick:()=>c(),className:"absolute right-3 bottom-3 w-8 h-8 rounded-lg bg-deep-space-accent-neon text-deep-space-bg flex items-center justify-center hover:scale-105 active:scale-95 transition-all shadow-[0_0_15px_rgba(0,255,255,0.3)] disabled:opacity-50",disabled:!a.trim()||i,children:(0,B.jsx)("span",{className:"transform -rotate-45 mb-1 ml-0.5",children:"âž¤"})})]}),(0,B.jsx)(es,{...e})]})]})},ec=new class{extensions=[];constructor(){this.loadDefaultExtensions()}loadDefaultExtensions(){this.extensions=[{id:"adblock-elite",name:"AdBlock Elite",description:"Advanced ad blocking for a cleaner web.",version:"1.0.0",icon:"ðŸ›¡ï¸",enabled:!0},{id:"dark-reader",name:"Dark Reader",description:"Force dark mode on every website.",version:"1.2.0",icon:"ðŸŒ™",enabled:!1},{id:"grammarly-lite",name:"Grammarly Lite",description:"Check your spelling in the notes area.",version:"0.9.0",icon:"âœï¸",enabled:!0}]}getExtensions(){return this.extensions}toggleExtension(e){let t=this.extensions.find(t=>t.id===e);t&&(t.enabled=!t.enabled)}installExtension(e){this.extensions.push(e)}},ef=(0,Q.default)("shopping-bag",[["path",{d:"M16 10a4 4 0 0 1-8 0",key:"1ltviw"}],["path",{d:"M3.103 6.034h17.794",key:"awc11p"}],["path",{d:"M3.4 5.467a2 2 0 0 0-.4 1.2V20a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6.667a2 2 0 0 0-.4-1.2l-2-2.667A2 2 0 0 0 17 2H7a2 2 0 0 0-1.6.8z",key:"o988cm"}]]),em=(0,Q.default)("star",[["path",{d:"M11.525 2.295a.53.53 0 0 1 .95 0l2.31 4.679a2.123 2.123 0 0 0 1.595 1.16l5.166.756a.53.53 0 0 1 .294.904l-3.736 3.638a2.123 2.123 0 0 0-.611 1.878l.882 5.14a.53.53 0 0 1-.771.56l-4.618-2.428a2.122 2.122 0 0 0-1.973 0L6.396 21.01a.53.53 0 0 1-.77-.56l.881-5.139a2.122 2.122 0 0 0-.611-1.879L2.16 9.795a.53.53 0 0 1 .294-.906l5.165-.755a2.122 2.122 0 0 0 1.597-1.16z",key:"r04s7s"}]]),eg=(0,Q.default)("zap",[["path",{d:"M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",key:"1xq2db"}]]),ey=({onClose:e})=>{let[t,n]=(0,W.useState)(ec.getExtensions());return(0,B.jsx)("div",{className:"fixed inset-0 z-[100] flex items-center justify-center p-8 bg-black/60 backdrop-blur-xl animate-in fade-in duration-300",children:(0,B.jsxs)(j.motion.div,{initial:{scale:.9,opacity:0},animate:{scale:1,opacity:1},className:"w-full max-w-5xl h-[80vh] bg-deep-space-bg border border-white/10 rounded-3xl overflow-hidden flex shadow-2xl",children:[(0,B.jsxs)("div",{className:"w-64 border-r border-white/5 p-6 flex flex-col gap-6 glass-dark",children:[(0,B.jsxs)("div",{className:"flex items-center gap-2 text-deep-space-accent-neon font-bold text-xl",children:[(0,B.jsx)(ef,{size:24}),(0,B.jsx)("span",{children:"Comet Store"})]}),(0,B.jsxs)("nav",{className:"space-y-2",children:[(0,B.jsx)("button",{className:"w-full text-left px-4 py-2 rounded-xl bg-white/5 text-white text-sm",children:"All Extensions"}),(0,B.jsx)("button",{className:"w-full text-left px-4 py-2 rounded-xl text-white/40 hover:bg-white/5 hover:text-white transition-colors text-sm font-medium",children:"Themes"}),(0,B.jsx)("button",{className:"w-full text-left px-4 py-2 rounded-xl text-white/40 hover:bg-white/5 hover:text-white transition-colors text-sm font-medium",children:"Developer tools"})]}),(0,B.jsxs)("div",{className:"mt-auto p-4 bg-white/5 rounded-2xl",children:[(0,B.jsx)("p",{className:"text-[10px] text-white/30 uppercase font-bold tracking-widest mb-1",children:"Your Account"}),(0,B.jsx)("p",{className:"text-xs text-white/70",children:"Dev User"})]})]}),(0,B.jsxs)("div",{className:"flex-1 flex flex-col p-8 overflow-y-auto custom-scrollbar",children:[(0,B.jsxs)("header",{className:"flex items-center justify-between mb-8",children:[(0,B.jsxs)("div",{children:[(0,B.jsx)("h2",{className:"text-2xl font-bold text-white mb-1",children:"Extensions"}),(0,B.jsx)("p",{className:"text-white/40 text-sm",children:"Enhance your productivity with powerful tools."})]}),(0,B.jsx)("button",{onClick:e,className:"px-4 py-2 bg-white/5 hover:bg-white/10 rounded-xl transition-all text-white/60",children:"Close"})]}),(0,B.jsx)("div",{className:"grid grid-cols-1 md:grid-cols-2 gap-4",children:t.map(e=>(0,B.jsxs)(j.motion.div,{whileHover:{y:-4},className:"p-6 rounded-3xl glass-dark border border-white/5 flex gap-4 transition-all hover:border-white/10",children:[(0,B.jsx)("div",{className:"w-16 h-16 rounded-2xl bg-white/5 flex items-center justify-center text-3xl shadow-lg border border-white/10",children:e.icon}),(0,B.jsxs)("div",{className:"flex-1",children:[(0,B.jsxs)("div",{className:"flex items-center justify-between mb-1",children:[(0,B.jsx)("h3",{className:"font-bold text-white leading-none",children:e.name}),(0,B.jsxs)("div",{className:"flex items-center text-[10px] text-yellow-500/80 gap-0.5",children:[(0,B.jsx)(em,{size:10,fill:"currentColor"}),(0,B.jsx)("span",{children:"adblock-elite"===e.id?"4.9":"4.7"})]})]}),(0,B.jsx)("p",{className:"text-xs text-white/40 mb-4 line-clamp-2",children:e.description}),(0,B.jsxs)("div",{className:"flex items-center justify-between",children:[(0,B.jsxs)("span",{className:"text-[10px] font-bold text-white/20 uppercase tracking-widest",children:["v",e.version]}),(0,B.jsx)("button",{onClick:()=>{var t;return t=e.id,void(ec.toggleExtension(t),n([...ec.getExtensions()]))},className:`px-4 py-1.5 rounded-lg text-[10px] font-bold uppercase tracking-widest transition-all ${e.enabled?"bg-red-500/10 text-red-400 border border-red-500/20 hover:bg-red-500/20":"bg-deep-space-accent-neon text-deep-space-bg shadow-[0_0_15px_rgba(0,255,255,0.3)] hover:scale-105 active:scale-95"}`,children:e.enabled?"Disable":"Install"})]})]})]},e.id))}),(0,B.jsxs)("div",{className:"mt-12 p-8 rounded-3xl bg-gradient-to-br from-deep-space-primary/20 to-deep-space-secondary/20 border border-white/5",children:[(0,B.jsxs)("div",{className:"flex items-center gap-3 mb-4",children:[(0,B.jsx)(eg,{className:"text-deep-space-accent-neon",size:24}),(0,B.jsx)("h3",{className:"text-xl font-bold text-white",children:"Create your own extension"})]}),(0,B.jsx)("p",{className:"text-sm text-white/60 mb-6 max-w-xl",children:"Our extension API is built on modern React and Electron standards. You can build plugins that interact with the AI sidebar or the page content directly."}),(0,B.jsx)("button",{className:"px-6 py-2.5 bg-white text-black font-bold rounded-xl hover:bg-white/90 transition-all text-sm",children:"Developer Documentation"})]})]})]})})};var ex=e.i(24533);let eb=(0,Q.default)("file-text",[["path",{d:"M6 22a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h8a2.4 2.4 0 0 1 1.704.706l3.588 3.588A2.4 2.4 0 0 1 20 8v12a2 2 0 0 1-2 2z",key:"1oefj6"}],["path",{d:"M14 2v5a1 1 0 0 0 1 1h5",key:"wfsgrz"}],["path",{d:"M10 9H8",key:"b1mrlr"}],["path",{d:"M16 13H8",key:"t4e002"}],["path",{d:"M16 17H8",key:"z1uh3a"}]]),ew=(0,Q.default)("pen-line",[["path",{d:"M13 21h8",key:"1jsn5i"}],["path",{d:"M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z",key:"1a8usu"}]]),ev=(0,Q.default)("trash-2",[["path",{d:"M10 11v6",key:"nco0om"}],["path",{d:"M14 11v6",key:"outv1u"}],["path",{d:"M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6",key:"miytrc"}],["path",{d:"M3 6h18",key:"d0wm0j"}],["path",{d:"M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2",key:"e791ji"}]]),ek=(0,Q.default)("download",[["path",{d:"M12 15V3",key:"m9g1x1"}],["path",{d:"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4",key:"ih7n3h"}],["path",{d:"m7 10 5 5 5-5",key:"brsn70"}]]),eN=(0,Q.default)("move",[["path",{d:"M12 2v20",key:"t6zp3m"}],["path",{d:"m15 19-3 3-3-3",key:"11eu04"}],["path",{d:"m19 9 3 3-3 3",key:"1mg7y2"}],["path",{d:"M2 12h20",key:"9i4pu4"}],["path",{d:"m5 9-3 3 3 3",key:"j64kie"}],["path",{d:"m9 5 3-3 3 3",key:"l8vdw6"}]]),eI=()=>{let[e,t]=(0,W.useState)(null),[n,r]=(0,W.useState)(null),[a,s]=(0,W.useState)(""),[i,o]=(0,W.useState)(!1),[l,u]=(0,W.useState)(0),[h,p]=(0,W.useState)([]);(0,W.useRef)(null);let d=async()=>{if(e){o(!0);try{let t=await ex.default.recognize(e,"eng",{logger:e=>{"recognizing text"===e.status&&u(Math.round(100*e.progress))}});s(t.data.text)}catch(e){console.error(e)}finally{o(!1)}}};return(0,B.jsxs)("div",{className:"flex h-screen bg-[#050510] text-white",children:[(0,B.jsxs)("div",{className:"w-72 border-r border-white/5 p-6 flex flex-col gap-6 glass-dark relative z-10",children:[(0,B.jsxs)("div",{className:"flex items-center gap-2 text-deep-space-accent-neon font-bold text-xl mb-4",children:[(0,B.jsx)(eb,{size:24}),(0,B.jsx)("span",{children:"Docs AI"})]}),(0,B.jsxs)("div",{className:"space-y-4",children:[(0,B.jsxs)("label",{className:"block p-4 rounded-2xl border-2 border-dashed border-white/10 hover:border-deep-space-accent-neon/30 hover:bg-white/5 transition-all cursor-pointer text-center",children:[(0,B.jsx)("input",{type:"file",className:"hidden",accept:"application/pdf,image/*",onChange:e=>{let n=e.target.files?.[0];n&&(t(n),r(URL.createObjectURL(n)))}}),(0,B.jsx)(ek,{className:"mx-auto mb-2 text-white/30"}),(0,B.jsx)("span",{className:"text-xs font-bold text-white/60",children:"Upload PDF or Image"})]}),e&&(0,B.jsxs)(j.motion.div,{initial:{opacity:0},animate:{opacity:1},className:"p-4 rounded-2xl bg-white/5 space-y-4",children:[(0,B.jsx)("p",{className:"text-xs font-mono text-white/40 truncate",children:e.name}),(0,B.jsx)("button",{onClick:d,disabled:i,className:"w-full py-2 bg-deep-space-accent-neon text-deep-space-bg rounded-xl font-bold text-[10px] uppercase tracking-widest shadow-[0_0_15px_rgba(0,255,255,0.3)] disabled:opacity-50",children:i?`OCR: ${l}%`:"Extract Text (OCR)"}),(0,B.jsx)("button",{onClick:()=>{p([...h,{id:Math.random().toString(36).substr(2,9),text:"New Note",x:100,y:100}])},className:"w-full py-2 bg-white/5 border border-white/10 rounded-xl text-[10px] uppercase font-bold tracking-widest text-white/60 hover:bg-white/10 hover:text-white transition-all",children:"Add Annotation"})]})]}),(0,B.jsxs)("div",{className:"mt-auto",children:[(0,B.jsx)("h4",{className:"text-[10px] font-bold uppercase tracking-widest text-white/20 mb-3",children:"Extracted Content"}),(0,B.jsx)("div",{className:"p-3 bg-white/[0.02] rounded-xl border border-white/5 text-[11px] text-white/40 max-h-40 overflow-y-auto custom-scrollbar italic leading-relaxed",children:a||"No text extracted yet. Use the OCR tool above."})]})]}),(0,B.jsxs)("div",{className:"flex-1 overflow-hidden relative p-8 flex flex-col items-center justify-center bg-black/40",children:[n?(0,B.jsx)("div",{className:"relative w-full h-full flex items-center justify-center overflow-auto custom-scrollbar",children:(0,B.jsxs)("div",{className:"relative bg-white shadow-2xl rounded-sm group min-w-[600px] min-h-[800px]",children:[e?.type==="application/pdf"?(0,B.jsx)("iframe",{src:n,className:"w-full h-full min-h-[800px]"}):(0,B.jsx)("img",{src:n,className:"max-w-full",alt:"document"}),h.map(e=>(0,B.jsxs)(j.motion.div,{drag:!0,className:"absolute p-3 glass-dark border border-deep-space-accent-neon/30 rounded-lg text-xs min-w-[120px] shadow-2xl cursor-move z-50 text-white",style:{left:e.x,top:e.y},children:[(0,B.jsxs)("div",{className:"flex items-center gap-2 mb-2 text-[10px] text-white/30 font-bold uppercase tracking-tighter",children:[(0,B.jsx)(eN,{size:8}),(0,B.jsx)("span",{children:"Note"})]}),(0,B.jsx)("textarea",{value:e.text,onChange:t=>{let n=[...h],r=n.findIndex(t=>t.id===e.id);n[r].text=t.target.value,p(n)},className:"w-full bg-transparent border-none outline-none resize-none font-medium h-20"}),(0,B.jsx)("button",{onClick:()=>p(h.filter(t=>t.id!==e.id)),className:"absolute -top-1.5 -right-1.5 w-5 h-5 bg-red-500 rounded-full flex items-center justify-center text-[8px]",children:(0,B.jsx)(ev,{size:10})})]},e.id))]})}):(0,B.jsxs)("div",{className:"text-center opacity-20",children:[(0,B.jsx)("div",{className:"w-24 h-24 rounded-full border-2 border-white/20 flex items-center justify-center mx-auto mb-6",children:(0,B.jsx)(eb,{size:48})}),(0,B.jsx)("p",{className:"font-bold uppercase tracking-widest text-sm",children:"No Document Selected"})]}),(0,B.jsx)(V.AnimatePresence,{children:n&&(0,B.jsxs)(j.motion.div,{initial:{y:100},animate:{y:0},className:"absolute bottom-8 left-1/2 -translate-x-1/2 px-6 py-3 rounded-2xl glass shadow-2xl flex gap-6 items-center border border-white/10",children:[(0,B.jsxs)("button",{className:"flex flex-col items-center gap-1 text-white/40 hover:text-white transition-all font-bold",children:[(0,B.jsx)(el,{size:18}),(0,B.jsx)("span",{className:"text-[10px] uppercase tracking-tighter",children:"Zoom"})]}),(0,B.jsx)("div",{className:"w-[1px] h-8 bg-white/10"}),(0,B.jsxs)("button",{className:"flex flex-col items-center gap-1 text-white/40 hover:text-white transition-all font-bold",children:[(0,B.jsx)(ew,{size:18}),(0,B.jsx)("span",{className:"text-[10px] uppercase tracking-tighter",children:"Annotate"})]}),(0,B.jsx)("div",{className:"w-[1px] h-8 bg-white/10"}),(0,B.jsxs)("button",{className:"flex flex-col items-center gap-1 text-deep-space-accent-neon hover:scale-110 transition-all font-bold neon-glow",children:[(0,B.jsx)(ek,{size:18}),(0,B.jsx)("span",{className:"text-[10px] uppercase tracking-tighter",children:"Export"})]})]})})]})]})},eS=(0,Q.default)("clipboard",[["rect",{width:"8",height:"4",x:"8",y:"2",rx:"1",ry:"1",key:"tgr4d6"}],["path",{d:"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2",key:"116196"}]]),eC=(0,Q.default)("copy",[["rect",{width:"14",height:"14",x:"8",y:"8",rx:"2",ry:"2",key:"17jyea"}],["path",{d:"M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2",key:"zix9uf"}]]),eT=(0,Q.default)("check",[["path",{d:"M20 6 9 17l-5-5",key:"1gmf2c"}]]),e$=()=>{let{clipboard:e,addClipboardItem:t,clearClipboard:n}=(0,U.useAppStore)(),[r,a]=W.default.useState(null);return(0,B.jsxs)("div",{className:"flex flex-col h-full bg-black/20 rounded-2xl border border-white/5 overflow-hidden",children:[(0,B.jsxs)("header",{className:"p-4 border-b border-white/5 flex items-center justify-between bg-white/5",children:[(0,B.jsxs)("div",{className:"flex items-center gap-2",children:[(0,B.jsx)(eS,{size:16,className:"text-deep-space-accent-neon"}),(0,B.jsx)("span",{className:"text-[10px] font-bold uppercase tracking-widest text-white/60",children:"Clipboard History"})]}),(0,B.jsx)("button",{onClick:n,className:"p-1.5 hover:bg-red-500/10 text-white/20 hover:text-red-400 rounded-lg transition-all",children:(0,B.jsx)(ev,{size:14})})]}),(0,B.jsx)("div",{className:"flex-1 overflow-y-auto p-4 space-y-2 custom-scrollbar",children:0===e.length?(0,B.jsxs)("div",{className:"h-full flex flex-col items-center justify-center text-center opacity-20 py-8",children:[(0,B.jsx)(eS,{size:32,className:"mb-2"}),(0,B.jsx)("p",{className:"text-[10px] uppercase font-bold tracking-tighter",children:"Empty History"})]}):(0,B.jsx)(V.AnimatePresence,{initial:!1,children:e.map((e,t)=>(0,B.jsxs)(j.motion.div,{initial:{opacity:0,x:-10},animate:{opacity:1,x:0},className:"group p-3 rounded-xl bg-white/[0.03] border border-white/5 hover:border-white/10 transition-all relative overflow-hidden",children:[(0,B.jsx)("p",{className:"text-xs text-white/60 line-clamp-2 break-all pr-8",children:e}),(0,B.jsx)("button",{onClick:()=>{navigator.clipboard.writeText(e),a(t),setTimeout(()=>a(null),2e3)},className:"absolute right-2 top-1/2 -translate-y-1/2 p-2 bg-black/40 rounded-lg text-white/40 hover:text-deep-space-accent-neon transition-all",children:r===t?(0,B.jsx)(eT,{size:14}):(0,B.jsx)(eC,{size:14})})]},e+t))})}),(0,B.jsx)("div",{className:"p-3 bg-white/5 border-t border-white/5",children:(0,B.jsx)("p",{className:"text-[8px] text-center text-white/20 uppercase font-black tracking-widest",children:"Synced across devices"})})]})},eE=(0,Q.default)("camera",[["path",{d:"M13.997 4a2 2 0 0 1 1.76 1.05l.486.9A2 2 0 0 0 18.003 7H20a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h1.997a2 2 0 0 0 1.759-1.048l.489-.904A2 2 0 0 1 10.004 4z",key:"18u6gg"}],["circle",{cx:"12",cy:"13",r:"3",key:"1vg3eu"}]]);var eA=e.i(30138);let eR=(0,Q.default)("x",[["path",{d:"M18 6 6 18",key:"1bl5f8"}],["path",{d:"m6 6 12 12",key:"d8bk6v"}]]),eF=(0,Q.default)("camera-off",[["path",{d:"M14.564 14.558a3 3 0 1 1-4.122-4.121",key:"1rnrzw"}],["path",{d:"m2 2 20 20",key:"1ooewy"}],["path",{d:"M20 20H4a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h1.997a2 2 0 0 0 .819-.175",key:"1x3arw"}],["path",{d:"M9.695 4.024A2 2 0 0 1 10.004 4h3.993a2 2 0 0 1 1.76 1.05l.486.9A2 2 0 0 0 18.003 7H20a2 2 0 0 1 2 2v7.344",key:"1i84u0"}]]);var e_=e.i(32266);let eD=({onClose:e})=>{let t=(0,W.useRef)(null),[n,r]=(0,W.useState)(!1),[a,s]=(0,W.useState)(null),i=async()=>{try{let e=await navigator.mediaDevices.getUserMedia({video:{facingMode:"environment"}});t.current&&(t.current.srcObject=e,r(!0),s(null))}catch(e){s("Camera access denied or unavailable."),r(!1)}},o=()=>{t.current&&t.current.srcObject&&(t.current.srcObject.getTracks().forEach(e=>e.stop()),r(!1))};return(0,W.useEffect)(()=>(i(),()=>o()),[]),(0,B.jsxs)("div",{className:"fixed bottom-8 right-8 z-[100] w-72 rounded-3xl overflow-hidden glass-dark border border-white/10 shadow-2xl shadow-black/50 overflow-hidden",children:[(0,B.jsxs)("header",{className:"p-4 flex items-center justify-between border-b border-white/5 bg-white/5",children:[(0,B.jsxs)("div",{className:"flex items-center gap-2",children:[(0,B.jsx)(eE,{size:16,className:"text-deep-space-accent-neon"}),(0,B.jsx)("span",{className:"text-[10px] font-bold uppercase tracking-widest text-white/60",children:"Vision Engine"})]}),(0,B.jsx)("button",{onClick:e,className:"text-white/20 hover:text-white transition-colors",children:(0,B.jsx)(eR,{size:16})})]}),(0,B.jsx)("div",{className:"relative aspect-[3/4] bg-black flex items-center justify-center",children:a?(0,B.jsxs)("div",{className:"text-center p-6 space-y-4",children:[(0,B.jsx)(eF,{size:32,className:"mx-auto text-red-500/40"}),(0,B.jsx)("p",{className:"text-[10px] text-white/40 font-bold uppercase leading-relaxed",children:a}),(0,B.jsx)("button",{onClick:i,className:"px-4 py-2 bg-white/5 rounded-xl text-[10px] font-bold uppercase tracking-widest hover:bg-white/10 transition-all",children:"Retry"})]}):(0,B.jsxs)(B.Fragment,{children:[(0,B.jsx)("video",{ref:t,autoPlay:!0,playsInline:!0,className:"w-full h-full object-cover grayscale brightness-110 contrast-125 opacity-80"}),(0,B.jsx)("div",{className:"absolute inset-0 border-[20px] border-black/10 pointer-events-none",children:(0,B.jsx)("div",{className:"w-full h-full border border-deep-space-accent-neon/20 rounded-2xl relative",children:(0,B.jsx)(j.motion.div,{animate:{top:["0%","100%","0%"]},transition:{duration:4,repeat:1/0,ease:"linear"},className:"absolute left-0 right-0 h-[1px] bg-deep-space-accent-neon shadow-[0_0_10px_#00FFFF]"})})})]})}),(0,B.jsxs)("footer",{className:"p-4 grid grid-cols-2 gap-2 bg-white/5 border-t border-white/5",children:[(0,B.jsxs)("button",{className:"flex items-center justify-center gap-2 px-3 py-2 rounded-xl bg-deep-space-accent-neon text-deep-space-bg font-bold text-[10px] uppercase tracking-widest hover:scale-105 transition-all",children:[(0,B.jsx)(e_.Sparkles,{size:12}),"Analyze"]}),(0,B.jsxs)("button",{onClick:()=>{o(),i()},className:"flex items-center justify-center gap-2 px-3 py-2 rounded-xl bg-white/5 text-white/60 font-bold text-[10px] uppercase tracking-widest hover:bg-white/10 transition-all",children:[(0,B.jsx)(eA.RefreshCw,{size:12}),"Flip"]})]})]})},eO=(0,Q.default)("code-xml",[["path",{d:"m18 16 4-4-4-4",key:"1inbqp"}],["path",{d:"m6 8-4 4 4 4",key:"15zrgr"}],["path",{d:"m14.5 4-5 16",key:"e7oirm"}]]),eM=(0,Q.default)("play",[["path",{d:"M5 5a2 2 0 0 1 3.008-1.728l11.997 6.998a2 2 0 0 1 .003 3.458l-12 7A2 2 0 0 1 5 19z",key:"10ikf1"}]]),eL=(0,Q.default)("panels-top-left",[["rect",{width:"18",height:"18",x:"3",y:"3",rx:"2",key:"afitv7"}],["path",{d:"M3 9h18",key:"1pudct"}],["path",{d:"M9 21V9",key:"1oto5p"}]]),ez=(0,Q.default)("terminal",[["path",{d:"M12 19h8",key:"baeox8"}],["path",{d:"m4 17 6-6-6-6",key:"1yngyt"}]]),eP=(0,Q.default)("maximize-2",[["path",{d:"M15 3h6v6",key:"1q9fwt"}],["path",{d:"m21 3-7 7",key:"1l2asr"}],["path",{d:"m3 21 7-7",key:"tjx5ai"}],["path",{d:"M9 21H3v-6",key:"wtvkvv"}]]),eB=(0,Q.default)("rotate-ccw",[["path",{d:"M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8",key:"1357e3"}],["path",{d:"M3 3v5h5",key:"1xhq8a"}]]),eW=()=>{let[e,t]=(0,W.useState)(`<!DOCTYPE html>
<html>
<head>
    <style>
        body { background: #050510; color: #00ffff; font-family: sans-serif; display: flex; align-items: center; justify-content: center; height: 100vh; margin: 0; }
        .card { border: 1px solid #00ffff33; padding: 2rem; border-radius: 1rem; background: #ffffff05; backdrop-filter: blur(10px); text-align: center; }
        h1 { margin: 0; font-size: 2rem; letter-spacing: 0.1em; }
    </style>
</head>
<body>
    <div class="card">
        <h1>COMET LIVE PREVIEW</h1>
        <p style="color: #ffffff66">Edit the code to see real-time updates.</p>
    </div>
</body>
</html>`);return(0,B.jsxs)("div",{className:"flex h-full w-full bg-[#030308] gap-4 p-4",children:[(0,B.jsxs)("div",{className:"flex-1 flex flex-col glass-dark rounded-3xl border border-white/5 overflow-hidden",children:[(0,B.jsxs)("header",{className:"px-6 py-4 border-b border-white/5 flex items-center justify-between bg-white/5",children:[(0,B.jsxs)("div",{className:"flex items-center gap-3",children:[(0,B.jsx)("div",{className:"w-8 h-8 rounded-lg bg-deep-space-accent-neon/10 flex items-center justify-center text-deep-space-accent-neon",children:(0,B.jsx)(eO,{size:18})}),(0,B.jsx)("span",{className:"text-[10px] font-bold uppercase tracking-[0.2em] text-white/60",children:"Live Source"})]}),(0,B.jsxs)("div",{className:"flex items-center gap-2",children:[(0,B.jsx)("button",{className:"p-2 hover:bg-white/10 rounded-xl text-white/40 transition-all",children:(0,B.jsx)(en,{size:16})}),(0,B.jsx)("button",{className:"p-2 hover:bg-white/10 rounded-xl text-white/40 transition-all",children:(0,B.jsx)(eB,{size:16})})]})]}),(0,B.jsx)("div",{className:"flex-1 relative",children:(0,B.jsx)("textarea",{value:e,onChange:e=>t(e.target.value),className:"absolute inset-0 w-full h-full bg-transparent p-6 text-sm font-mono text-white/80 focus:outline-none resize-none custom-scrollbar leading-relaxed"})}),(0,B.jsx)("footer",{className:"p-4 bg-black/40 border-t border-white/5 flex items-center justify-between",children:(0,B.jsxs)("div",{className:"flex gap-2",children:[(0,B.jsxs)("button",{className:"px-4 py-2 rounded-xl bg-deep-space-accent-neon text-deep-space-bg font-bold text-[10px] uppercase tracking-widest flex items-center gap-2",children:[(0,B.jsx)(eM,{size:12}),"Deploy"]}),(0,B.jsx)("button",{className:"px-4 py-2 rounded-xl bg-white/5 text-white/40 font-bold text-[10px] uppercase tracking-widest hover:bg-white/10 transition-all",children:"Format"})]})})]}),(0,B.jsxs)("div",{className:"flex-1 flex flex-col gap-4",children:[(0,B.jsxs)("div",{className:"flex-1 glass-dark rounded-3xl border border-white/5 overflow-hidden flex flex-col bg-white/[0.02]",children:[(0,B.jsxs)("header",{className:"px-6 py-4 border-b border-white/5 flex items-center justify-between",children:[(0,B.jsxs)("div",{className:"flex items-center gap-3",children:[(0,B.jsx)(eL,{size:16,className:"text-deep-space-accent-neon"}),(0,B.jsx)("span",{className:"text-[10px] font-bold uppercase tracking-[0.2em] text-white/60",children:"Real-time Preview"})]}),(0,B.jsx)("button",{className:"p-2 hover:bg-white/10 rounded-xl text-white/40 transition-all",children:(0,B.jsx)(eP,{size:16})})]}),(0,B.jsx)("div",{className:"flex-1 bg-white",children:(0,B.jsx)("iframe",{title:"preview",srcDoc:e,className:"w-full h-full border-0"})})]}),(0,B.jsxs)("div",{className:"h-48 glass-dark rounded-3xl border border-white/5 overflow-hidden flex flex-col",children:[(0,B.jsxs)("header",{className:"px-6 py-3 border-b border-white/5 flex items-center gap-2 bg-white/5",children:[(0,B.jsx)(ez,{size:14,className:"text-white/40"}),(0,B.jsx)("span",{className:"text-[10px] font-bold uppercase tracking-[0.2em] text-white/40",children:"Console"})]}),(0,B.jsxs)("div",{className:"flex-1 p-4 font-mono text-[11px] text-green-400/60 overflow-y-auto custom-scrollbar",children:[(0,B.jsxs)("div",{children:[">"," Initializing render engine..."]}),(0,B.jsxs)("div",{children:[">"," Bridge connected to Electron main..."]}),(0,B.jsxs)("div",{children:[">"," Live reload enabled."]}),(0,B.jsx)("div",{className:"text-white/20 mt-1 cursor-text",children:"_"})]})]})]})]})},eU=(0,Q.default)("monitor",[["rect",{width:"20",height:"14",x:"2",y:"3",rx:"2",key:"48i651"}],["line",{x1:"8",x2:"16",y1:"21",y2:"21",key:"1svkeh"}],["line",{x1:"12",x2:"12",y1:"17",y2:"21",key:"vw1qmm"}]]);var ej=e.i(9277);let eV=(0,Q.default)("info",[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["path",{d:"M12 16v-4",key:"1dtifu"}],["path",{d:"M12 8h.01",key:"e9boi3"}]]),eG=(0,Q.default)("chevron-right",[["path",{d:"m9 18 6-6-6-6",key:"mthhwq"}]]),eH=(0,Q.default)("key",[["path",{d:"m15.5 7.5 2.3 2.3a1 1 0 0 0 1.4 0l2.1-2.1a1 1 0 0 0 0-1.4L19 4",key:"g0fldk"}],["path",{d:"m21 2-9.6 9.6",key:"1j0ho8"}],["circle",{cx:"7.5",cy:"15.5",r:"5.5",key:"yqb3hr"}]]),eq=(0,Q.default)("package",[["path",{d:"M11 21.73a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73z",key:"1a0edw"}],["path",{d:"M12 22V12",key:"d0xqtd"}],["polyline",{points:"3.29 7 12 12 20.71 7",key:"ousv84"}],["path",{d:"m7.5 4.27 9 5.15",key:"1c824w"}]]),eK=(0,Q.default)("file-spreadsheet",[["path",{d:"M6 22a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h8a2.4 2.4 0 0 1 1.704.706l3.588 3.588A2.4 2.4 0 0 1 20 8v12a2 2 0 0 1-2 2z",key:"1oefj6"}],["path",{d:"M14 2v5a1 1 0 0 0 1 1h5",key:"wfsgrz"}],["path",{d:"M8 13h2",key:"yr2amv"}],["path",{d:"M14 13h2",key:"un5t4a"}],["path",{d:"M8 17h2",key:"2yhykz"}],["path",{d:"M14 17h2",key:"10kma7"}]]),eX=(0,Q.default)("lock",[["rect",{width:"18",height:"11",x:"3",y:"11",rx:"2",ry:"2",key:"1w4ew1"}],["path",{d:"M7 11V7a5 5 0 0 1 10 0v4",key:"fwvmzm"}]]),eY=(0,Q.default)("external-link",[["path",{d:"M15 3h6v6",key:"1q9fwt"}],["path",{d:"M10 14 21 3",key:"gplh6r"}],["path",{d:"M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6",key:"a6xqqp"}]]),eZ=({onClose:e})=>{let t=(0,U.useAppStore)(),[n,r]=W.default.useState("appearance"),[a,s]=(0,W.useState)(!1),[i,o]=(0,W.useState)({site:"",username:"",password:""}),l=[{id:"appearance",icon:(0,B.jsx)(eU,{size:18}),label:"Appearance"},{id:"privacy",icon:(0,B.jsx)(er.Shield,{size:18}),label:"Privacy & Security"},{id:"vault",icon:(0,B.jsx)(eH,{size:18}),label:"Vault & Autofill"},{id:"extensions",icon:(0,B.jsx)(eq,{size:18}),label:"Extensions"},{id:"tabs",icon:(0,B.jsx)(eL,{size:18}),label:"Tab Management"},{id:"system",icon:(0,B.jsx)(ej.Globe,{size:18}),label:"System"},{id:"about",icon:(0,B.jsx)(eV,{size:18}),label:"About Comet"}];return(0,B.jsx)("div",{className:"fixed inset-0 z-[100] flex items-center justify-center p-4 md:p-12 bg-black/60 backdrop-blur-3xl",children:(0,B.jsxs)(j.motion.div,{initial:{scale:.95,opacity:0},animate:{scale:1,opacity:1},className:"w-full max-w-6xl h-[85vh] bg-deep-space-bg border border-white/10 rounded-[2.5rem] overflow-hidden flex shadow-[0_30px_100px_rgba(0,0,0,0.8)]",children:[(0,B.jsxs)("div",{className:"w-72 bg-white/[0.02] border-r border-white/5 p-8 flex flex-col gap-2",children:[(0,B.jsxs)("div",{className:"flex items-center gap-3 px-4 mb-10",children:[(0,B.jsx)("div",{className:"w-10 h-10 rounded-2xl bg-deep-space-accent-neon flex items-center justify-center text-deep-space-bg font-black text-xl shadow-[0_0_20px_rgba(0,255,255,0.3)]",children:t.appName.charAt(0)}),(0,B.jsx)("span",{className:"text-xl font-black tracking-tighter uppercase",children:t.appName})]}),(0,B.jsx)("div",{className:"flex-1 overflow-y-auto no-scrollbar space-y-1",children:l.map(e=>(0,B.jsxs)("button",{onClick:()=>r(e.id),className:`w-full flex items-center gap-4 px-5 py-4 rounded-2xl transition-all font-bold text-sm ${n===e.id?"bg-deep-space-accent-neon/10 text-deep-space-accent-neon":"text-white/40 hover:bg-white/5 hover:text-white"}`,children:[e.icon,(0,B.jsx)("span",{className:"flex-1 text-left",children:e.label}),n===e.id&&(0,B.jsx)(eG,{size:14})]},e.id))}),(0,B.jsxs)("div",{className:"mt-6 space-y-4",children:[(0,B.jsxs)("button",{className:"w-full flex items-center justify-center gap-2 py-4 bg-white/5 hover:bg-white/10 border border-white/10 rounded-2xl text-[10px] font-black uppercase tracking-widest text-white/60 transition-all",children:[(0,B.jsx)(ek,{size:14}),"Install PWA"]}),(0,B.jsxs)("div",{className:"p-4 bg-deep-space-accent-neon/5 rounded-2xl border border-deep-space-accent-neon/10 text-[10px] font-medium text-deep-space-accent-neon/60 text-center leading-relaxed",children:["Version 0.5.2-alpha ",(0,B.jsx)("br",{})," (Production Build)"]})]})]}),(0,B.jsxs)("div",{className:"flex-1 flex flex-col p-12 overflow-y-auto custom-scrollbar bg-black/10",children:[(0,B.jsxs)("header",{className:"flex items-center justify-between mb-12",children:[(0,B.jsxs)("div",{children:[(0,B.jsx)("h2",{className:"text-3xl font-black text-white mb-2 uppercase tracking-tight",children:n.replace("-"," ")}),(0,B.jsx)("p",{className:"text-white/30 text-sm",children:"Configure your hardware-accelerated workspace."})]}),(0,B.jsx)("button",{onClick:e,className:"px-6 py-3 bg-white/5 hover:bg-white/10 rounded-2xl transition-all text-sm font-black uppercase tracking-widest border border-white/5",children:"Close"})]}),(0,B.jsxs)("div",{className:"space-y-12 max-w-3xl",children:["appearance"===n&&(0,B.jsx)("div",{className:"space-y-8",children:(0,B.jsxs)("div",{className:"p-8 rounded-[2rem] bg-white/[0.03] border border-white/5 space-y-8",children:[(0,B.jsxs)("div",{className:"flex items-center justify-between",children:[(0,B.jsxs)("div",{children:[(0,B.jsx)("p",{className:"font-bold text-white mb-1",children:"Layout Position"}),(0,B.jsx)("p",{className:"text-xs text-white/30",children:"Primary sidebar alignment."})]}),(0,B.jsx)("div",{className:"flex gap-2 p-1 bg-black/40 rounded-xl border border-white/5",children:["left","right"].map(e=>(0,B.jsx)("button",{onClick:()=>t.setSidebarSide(e),className:`px-4 py-1.5 rounded-lg text-[10px] font-black uppercase tracking-widest transition-all ${t.sidebarSide===e?"bg-deep-space-accent-neon text-deep-space-bg":"text-white/40 hover:text-white"}`,children:e},e))})]}),(0,B.jsxs)("div",{className:"space-y-4",children:[(0,B.jsxs)("div",{className:"flex items-center justify-between",children:[(0,B.jsx)("p",{className:"font-bold text-white",children:"Panel Width"}),(0,B.jsxs)("span",{className:"text-[10px] font-black text-deep-space-accent-neon",children:[t.sidebarWidth,"px"]})]}),(0,B.jsx)("input",{type:"range",min:"280",max:"600",step:"10",value:t.sidebarWidth,onChange:e=>t.setSidebarWidth(parseInt(e.target.value)),className:"w-full h-1.5 bg-white/10 rounded-lg appearance-none cursor-pointer accent-deep-space-accent-neon"})]})]})}),"vault"===n&&(0,B.jsxs)("div",{className:"space-y-8",children:[(0,B.jsxs)("div",{className:"flex items-center justify-between",children:[(0,B.jsx)("h3",{className:"text-xs font-black text-white/20 uppercase tracking-[0.3em]",children:"Credentials & Autofill"}),(0,B.jsxs)("button",{onClick:()=>s(!0),className:"flex items-center gap-2 px-4 py-2 bg-deep-space-accent-neon text-deep-space-bg rounded-xl text-[10px] font-black uppercase tracking-widest transition-all hover:scale-105",children:[(0,B.jsx)(eh,{size:14})," Add Manual"]})]}),(0,B.jsxs)(j.motion.div,{layout:!0,className:"grid grid-cols-1 gap-4",children:[(0,B.jsx)(V.AnimatePresence,{children:a&&(0,B.jsxs)(j.motion.div,{initial:{opacity:0,y:-10},animate:{opacity:1,y:0},exit:{opacity:0,y:-10},className:"p-6 rounded-3xl bg-deep-space-accent-neon/5 border border-deep-space-accent-neon/20 grid grid-cols-3 gap-4",children:[(0,B.jsx)("input",{placeholder:"Site (e.g. google.com)",className:"bg-black/40 border border-white/10 rounded-xl px-4 py-2 text-xs",value:i.site,onChange:e=>o({...i,site:e.target.value})}),(0,B.jsx)("input",{placeholder:"Username",className:"bg-black/40 border border-white/10 rounded-xl px-4 py-2 text-xs",value:i.username,onChange:e=>o({...i,username:e.target.value})}),(0,B.jsx)("input",{type:"password",placeholder:"Password",className:"bg-black/40 border border-white/10 rounded-xl px-4 py-2 text-xs",value:i.password,onChange:e=>o({...i,password:e.target.value})}),(0,B.jsxs)("div",{className:"col-span-3 flex justify-end gap-2",children:[(0,B.jsx)("button",{onClick:()=>s(!1),className:"text-[10px] font-black uppercase text-white/40",children:"Cancel"}),(0,B.jsx)("button",{onClick:()=>{i.site&&i.username&&i.password&&(t.addPassword(i),o({site:"",username:"",password:""}),s(!1))},className:"text-[10px] font-black uppercase text-deep-space-accent-neon",children:"Save to Vault"})]})]})}),0===t.passwords.length?(0,B.jsxs)("div",{className:"p-12 text-center rounded-[2rem] border border-dashed border-white/10",children:[(0,B.jsx)(eX,{size:32,className:"mx-auto text-white/10 mb-4"}),(0,B.jsx)("p",{className:"text-white/20 text-xs font-bold uppercase tracking-widest",children:"No entries in your secure vault."})]}):t.passwords.map(e=>(0,B.jsxs)("div",{className:"p-6 rounded-3xl bg-white/[0.03] border border-white/5 flex items-center justify-between group",children:[(0,B.jsxs)("div",{className:"flex items-center gap-4",children:[(0,B.jsx)("div",{className:"w-10 h-10 rounded-xl bg-white/5 flex items-center justify-center text-white/20 font-bold uppercase",children:e.site.charAt(0)}),(0,B.jsxs)("div",{children:[(0,B.jsx)("p",{className:"font-bold text-white text-sm",children:e.site}),(0,B.jsx)("p",{className:"text-[10px] text-white/30 uppercase tracking-widest",children:e.username})]})]}),(0,B.jsx)("button",{onClick:()=>t.removePassword(e.id),className:"opacity-0 group-hover:opacity-100 p-2 text-white/20 hover:text-red-400",children:(0,B.jsx)(eR,{size:16})})]},e.id))]}),(0,B.jsxs)("div",{className:"p-8 rounded-[2rem] bg-vibrant-mesh border border-white/10 space-y-6",children:[(0,B.jsxs)("div",{className:"flex items-center gap-4",children:[(0,B.jsx)("div",{className:"w-12 h-12 rounded-2xl bg-white/10 flex items-center justify-center text-white",children:(0,B.jsx)(eK,{size:24})}),(0,B.jsxs)("div",{children:[(0,B.jsx)("p",{className:"font-black text-white uppercase tracking-tight",children:"Excel Intelligence Autofill"}),(0,B.jsx)("p",{className:"text-xs text-white/60",children:"Import spreadsheet data to enable AI-powered form filling."})]})]}),(0,B.jsx)("input",{type:"file",accept:".xlsx,.csv",onChange:e=>{let n=e.target.files?.[0];n&&(alert(`Parsed ${n.name} for autofill intelligence.`),t.setExcelAutofillData([{site:"example.com",data:"Parsed From Excel"}]))},className:"hidden",id:"excel-upload"}),(0,B.jsx)("label",{htmlFor:"excel-upload",className:"inline-block px-8 py-3 bg-white text-black font-black rounded-xl text-[10px] uppercase tracking-widest cursor-pointer hover:scale-105 transition-all",children:"Import External Data"})]})]}),"extensions"===n&&(0,B.jsx)("div",{className:"space-y-8",children:(0,B.jsxs)("div",{className:"p-8 rounded-[2rem] bg-white/[0.03] border border-white/5 space-y-6",children:[(0,B.jsxs)("div",{className:"flex items-center gap-4",children:[(0,B.jsx)("div",{className:"w-12 h-12 rounded-2xl bg-purple-500/10 flex items-center justify-center text-purple-400",children:(0,B.jsx)(eq,{size:24})}),(0,B.jsxs)("div",{children:[(0,B.jsx)("p",{className:"font-bold text-white mb-1",children:"Custom Chrome Extensions"}),(0,B.jsx)("p",{className:"text-xs text-white/30",children:"Load and manage your local development plugins."})]})]}),(0,B.jsxs)("div",{className:"pt-4 space-y-4",children:[(0,B.jsxs)("div",{className:"p-6 rounded-2xl bg-black/40 border border-white/5",children:[(0,B.jsx)("p",{className:"text-[10px] font-black uppercase text-white/60 mb-4 tracking-widest",children:"Guide: Setting up your own extension"}),(0,B.jsxs)("ol",{className:"text-xs text-white/30 space-y-3 leading-relaxed",children:[(0,B.jsxs)("li",{children:["1. Create a directory containing your ",(0,B.jsx)("code",{className:"text-deep-space-accent-neon font-bold",children:"manifest.json"}),"."]}),(0,B.jsx)("li",{children:"2. Open your System/UserData directory."}),(0,B.jsxs)("li",{children:["3. Move your extension folder into the ",(0,B.jsx)("code",{className:"text-deep-space-accent-neon font-bold",children:"/extensions"})," sub-directory."]}),(0,B.jsx)("li",{children:"4. Restart Comet. Extensions are loaded at runtime for security."})]})]}),(0,B.jsxs)("button",{onClick:async()=>{let e=await window.electronAPI?.getExtensionPath();alert(`Drop your extension folders here: 
${e}`)},className:"px-6 py-3 bg-deep-space-accent-neon/10 border border-deep-space-accent-neon/20 text-deep-space-accent-neon font-black rounded-xl text-[10px] uppercase tracking-widest hover:bg-deep-space-accent-neon/20 transition-all flex items-center gap-2",children:[(0,B.jsx)(eY,{size:14})," View Extensions Dir"]})]})]})}),"about"===n&&(0,B.jsxs)("div",{className:"text-center py-20",children:[(0,B.jsx)("div",{className:"w-24 h-24 rounded-[2.5rem] bg-deep-space-accent-neon flex items-center justify-center text-deep-space-bg font-black text-6xl mx-auto mb-8 shadow-2xl animate-pulse",children:t.appName.charAt(0)}),(0,B.jsx)("h2",{className:"text-5xl font-black tracking-tighter mb-4",children:t.appName}),(0,B.jsx)("p",{className:"text-white/40 max-w-md mx-auto mb-10 text-sm leading-relaxed font-medium",children:"A performance-hardened Chromium shell with native AI orchestration, optimized for decentralized workflows."}),(0,B.jsxs)("div",{className:"flex items-center justify-center gap-4",children:[(0,B.jsx)("button",{className:"px-8 py-4 bg-white/5 border border-white/10 rounded-2xl text-[10px] font-black uppercase tracking-widest hover:bg-white/10 transition-all text-white/40",children:"Check build updates"}),(0,B.jsx)("button",{className:"px-8 py-4 bg-white/5 border border-white/10 rounded-2xl text-[10px] font-black uppercase tracking-widest hover:bg-white/10 transition-all text-white/40",children:"Documentation"})]})]})]})]})]})})};var eJ=e.i(18342);class eQ{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class e0{refCount(e){return e1("refCount")}incRef(e){return e1("incRef")}timerAvailable(){return!0}time(e){return e1("time")}read(e){return e1("read")}readSync(e){return e1("readSync")}readToGPU(e,t){return e1("readToGPU")}numDataIds(){return e1("numDataIds")}disposeData(e,t){return e1("disposeData")}write(e,t,n){return e1("write")}move(e,t,n,r,a){return e1("move")}createTensorFromGPUData(e,t,n){return e1("createTensorFromGPUData")}memory(){return e1("memory")}floatPrecision(){return e1("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return e1("dispose")}}function e1(e){throw Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function e2(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,e6(e,--t,n)}function e3(e,t){if(e.length!==t.length)throw Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,e6(e,--n,r),e6(t,n,r)}function e4(e,t,n){return Math.max(e,Math.min(t,n))}function e5(e){return e%2==0?e:e+1}function e6(e,t,n){let r=e[t];e[t]=e[n],e[n]=r}function e8(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function e7(e,t){let n=Math.random();return t*n+(1-n)*e}function e9(e,t){let n=0;for(let r=0;r<e.length;r++){let a=Number(e[r])-Number(t[r]);n+=a*a}return n}function te(e,t){if(!e)throw Error("string"==typeof t?t:t())}function tt(e,t,n=""){te(ti(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function tn(e){te(null!=e,()=>"The input to the tensor constructor must be a non-null value.")}function tr(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function ta(e){return 0===e.length}function ts(e,t){if(e===t)return!0;if(null==e||null==t||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(null!==e[n]&&null!==t[n]&&e[n]!==t[n])return!1;return!0}function ti(e,t){if(e===t)return!0;if(null==e||null==t||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function to(e){return e%1==0}function tl(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;{if(e===-1/0)return -1;let t=Math.exp(2*e);return(t-1)/(t+1)}}function tu(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function th(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return e2(t),t}function tp(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function td(e,t=e=>0,n,r){return new Promise((a,s)=>{let i=0,o=()=>{if(e())return void a();let l=t(++i);null!=n&&i>=n?s():null!=r?r(o,l):setTimeout(o,l)};o()})}function tc(e,t){let n=1,r=-1;for(let t=0;t<e.length;++t)if(e[t]>=0)n*=e[t];else if(-1===e[t]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${t}`);r=t}else if(e[t]<0)throw Error(`Shapes can not be < 0. Found ${e[t]} at dim ${t}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let a=e.slice();return a[r]=t/n,a}function tf(e,t){let n=t.length;return te((e=null==e?t.map((e,t)=>t):[].concat(e)).every(e=>e>=-n&&e<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),te(e.every(e=>to(e)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(e=>e<0?n+e:e)}function tm(e,t){let n=[],r=[],a=null!=t&&Array.isArray(t)&&0===t.length,s=null==t||a?null:tf(t,e).sort(),i=0;for(let t=0;t<e.length;++t){if(null!=s){if(s[i]===t&&1!==e[t])throw Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(null==s[i]||s[i]>t)&&1===e[t]&&(n.push(e[t]),r.push(t)),s[i]<=t&&i++}1!==e[t]&&(n.push(e[t]),r.push(t))}return{newShape:n,keptDims:r}}function tg(e,t){return ty(e,t)}function ty(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else if("string"===e)n=Array(t);else throw Error(`Unknown data type ${e}`);return n}function tx(e,t){for(let n=0;n<e.length;n++){let r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function tb(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function tw(e,t){return"complex64"!==t&&("float32"!==t||"complex64"===e)&&("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)}function tv(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw Error(`Unknown dtype ${e}`)}function tk(e){if(null==e)return 0;let t=0;return e.forEach(e=>t+=e.length),t}function tN(e){return"string"==typeof e||e instanceof String}function tI(e){return"boolean"==typeof e}function tS(e){return"number"==typeof e}function tC(e){if(Array.isArray(e))return tC(e[0]);if(e instanceof Float32Array);else if(e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray)return"int32";else if(tS(e));else if(tN(e))return"string";else if(tI(e))return"bool";return"float32"}function tT(e){return!!(e&&e.constructor&&e.call&&e.apply)}function t$(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function tE(e){let t=e.length;if(t<2)return[];let n=Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function tA(e,t,n=!1){if(0===e.length)return t[0];let r=e.reduce((e,t)=>e*t)*(n?2:1);if(0===r)return[];if(r!==t.length)throw Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return function e(t,n,r,a=!1){let s=[];if(1===n.length){let e=n[0]*(a?2:1);for(let n=0;n<e;n++)s[n]=r[t+n]}else{let i=n[0],o=n.slice(1),l=o.reduce((e,t)=>e*t)*(a?2:1);for(let n=0;n<i;n++)s[n]=e(t+n*l,o,r,a)}return s}(0,e,t,n)}function tR(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw Error(`Unknown dtype ${t}`)}function tF(e,t){let n=t_(e,t);for(let e=0;e<n.length;e++)n[e]=1;return n}function t_(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw Error(`Unknown data type ${t}`)}function tD(e,t){let n=e.reduce((e,t)=>e*t,1);if(null==t||"float32"===t)return tA(e,new Float32Array(n));if("int32"===t)return tA(e,new Int32Array(n));if("bool"===t)return tA(e,new Uint8Array(n));throw Error(`Unknown data type ${t}`)}function tO(e){e.forEach(t=>{te(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function tM(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let t=0;t<e.length-1;++t)r+=n[t]*e[t];return r}function tL(e,t,n){if(0===t)return[];if(1===t)return[e];let r=Array(t);for(let t=0;t<r.length-1;++t)r[t]=Math.floor(e/n[t]),e-=r[t]*n[t];return r[r.length-1]=e,r}function tz(e){return e&&e.then&&"function"==typeof e.then}e.s(["arraysEqual",()=>ti,"arraysEqualWithNull",()=>ts,"assert",()=>te,"assertNonNegativeIntegerDimensions",()=>tO,"assertNonNull",()=>tn,"assertShapesMatch",()=>tt,"bytesFromStringArray",()=>tk,"bytesPerElement",()=>tv,"checkConversionForErrors",()=>tx,"clamp",()=>e4,"computeStrides",()=>tE,"convertBackendValuesAndArrayBuffer",()=>tR,"createShuffledIndices",()=>th,"distSquared",()=>e9,"getArrayFromDType",()=>ty,"getTypedArrayFromDType",()=>tg,"hasEncodingLoss",()=>tw,"indexToLoc",()=>tL,"inferDtype",()=>tC,"inferFromImplicitShape",()=>tc,"isBoolean",()=>tI,"isFunction",()=>tT,"isInt",()=>to,"isNumber",()=>tS,"isPromise",()=>tz,"isScalarShape",()=>ta,"isString",()=>tN,"isValidDtype",()=>tb,"locToIndex",()=>tM,"makeOnesTypedArray",()=>tF,"makeZerosNestedTypedArray",()=>tD,"makeZerosTypedArray",()=>t_,"nearestDivisor",()=>t$,"nearestLargerEven",()=>e5,"parseAxisParam",()=>tf,"randUniform",()=>e7,"repeatedTry",()=>td,"rightPad",()=>tp,"shuffle",()=>e2,"shuffleCombo",()=>e3,"sizeFromShape",()=>tr,"sizeToSquarishShape",()=>tu,"squeezeShape",()=>tm,"sum",()=>e8,"swap",()=>e6,"tanh",()=>tl,"toNestedArray",()=>tA],63385);let tP="tfjsflags";class tB{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=tW,this.populateURLFlags()}setPlatform(e,t){null==this.platform||tU.getBool("IS_TEST")||tU.getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){let t=this.urlFlags[e];tU.getBool("IS_TEST")||tU.getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(tz(t))throw Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;let e=this.getQueryParams(this.global.location.search);tP in e&&e[tP].split(",").forEach(e=>{var t;let n,[r,a]=e.split(":");this.urlFlags[r]="true"===(n=(t=a).toLowerCase())||"false"===n?"true"===n:`${+n}`===n?+n:t})}}function tW(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...n)=>{var r,a,s;return r=t,a=n[0],s=n[1],r[decodeURIComponent(a)]=decodeURIComponent(s||""),n.join("=")}),t}let tU=null;function tj(){if(null==t){let n;t=n="undefined"!=typeof window?window:e.g}return t}function tV(e,t){let n,r=(null==(n=tj())._tfGlobals&&(n._tfGlobals=new Map),n._tfGlobals);if(r.has(e))return r.get(e);{let n=t();return r.set(e,n),r.get(e)}}let tG="Acos",tH="Acosh",tq="AddN",tK="ArgMax",tX="ArgMin",tY="Asin",tZ="Asinh",tJ="Atan",tQ="Atanh",t0="Atan2",t1="AvgPool",t2="AvgPoolGrad",t3="AvgPool3D",t4="AvgPool3DGrad",t5="BatchMatMul",t6="BatchToSpaceND",t8="Bincount",t7="BitwiseAnd",t9="BroadcastArgs",ne="Cast",nt="Ceil",nn="ClipByValue",nr="Complex",na="ComplexAbs",ns="Concat",ni="Conv2D",no="Conv2DBackpropFilter",nl="Conv2DBackpropInput",nu="Conv3D",nh="Conv3DBackpropFilterV2",np="Conv3DBackpropInputV2",nd="Cosh",nc="Cumprod",nf="Cumsum",nm="CropAndResize",ng="DenseBincount",ny="DepthToSpace",nx="DepthwiseConv2dNative",nb="DepthwiseConv2dNativeBackpropFilter",nw="DepthwiseConv2dNativeBackpropInput",nv="Diag",nk="Dilation2D",nN="Dilation2DBackpropInput",nI="Dilation2DBackpropFilter",nS="Draw",nC="RealDiv",nT="Einsum",n$="EluGrad",nE="Equal",nA="ExpandDims",nR="Expm1",nF="Fill",n_="FlipLeftRight",nD="Floor",nO="FloorDiv",nM="FusedBatchNorm",nL="GatherV2",nz="GatherNd",nP="Greater",nB="GreaterEqual",nW="Identity",nU="IFFT",nj="Imag",nV="IsFinite",nG="IsInf",nH="IsNan",nq="LeakyRelu",nK="Less",nX="LessEqual",nY="LinSpace",nZ="Log1p",nJ="LogicalAnd",nQ="LogicalNot",n0="LogicalOr",n1="LRNGrad",n2="Maximum",n3="MaxPool",n4="MaxPoolGrad",n5="MaxPool3D",n6="MaxPool3DGrad",n8="MaxPoolWithArgmax",n7="Mean",n9="Minimum",re="MirrorPad",rt="Multinomial",rn="Multiply",rr="NotEqual",ra="NonMaxSuppressionV3",rs="NonMaxSuppressionV4",ri="NonMaxSuppressionV5",ro="OnesLike",rl="OneHot",ru="Pack",rh="PadV2",rp="Prelu",rd="Prod",rc="RaggedGather",rf="RaggedRange",rm="RaggedTensorToTensor",rg="Range",ry="Real",rx="Reciprocal",rb="Relu",rw="Reshape",rv="ResizeNearestNeighbor",rk="ResizeNearestNeighborGrad",rN="ResizeBilinear",rI="ResizeBilinearGrad",rS="Relu6",rC="Reverse",rT="Round",r$="Rsqrt",rE="ScatterNd",rA="TensorScatterUpdate",rR="SearchSorted",rF="Select",r_="Selu",rD="Slice",rO="Sinh",rM="Sign",rL="Sigmoid",rz="Softplus",rP="Sqrt",rB="SpaceToBatchND",rW="SplitV",rU="Softmax",rj="SparseFillEmptyRows",rV="SparseReshape",rG="SparseSegmentMean",rH="SparseSegmentSum",rq="SparseToDense",rK="SquaredDifference",rX="Square",rY="StaticRegexReplace",rZ="StridedSlice",rJ="StringNGrams",rQ="StringSplit",r0="StringToHashBucketFast",r1="Tanh",r2="Tile",r3="TopK",r4="Transform",r5="Transpose",r6="Unique",r8="Unpack",r7="UnsortedSegmentSum",r9="ZerosLike",ae="Step",at="FromPixels",an="RotateWithOffset",ar="_FusedMatMul",aa="FusedConv2D",as="FusedDepthwiseConv2D";function ai(...e){tU.getBool("IS_TEST")||tU.getBool("PROD")||console.warn(...e)}function ao(...e){tU.getBool("IS_TEST")||tU.getBool("PROD")||console.log(...e)}e.s(["log",()=>ao,"warn",()=>ai],91338);let al=tV("kernelRegistry",()=>new Map),au=tV("gradRegistry",()=>new Map);function ah(e,t){var n,r;let a=(n=e,r=t,`${r}_${n}`);return al.get(a)}function ap(e){let t=al.entries(),n=[];for(;;){let{done:r,value:a}=t.next();if(r)break;let[s,i]=a,[o]=s.split("_");o===e&&n.push(i)}return n}function ad(e){var t,n;let{kernelName:r,backendName:a}=e,s=(t=r,n=a,`${n}_${t}`);al.has(s)&&ai(`The kernel '${r}' for backend '${a}' is already registered`),al.set(s,e)}function ac(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}function af(e,t){return"string"===t?ax(e):am([e],t)}function am(e,t){var n;if("string"===t)throw Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=av(e)),tU.getBool("DEBUG")&&tx(e,t),(n=e)instanceof Float32Array&&"float32"===t||n instanceof Int32Array&&"int32"===t||n instanceof Uint8Array&&"bool"===t)return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){let t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw Error(`Unknown data type ${t}`)}function ag(){return tU.platform.now()}function ay(e,t){return tU.platform.fetch(e,t)}function ax(e,t="utf-8"){return t=t||"utf-8",tU.platform.encode(e,t)}function ab(e,t="utf-8"){return t=t||"utf-8",tU.platform.decode(e,t)}function aw(e){return null!=tU.platform.isTypedArray?tU.platform.isTypedArray(e):ac(e)}function av(e,t=[],n=!1){if(null==t&&(t=[]),"boolean"==typeof e||"number"==typeof e||"string"==typeof e||tz(e)||null==e||aw(e)&&n)t.push(e);else if(Array.isArray(e)||aw(e))for(let r=0;r<e.length;++r)av(e[r],t,n);else{let r=-1;for(let t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let a=0;a<=r;a++)av(e[a],t,n)}return t}e.s(["createScalarValue",()=>af,"decodeString",()=>ab,"encodeString",()=>ax,"fetch",()=>ay,"flatten",()=>av,"isTypedArray",()=>aw,"now",()=>ag,"toTypedArray",()=>am],94150);class ak{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new aN)}profileKernel(e,t,n){let r,a,s=()=>{r=n()},i=ag();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{for(let e of(s(),r))e.dataSync();a=Promise.resolve({kernelMs:ag()-i})}if(tU.getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let t=0;t<r.length;t++){let n=r[t];n.data().then(t=>{!function(e,t,n){if("float32"===t)for(let t=0;t<e.length;t++){let r=e[t];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}}(t,n.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then(e=>e.kernelMs),extraInfo:a.then(e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:r,inputs:a,extraInfo:s}=e;n.forEach(e=>{Promise.all([e.data(),r,s]).then(n=>{this.logger.logKernelProfile(t,e,n[0],n[1],a,n[2])})})}}class aN{logKernelProfile(e,t,n,r,a,s){let i="number"==typeof r?tp(`${r}ms`,9):r.error,o=tp(e,25),l=t.rank,u=t.size,h=tp(t.shape.toString(),14),p="";for(let e in a){let n=a[e];if(null!=n){let r=n.shape||t.shape,a=r.length;p+=`${e}: ${a}D ${a>0?r:""} `}}console.log(`%c${o}	%c${i}	%c${l}D ${h}	%c${u}	%c${p}	%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function aI(e,t,n){return tp(Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:tN(e)?`'${e}'`:"bool"===n?aS(e):parseFloat(e.toFixed(7)).toString(),t)}function aS(e){return 0===e?"false":"true"}function aC(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class aT{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=tr(e),null!=n){const e=n.length;te(e===this.size,()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===t)throw Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||ty(t,this.size),this.strides=tE(e)}set(e,...t){0===t.length&&(t=[0]),te(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(let n of e){if(n<0||n>=this.shape[t])throw Error(`Requested out of range element at ${e}.   Buffer shape=${this.shape}`);t++}let n=e[e.length-1];for(let t=0;t<e.length-1;++t)n+=this.strides[t]*e[t];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];let t=Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return a$().makeTensor(this.values,this.shape,this.dtype)}}let a$=null,aE=null;class aA{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=tr(e),this.strides=tE(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return aE.buffer(this.shape,this.dtype,e)}bufferSync(){return aE.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return tA(this.shape,e,"complex64"===this.dtype)}arraySync(){return tA(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();let e=a$().read(this.dataId);if("string"===this.dtype){let t=await e;try{return t.map(e=>ab(e))}catch(e){throw Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),a$().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=a$().readSync(this.dataId);if("string"===this.dtype)try{return e.map(e=>ab(e))}catch(e){throw Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await a$().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),a$().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw Error("Tensor is disposed.")}print(e=!1){return aE.print(this,e)}clone(){return this.throwIfDisposed(),aE.clone(this)}toString(e=!1){var t,n,r;let a,s,i,o,l;return t=this.dataSync(),n=this.shape,r=this.dtype,a=tE(n),s=function(e,t,n,r){let a=tr(t),s=r[r.length-1],i=Array(s).fill(0),o=t.length,l="complex64"===n?aC(e):e;if(o>1)for(let e=0;e<a/s;e++){let t=e*s;for(let e=0;e<s;e++)i[e]=Math.max(i[e],aI(l[t+e],0,n).length)}return i}(t,n,r,a),i=n.length,o=function e(t,n,r,a,s,i=!0){let o="complex64"===r?2:1,l=n[0],u=n.length;if(0===u)return"complex64"===r?[aI(aC(t)[0],0,r)]:"bool"===r?[aS(t[0])]:[t[0].toString()];if(1===u){if(l>20){let e=Array.from(t.slice(0,3*o)),n=Array.from(t.slice((l-3)*o,l*o));return"complex64"===r&&(e=aC(e),n=aC(n)),["["+e.map((e,t)=>aI(e,s[t],r)).join(", ")+", ..., "+n.map((e,t)=>aI(e,s[l-3+t],r)).join(", ")+"]"]}return["["+("complex64"===r?aC(t):Array.from(t)).map((e,t)=>aI(e,s[t],r)).join(", ")+"]"]}let h=n.slice(1),p=a.slice(1),d=a[0]*o,c=[];if(l>20){for(let n=0;n<3;n++){let a=n*d,i=a+d;c.push(...e(t.slice(a,i),h,r,p,s,!1))}c.push("...");for(let n=l-3;n<l;n++){let a=n*d,i=a+d;c.push(...e(t.slice(a,i),h,r,p,s,n===l-1))}}else for(let n=0;n<l;n++){let a=n*d,i=a+d;c.push(...e(t.slice(a,i),h,r,p,s,n===l-1))}let f=2===u?",":"";c[0]="["+(l>0?c[0]+f:"");for(let e=1;e<c.length-1;e++)c[e]=" "+c[e]+f;let m=",\n";for(let e=2;e<u;e++)m+="\n";return c[c.length-1]=" "+c[c.length-1]+"]"+(i?"":m),c}(t,n,r,a,s),l=["Tensor"],e&&(l.push(`  dtype: ${r}`),l.push(`  rank: ${i}`),l.push(`  shape: [${n}]`),l.push("  values:")),l.push(o.map(e=>"    "+e).join("\n")),l.join("\n")}cast(e){return this.throwIfDisposed(),aE.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),a$().makeVariable(this,e,t,n)}}function aR(){return tV("Tensor",()=>aA)}Object.defineProperty(aA,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),aR();class aF extends aA{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!ti(e.shape,this.shape))throw Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);a$().disposeTensor(this),this.dataId=e.dataId,a$().incRef(this,null)}dispose(){a$().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(aF,Symbol.hasInstance,{value:e=>e instanceof aA&&null!=e.assign&&e.assign instanceof Function}),(u=S||(S={})).R0="R0",u.R1="R1",u.R2="R2",u.R3="R3",u.R4="R4",u.R5="R5",u.R6="R6",(h=C||(C={})).float32="float32",h.int32="int32",h.bool="int32",h.complex64="complex64",(p=T||(T={})).float32="float32",p.int32="int32",p.bool="bool",p.complex64="complex64",(d=$||($={})).float32="float32",d.int32="float32",d.bool="float32",d.complex64="complex64",(c=E||(E={})).float32="complex64",c.int32="complex64",c.bool="complex64",c.complex64="complex64";let a_={float32:$,int32:C,bool:T,complex64:E};function aD(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw Error(`Can not upcast ${e} with ${t}`)}return a_[e][t]}function aO(e){return aD(e,"int32")}function aM(e){return null!=e&&"object"==typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function aL(e){return"undefined"!=typeof GPUBuffer&&null!=e&&"object"==typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function az(e,t){if(e.dtype===t.dtype)return[e,t];let n=aD(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function aP(e,t){te(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function aB(e,t){return t.some(t=>t.id===e.id)}function aW(e){let t=[];return function e(t,n,r){var a;if(null!=t){if(t instanceof aA)return void n.push(t);if(Array.isArray(a=t)||"object"==typeof a)for(let a in t){let s=t[a];r.has(s)||(r.add(s),e(s,n,r))}}}(e,t,new Set),t}function aU(e){return null!=e.kernelName}e.s(["assertTypesMatch",()=>aP,"getTensorsInContainer",()=>aW,"isTensorInList",()=>aB,"makeTypesMatch",()=>az],9e4);class aj{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}}class aV{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new aj}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then(()=>{});if(null!=this.backendInstance)return;let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){let{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(!(e in this.registryFactory))return null;else{let{asyncInit:t}=this.initializeBackend(e);if(t)return null}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(ai(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;let{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new ak(this.backendInstance),!0}setupRegisteredKernels(){ap(this.backendName).forEach(e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){ap(e).forEach(t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])})}initializeBackend(e){let t=this.registryFactory[e];if(null==t)throw Error(`Cannot initialize backend ${e}, no registration found.`);try{let n=t.factory();if(!n||n instanceof e0||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{let t=++this.pendingBackendInitId,r=n.then(n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0)).catch(n=>!(t<this.pendingBackendInitId)&&(this.pendingBackendInit=null,ai(`Initialization of backend ${e} failed`),ai(n.stack||n.message),!1));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(t){return ai(`Initialization of backend ${e} failed`),ai(t.stack||t.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t],{success:r,asyncInit:a}=this.initializeBackend(n);if(a||r)return{name:n,asyncInit:a}}throw Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){let n=this.state.tensorInfo.get(t),r=n.backend,a=this.readSync(t),s=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,a,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun(()=>this.startScope(r),()=>this.endScope(n),()=>((n=t())instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n))}scopedRun(e,t,n){e();try{let e=n();return t(),e}catch(e){throw t(),e}}nextTensorId(){return aV.nextTensorId++}nextVariableId(){return aV.nextVariableId++}clone(e){let t=aH.runKernel(nW,{x:e});return this.addTapeNode(this.state.activeScope.name,{x:e},[t],e=>({x:()=>aH.runKernel(ne,{x:e},{dtype:"float32"})}),[],{}),t}runKernel(e,t,n){if(null==this.backendName&&this.backend,null==ah(e,this.backendName))throw Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){let r=this.backend.numDataIds(),a=0;n.forEach(e=>{a+="complex64"===e.dtype?3:1});let s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-a-s;if(i>0)throw Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n,r,a,s=[],i=this.isTapeOn(),o=this.state.numBytes,l=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;let u=aU(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(aU(e)){let{kernelName:t,inputs:a,attrs:o}=e;null==this.backendName&&this.backend;let l=ah(t,this.backendName);te(null!=l,()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`),n=()=>{let e=this.backend.numDataIds(),n=Array.isArray(r=l.kernelFunc({inputs:a,attrs:o,backend:this.backend}))?r:[r];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,n);let u=n.map(e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e));if(i){let e=this.getTensorsForGradient(t,a,u);s=this.saveTensorsForBackwardMode(e)}return u}}else{let{forwardFunc:t}=e,a=e=>{i&&(s=e.map(e=>this.keep(this.clone(e))))};n=()=>{let e=this.backend.numDataIds(),n=Array.isArray(r=this.tidy(()=>t(this.backend,a)))?r:[r];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,e,n),n}}let{inputs:h,attrs:p}=e,d=aU(e)?null:e.backwardsFunc;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(a=this.profiler.profileKernel(u,h,()=>n()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(a),t=a.outputs):t=n()}),i&&this.addTapeNode(u,h,t,d,s,p),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-l,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(h).map(e=>null!=h[e]?h[e].shape:null),outputShapes:t.map(e=>e.shape),kernelTimeMs:a.timeMs,extraInfo:a.extraInfo}),Array.isArray(r)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(e=>this.keep(this.clone(e)))}getTensorsForGradient(e,t,n){let r=au.get(e);if(null!=r){let e,a=r.inputsToSave||[],s=r.outputsToSave||[];r.saveAllInputs?(te(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),e=Object.keys(t).map(e=>t[e])):e=a.map(e=>t[e]);let i=n.filter((e,t)=>s[t]);return e.concat(i)}return[]}makeTensor(e,t,n,r){if(null==e)throw Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let a=e;"string"===n&&tN(e[0])&&(a=e.map(e=>ax(e)));let s=r.write(a,t,n),i=new aA(t,n,s,this.nextTensorId());if(this.trackTensor(i,r),"string"===n){let e=this.state.tensorInfo.get(s),t=tk(a);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){let a={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(e,t){let{dataId:n,shape:r,dtype:a}=e,s=new aA(r,a,n,this.nextTensorId());return this.trackTensor(s,t),s}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));let a=new aF(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[a.name])throw Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*tv(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof aF||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){let t=e.size*tv(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;let t=this.state.numBytes,n=this.state.numTensors;for(let r of(this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(e=>e.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n,this.state.activeProfile.kernels))r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,a,s){let i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:a},o=au.get(e);null!=o&&(r=o.gradFunc),null!=r&&(i.gradient=e=>(e=e.map((e,t)=>{if(null==e){let e=n[t],r=t_(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e}),r(e.length>1?e:e[0],a,s))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){let t=aW(e),n=new Set(t.map(e=>e.id));for(let e=0;e<this.state.activeScope.track.length;e++){let t=this.state.activeScope.track[e];t.kept||n.has(t.id)||t.dispose()}let r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(e=>{e.kept||e.scopeId!==r.id||this.track(e)})}gradients(e,t,n,r=!1){if(te(t.length>0,()=>"gradients() received an empty list of xs."),null!=n&&"float32"!==n.dtype)throw Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let a=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));te(a instanceof aA,()=>"The result y returned by f() must be a tensor.");let s=function(e,t,n){let r={},a={};for(let e=0;e<t.length;e++)r[t[e].id]=!0;for(let n=0;n<e.length;n++){let s=e[n],i=s.inputs;for(let e in i){let n=i[e],o=!1;for(let e=0;e<t.length;e++)if(r[n.id]){s.outputs.forEach(e=>r[e.id]=!0),o=!0,a[s.id]=!0;break}if(o)break}}let s={};s[n.id]=!0;let i={};for(let t=e.length-1;t>=0;t--){let n=e[t],r=n.inputs;for(let e=0;e<n.outputs.length;e++)if(s[n.outputs[e].id]){for(let e in r)s[r[e].id]=!0,i[n.id]=!0;break}}let o=[];for(let t=0;t<e.length;t++){let n=e[t];if(a[n.id]&&i[n.id]){let e={};for(let t in n.inputs){let a=n.inputs[t];r[a.id]&&(e[t]=a)}let t=Object.assign({},n);t.inputs=e,t.outputs=n.outputs,o.push(t)}}return o}(this.state.activeTape,t,a);if(!r&&0===s.length&&t.length>0)throw Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{var e;let r,i={};i[a.id]=null==n?(r=tF(tr(e=a.shape),"float32"),aH.makeTensor(r,e,"float32")):n,function(e,t,n,r){for(let a=t.length-1;a>=0;a--){let s=t[a],i=[];if(s.outputs.forEach(t=>{let n=e[t.id];null!=n?i.push(n):i.push(null)}),null==s.gradient)throw Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let o=s.gradient(i);for(let t in s.inputs){if(!(t in o))throw Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);let a=n(()=>o[t]());if("float32"!==a.dtype)throw Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${a.dtype}'`);let i=s.inputs[t];if(!ti(a.shape,i.shape))throw Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${t}' has shape '${a.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=a;else{let t=e[i.id];e[i.id]=r(t,a),t.dispose()}}}}(i,s,e=>this.tidy(e),aq);let o=t.map(e=>i[e.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(e=>{for(let t of e.saved)t.dispose()}),this.state.activeTape=null),{value:a,grads:o}})}customGrad(e){return te(tT(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{let n;te(t.every(e=>e instanceof aA),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r={};return t.forEach((e,t)=>{r[t]=e}),this.runKernelFunc({forwardFunc:(r,a)=>(te((n=e(...t,a)).value instanceof aA,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),te(tT(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),backwardsFunc:(e,r)=>{let a=n.gradFunc(e,r),s=Array.isArray(a)?a:[a];te(s.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),te(s.every(e=>e instanceof aA),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let i={};return s.forEach((e,t)=>{i[t]=()=>e}),i},inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){let t=ag(),n=await this.backend.time(e);return n.wallMs=ag()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){for(let e in this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new aj,this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function aG(){let e=tj();if(null==e._tfengine){let t=new tB(e);e._tfengine=new aV(t)}return tU=e._tfengine.ENV,a$=()=>e._tfengine,e._tfengine}aV.nextTensorId=0,aV.nextVariableId=0;let aH=aG();function aq(e,t){return aH.runKernel("Add",{a:e,b:t})}function aK(e){n=e}function aX(e){if(void 0!==n)return n;if(e||"undefined"!=typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;let t=e.userAgent||e.vendor||("undefined"!=typeof window?window.opera:"");if(!t){let t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function aY(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}e.s(["isBrowser",()=>aY,"isMobile",()=>aX,"mockIsMobile",()=>aK],31654);let aZ=tU;aZ.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),aZ.registerFlag("IS_BROWSER",()=>aY()),aZ.registerFlag("IS_NODE",()=>void 0!==X.default&&void 0!==X.default.versions&&void 0!==X.default.versions.node),aZ.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),aZ.registerFlag("IS_SAFARI",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),aZ.registerFlag("PROD",()=>!1),aZ.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>aZ.getBool("DEBUG")),aZ.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),aZ.registerFlag("IS_TEST",()=>!1),aZ.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>aZ.getBool("DEBUG")),aZ.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),aZ.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),aZ.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);var aJ=e.i(9738);function aQ(e,t){let n=e;if(aw(e))return"string"===t?[]:[e.length];if(aM(e)){let t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(aL(e))return[e.buffer.size/(null==t?4:tv(t))];if(!Array.isArray(e))return[];let r=[];for(;Array.isArray(n)||aw(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&tU.getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&function e(t,n,r){if(r=r||[],!Array.isArray(t)&&!aw(t))return void te(0===n.length,()=>`Element arr[${r.join("][")}] is a primitive, but should be an array/TypedArray of ${n[0]} elements`);te(n.length>0,()=>`Element arr[${r.join("][")}] should be a primitive, but is an array of ${t.length} elements`),te(t.length===n[0],()=>`Element arr[${r.join("][")}] should have ${n[0]} elements, but has ${t.length} elements`);let a=n.slice(1);for(let n=0;n<t.length;++n)e(t[n],a,r.concat(n))}(e,r,[]),r}function a0(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function a1(e,t,n,r="numeric"){if(e instanceof aR())return a0(r,e.dtype,t,n),e;let a=tC(e);if("string"!==a&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),a0(r,a,t,n),null==e||!aw(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){let r=null==e?"null":e.constructor.name;throw Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}let s=aQ(e,a);aw(e)||Array.isArray(e)||(e=[e]);let i="string"!==a?am(e,a):av(e,[],!0);return aH.makeTensor(i,s,a)}function a2(e,t,n,r="numeric"){if(!Array.isArray(e))throw Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((e,a)=>a1(e,`${t}[${a}]`,n,r))}let a3="__op";function a4(e){let t=Object.keys(e);if(1!==t.length)throw Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1));let a=(...e)=>{aH.startScope(n);try{let t=r(...e);return tz(t)&&console.error("Cannot return a Promise inside of tidy."),aH.endScope(t),t}catch(e){throw aH.endScope(null),e}};return Object.defineProperty(a,"name",{value:n+=a3,configurable:!0}),a}let a5=a4({complex_:function(e,t){let n=a1(e,"real","complex"),r=a1(t,"imag","complex");return tt(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`),aH.runKernel(nr,{real:n,imag:r})}});function a6(e,t,n,r){if(null==r)r=tC(e);else if("complex64"===r)throw Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(aL(e)||aM(e)){if("float32"!==r&&"int32"!==r)throw Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return aH.backend.createTensorFromGPUData(e,t||n,r)}if(!aw(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){tO(t);let e=tr(t),r=tr(n);te(e===r,()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`);for(let e=0;e<n.length;++e){let r=n[e],a=e!==n.length-1||r!==tr(t.slice(e));te(n[e]===t[e]||!a,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return aw(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==r?am(e,r):av(e,[],!0),aH.makeTensor(e,t,r)}function a8(e,t,n){let r=aQ(e,n);return a6(e,t,r,n)}let a7={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class a9{static join(e){return new a9(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e||(e instanceof Array||(e=[e]),0===(e=e.map(e=>aw(e)?e.buffer:e)).length))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const r=e[n];n!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const a=t+r.byteLength;this.shards.push({buffer:r,start:t,end:a}),t=a}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(0===this.shards.length||(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),(t=Math.min(this.byteLength,t))<=e))return new ArrayBuffer(0);let n=this.findShardForByte(e);if(-1===n)throw Error(`Could not find start shard for byte ${e}`);let r=new ArrayBuffer(t-e),a=new Uint8Array(r),s=0;for(let r=n;r<this.shards.length;r++){let n=this.shards[r],i=e+s-n.start,o=s,l=Math.min(t,n.end)-n.start,u=new Uint8Array(n.buffer,i,l-i);if(a.set(u,o),s+=u.length,t<n.end)break}return r}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return -1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:+(e>=t.end)}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;let n=function(e,t){let n=0,r=e.length;for(;n<=r;){let a=Math.floor((r-n)/2)+n,s=t(e[a]);if(0===s)return a;s<0?r=a:n=a+1}return -1}(this.shards,t);return -1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function se(){return aH.memory()}function st(e,t){return aH.tidy(e,t)}function sn(e){aW(e).forEach(e=>e.dispose())}function sr(e){return aH.keep(e)}function sa(e,t,n=1){return aH.registerBackend(e,t,n)}async function ss(e,t){let n=[],r=[],a=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);for(let s=0;s<a.length;++s){let i=a[s],o=Array.isArray(e)?e[s].tensor:e[i];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw Error(`Unsupported dtype in weight '${i}': ${o.dtype}`);let l={name:i,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){let e=new Promise(async e=>{let t=await o.bytes(),n=new Uint8Array(t.reduce((e,t)=>e+t.length,0)+4*t.length),r=0;for(let e=0;e<t.length;e++){let a=t[e],s=new Uint8Array(new Uint32Array([a.length]).buffer);n.set(s,r),r+=4,n.set(a,r),r+=a.length}e(n)});r.push(e)}else r.push(o.data());null!=t&&(l.group=t),n.push(l)}return{data:function(e){if(null===e)throw Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach(e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)});let r=new Uint8Array(t),a=0;return n.forEach(e=>{r.set(new Uint8Array(e.buffer),a),a+=e.byteLength}),r.buffer}(await Promise.all(r)),specs:n}}function si(e,t){let n=new a9(e),r={},a=0;for(let e of t){let t=function(e,t){let n,r=tr(e.shape);if("quantization"in e)n=a7[e.quantization.dtype];else if("string"===e.dtype){let e=0;for(let n=0;n<r;n++)e+=4+new Uint32Array(t(e,e+4))[0];return e}else n=a7[e.dtype];return r*n}(e,(e,t)=>n.slice(a+e,a+t));r[e.name]=sl(e,n.slice(a,a+t)),a+=t}return r}async function so(e,t){let n,r=tr(e.shape);if("quantization"in e)n=a7[e.quantization.dtype];else if("string"===e.dtype){let e=0;for(let n=0;n<r;n++)e+=4+new Uint32Array(await t(e,e+4))[0];return e}else n=a7[e.dtype];return r*n}function sl(e,t){let n,r=e.name,a=e.dtype,s=e.shape,i=tr(s),o=0;if("quantization"in e){let s=e.quantization;if("uint8"===s.dtype||"uint16"===s.dtype){if(!("min"in s&&"scale"in s))throw Error(`Weight ${e.name} with quantization ${s.dtype} doesn't have corresponding metadata min and scale.`)}else if("float16"===s.dtype){if("float32"!==a)throw Error(`Weight ${e.name} is quantized with ${s.dtype} which only supports weights of type float32 not ${a}.`)}else throw Error(`Weight ${e.name} has unknown quantization dtype ${s.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let l=a7[s.dtype],u="uint8"===s.dtype?new Uint8Array(t):new Uint16Array(t);if("float32"===a)if("uint8"===s.dtype||"uint16"===s.dtype){n=new Float32Array(u.length);for(let e=0;e<u.length;e++){let t=u[e];n[e]=t*s.scale+s.min}}else if("float16"===s.dtype){let e,t,r;n=(e=function(){let e=e=>{let t=e<<13,n=0;for(;(8388608&t)==0;)n-=8388608,t<<=1;return(t&=-8388609)|(n+=0x38800000)},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let e=1024;e<2048;e++)t[e]=0x38000000+(e-1024<<13);return t}(),t=function(){let e=new Uint32Array(64);e[0]=0,e[31]=0x47800000,e[32]=0x80000000,e[63]=0xc7800000;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=0x80000000+(t-32<<23);return e}(),r=function(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}(),n=>{let a=new ArrayBuffer(4*n.length),s=new Uint32Array(a);for(let a=0;a<n.length;a++){let i=n[a],o=e[r[i>>10]+(1023&i)]+t[i>>10];s[a]=o}return new Float32Array(a)})(u)}else throw Error(`Unsupported quantization type ${s.dtype} for weight type float32.`);else if("int32"===a){if("uint8"!==s.dtype&&"uint16"!==s.dtype)throw Error(`Unsupported quantization type ${s.dtype} for weight type int32.`);n=new Int32Array(u.length);for(let e=0;e<u.length;e++){let t=u[e];n[e]=Math.round(t*s.scale+s.min)}}else throw Error(`Unsupported dtype in weight '${r}': ${a}`);o+=i*l}else if("string"===a){let r=tr(e.shape);n=[];for(let e=0;e<r;e++){let e=new Uint32Array(t.slice(o,o+4))[0];o+=4;let r=new Uint8Array(t.slice(o,o+e));n.push(r),o+=e}}else{let e=a7[a];if("float32"===a)n=new Float32Array(t);else if("int32"===a)n=new Int32Array(t);else if("bool"===a)n=new Uint8Array(t);else if("complex64"===a){n=new Float32Array(t);let e=new Float32Array(n.length/2),r=new Float32Array(n.length/2);for(let t=0;t<e.length;t++)e[t]=n[2*t],r[t]=n[2*t+1];let a=a8(e,s,"float32"),i=a8(r,s,"float32"),o=a5(a,i);return a.dispose(),i.dispose(),o}else throw Error(`Unsupported dtype in weight '${r}': ${a}`);o+=i*e}return a8(n,s,a)}async function su(e,t,n){let r=new Uint8Array(t);for(;r.byteLength<n;){let{done:t,value:a}=await e.read();if(t&&null==a){let e=n-r.byteLength;throw Error(`Reader is done but ${e} bytes are still expected`)}let s=new Uint8Array(r.length+a.byteLength);s.set(r,0),s.set(new Uint8Array(a),r.length),r=s}return r.buffer}async function sh(e,t){let n={},r=e.getReader(),a=new ArrayBuffer(0);for(let e of t){let t=await so(e,async(e,t)=>(a=await su(r,a,t)).slice(e,t)),s=(a=await su(r,a,t)).slice(0,t);a=a.slice(t);let i=sl(e,s);if(n[e.name]=i,"webgpu"===aH.backendName){let e=aH.backend;"uploadToGPU"in e&&tr(i.shape)>=tU.get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&e.uploadToGPU(i.dataId)}}return n}let sp=void 0!==aJ.Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function sd(e){return sp?aJ.Buffer.byteLength(e,"utf8"):new Blob([e]).size}function sc(e){return a9.join(e)}function sf(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);let t=e.split("/");return t[t.length-1]}function sm(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function sg(e,t,n){let r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),r}async function sy(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=await t(e.weightsManifest)),sg(e,n,r)}function sx(e){if(e.modelTopology instanceof ArrayBuffer)throw Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:sd(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:sd(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new a9(e.weightData).byteLength}}function sb(e){let t=[];for(let n of e)t.push(...n.weights);return t}class sw{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==sw.instance&&(sw.instance=new sw),sw.instance}static registerSaveRouter(e){sw.getInstance().saveRouters.push(e)}static registerLoadRouter(e){sw.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return sw.getHandlers(e,"save")}static getLoadHandlers(e,t){return sw.getHandlers(e,"load",t)}static getHandlers(e,t,n){let r=[];return("load"===t?sw.getInstance().loadRouters:sw.getInstance().saveRouters).forEach(t=>{let a=t(e,n);null!==a&&r.push(a)}),r}}let sv="tensorflowjs",sk="models_store",sN="model_info_store";function sI(){if(!tU.getBool("IS_BROWSER"))throw Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw Error("The current browser does not appear to support IndexedDB.");return t}function sS(e){let t=e.result;t.createObjectStore(sk,{keyPath:"modelPath"}),t.createObjectStore(sN,{keyPath:"modelPath"})}class sC{constructor(e){if(this.indexedDB=sI(),null==e||!e)throw Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((e,n)=>{let r=this.indexedDB.open(sv,1);r.onupgradeneeded=()=>sS(r),r.onsuccess=()=>{let a=r.result;if(null==t){let t=a.transaction(sk,"readonly"),r=t.objectStore(sk).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return a.close(),n(Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(a.close(),n(r.error)),t.oncomplete=()=>a.close()}else{let r,s;t.weightData=a9.join(t.weightData);let i=sx(t),o=a.transaction(sN,"readwrite"),l=o.objectStore(sN);try{r=l.put({modelPath:this.modelPath,modelArtifactsInfo:i})}catch(e){return n(e)}r.onsuccess=()=>{let r,u=(s=a.transaction(sk,"readwrite")).objectStore(sk);try{r=u.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i})}catch(e){return n(e)}r.onsuccess=()=>e({modelArtifactsInfo:i}),r.onerror=e=>{let t=(l=o.objectStore(sN)).delete(this.modelPath);t.onsuccess=()=>(a.close(),n(r.error)),t.onerror=e=>(a.close(),n(r.error))}},r.onerror=e=>(a.close(),n(r.error)),o.oncomplete=()=>{null==s?a.close():s.oncomplete=()=>a.close()}}},r.onerror=e=>n(r.error)})}}sC.URL_SCHEME="indexeddb://";let sT=e=>{var t;return tU.getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(sC.URL_SCHEME)?(t=e.slice(sC.URL_SCHEME.length),new sC(t)):null};sw.registerSaveRouter(sT),sw.registerLoadRouter(sT);let s$="tensorflowjs_models",sE="info";function sA(e){return{info:[s$,e,sE].join("/"),topology:[s$,e,"model_topology"].join("/"),weightSpecs:[s$,e,"weight_specs"].join("/"),weightData:[s$,e,"weight_data"].join("/"),modelMetadata:[s$,e,"model_metadata"].join("/")}}function sR(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}class sF{constructor(e){if(!tU.getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=sA(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=sx(e),a=a9.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(e){if(sp)return aJ.Buffer.from(e).toString("base64");let t=new Uint8Array(e),n="";for(let e=0,r=t.length;e<r;e++)n+=String.fromCharCode(t[e]);return btoa(n)}(a));let s={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:r}}catch(e){throw sR(this.keys),Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;let a=this.LS.getItem(this.keys.modelMetadata);if(null!=a){let e=JSON.parse(a);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}let s=this.LS.getItem(this.keys.weightData);if(null==s)throw Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(e){if(sp){let t=aJ.Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let e=0;e<t.length;++e)n.set([t.charCodeAt(e)],e);return n.buffer}(s),t}}sF.URL_SCHEME="localstorage://";let s_=e=>{var t;return tU.getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(sF.URL_SCHEME)?(t=e.slice(sF.URL_SCHEME.length),new sF(t)):null};sw.registerSaveRouter(s_),sw.registerLoadRouter(s_);class sD{constructor(){this.managers={}}static getInstance(){return null==sD.instance&&(sD.instance=new sD),sD.instance}static registerManager(e,t){te(null!=e,()=>"scheme must not be undefined or null."),e.endsWith("://")&&(e=e.slice(0,e.indexOf("://"))),te(e.length>0,()=>"scheme must not be an empty string.");let n=sD.getInstance();te(null==n.managers[e],()=>`A model store manager is already registered for scheme '${e}'.`),n.managers[e]=t}static getManager(e){let t=sD.getInstance().managers[e];if(null==t)throw Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(sD.getInstance().managers)}}function sO(e){if(-1===e.indexOf("://"))throw Error(`The url string provided does not contain a scheme. Supported schemes are: ${sD.getSchemes().join(",")}`);return{scheme:e.split("://")[0],path:e.split("://")[1]}}async function sM(e,t,n=!1){te(e!==t,()=>`Old path and new path are the same: '${e}'`);let r=sw.getLoadHandlers(e);te(r.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),te(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`);let a=r[0],s=sw.getSaveHandlers(t);te(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),te(s.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);let i=s[0],o=sO(e).scheme,l=sO(e).path,u=o===sO(e).scheme,h=await a.load();n&&u&&await sD.getManager(o).removeModel(l);let p=await i.save(h);return n&&!u&&await sD.getManager(o).removeModel(l),p.modelArtifactsInfo}async function sL(){let e=sD.getSchemes(),t={};for(let n of e){let e=await sD.getManager(n).listModels();for(let r in e)t[n+"://"+r]=e[r]}return t}async function sz(e){let t=sO(e);return sD.getManager(t.scheme).removeModel(t.path)}async function sP(e,t){return sM(e,t,!1)}async function sB(e,t){return sM(e,t,!0)}if(tU.get("IS_BROWSER")){tU.setPlatform("browser",new class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!=typeof window&&tU.getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",e=>{e.source===window&&e.data.name===this.messageName&&(e.stopPropagation(),(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0))):setTimeout(e,t)}isTypedArray(e){return ac(e)}});try{sD.registerManager(sF.URL_SCHEME,new class{constructor(){te(tU.getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),te("undefined"==typeof window||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=s$+"/",n="/"+sE;for(let r=0;r<this.LS.length;++r){let a=this.LS.key(r);a.startsWith(t)&&a.endsWith(n)&&(e[function(e){let t=e.split("/");if(t.length<3)throw Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join("/")}(a)]=JSON.parse(this.LS.getItem(a)))}return e}async removeModel(e){var t;let n=sA(e=(t=e).startsWith(sF.URL_SCHEME)?t.slice(sF.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw Error(`Cannot find model at path '${e}'`);let r=JSON.parse(this.LS.getItem(n.info));return sR(n),r}})}catch(e){}try{sD.registerManager(sC.URL_SCHEME,new class{constructor(){this.indexedDB=sI()}async listModels(){return new Promise((e,t)=>{let n=this.indexedDB.open(sv,1);n.onupgradeneeded=()=>sS(n),n.onsuccess=()=>{let r=n.result,a=r.transaction(sN,"readonly"),s=a.objectStore(sN).getAll();s.onsuccess=()=>{let t={};for(let e of s.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},s.onerror=e=>(r.close(),t(s.error)),a.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)})}async removeModel(e){var t;return e=(t=e).startsWith(sC.URL_SCHEME)?t.slice(sC.URL_SCHEME.length):t,new Promise((t,n)=>{let r=this.indexedDB.open(sv,1);r.onupgradeneeded=()=>sS(r),r.onsuccess=()=>{let a,s=r.result,i=s.transaction(sN,"readwrite"),o=i.objectStore(sN),l=o.get(e);l.onsuccess=()=>{if(null==l.result)return s.close(),n(Error(`Cannot find model with path '${e}' in IndexedDB.`));{let r=o.delete(e),i=()=>{let r=(a=s.transaction(sk,"readwrite")).objectStore(sk).delete(e);r.onsuccess=()=>t(l.result.modelArtifactsInfo),r.onerror=e=>n(l.error)};r.onsuccess=i,r.onerror=e=>(i(),s.close(),n(l.error))}},l.onerror=e=>(s.close(),n(l.error)),i.oncomplete=()=>{null==a?s.close():a.oncomplete=()=>s.close()}},r.onerror=e=>n(r.error)})}})}catch(e){}}function sW(e,t="float32",n){return t=t||"float32",tO(e),new aT(e,t,n)}tU.get("IS_NODE")&&!tU.get("IS_BROWSER")&&tU.setPlatform("node",new class{constructor(){this.util={},this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=tU.global.fetch?tU.global.fetch(e,t):(null==r&&(r={}),r(e,t))}now(){let e=X.default.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}});let sU=a4({cast_:function(e,t){let n=a1(e,"x","cast");if(!tb(t))throw Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw Error("Only strings can be casted to strings");return aH.runKernel(ne,{x:n},{dtype:t})}}),sj=a4({clone_:function(e){let t=a1(e,"x","clone","string_or_numeric");return aH.runKernel(nW,{x:t})}});function sV(e,t=!1){console.log(e.toString(t))}aG(),aE={buffer:sW,cast:sU,clone:sj,print:sV};let sG=a4({add_:function(e,t){let n=a1(e,"a","add"),r=a1(t,"b","add");[n,r]=az(n,r);let a={a:n,b:r};return aH.runKernel("Add",a)}}),sH=a4({floorDiv_:function(e,t){let n=a1(e,"a","floorDiv"),r=a1(t,"b","floorDiv");[n,r]=az(n,r);let a={a:n,b:r};return aH.runKernel(nO,a)}}),sq=a4({div_:function(e,t){let n=a1(e,"a","div"),r=a1(t,"b","div");if([n,r]=az(n,r),"int32"===n.dtype&&"int32"===r.dtype)return sH(n,r);let a={a:n,b:r};return aH.runKernel(nC,a,{})}}),sK=a4({mul_:function(e,t){let n=a1(e,"a","mul"),r=a1(t,"b","mul");[n,r]=az(n,r);let a={a:n,b:r};return aH.runKernel(rn,a)}}),sX=a4({sqrt_:function(e){let t=a1(e,"x","sqrt","float32");return aH.runKernel(rP,{x:t})}}),sY=a4({square_:function(e){let t=a1(e,"x","square");return aH.runKernel("Square",{x:t},{})}}),sZ=a4({zerosLike_:function(e){let t=a1(e,"x","zerosLike");return aH.runKernel(r9,{x:t})}});function sJ(e){return aH.customGrad(e)}function sQ(e,t){if((aw(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&aw(e)&&!(e instanceof Uint8Array))throw Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return a6(e,[],[],t)}let s0=new Map,s1=new Map;class s2{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class s3{constructor(){this.classNameMap={}}static getMap(){return null==s3.instance&&(s3.instance=new s3),s3.instance}static register(e){s3.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function s4(e,t,n){te(null!=e.className,()=>"Class being registered does not have the static className property defined."),te("string"==typeof e.className,()=>"className is required to be a string, but got type "+typeof e.className),te(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),void 0===t&&(t="Custom"),void 0===n&&(n=e.className);let r=t+">"+n;return s3.register(e),s0.set(r,e),s1.set(e,r),e}function s5(e){return s1.has(e)?s1.get(e):e.className}e.s(["Serializable",()=>s2,"SerializationMap",()=>s3,"getRegisteredName",()=>s5,"registerClass",()=>s4],4976);class s6 extends s2{minimize(e,t=!1,n){let{value:r,grads:a}=this.computeGradients(e,n);if(null!=n){let e=n.map(e=>({name:e.name,tensor:a[e.name]}));this.applyGradients(e)}else this.applyGradients(a);return(sn(a),t)?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return function(e,t){te(tT(e),()=>"The f passed in variableGrads(f) must be a function"),te(null==t||Array.isArray(t)&&t.every(e=>e instanceof aF),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let n=null!=t;if(!n)for(let e in t=[],aH.registeredVariables)t.push(aH.registeredVariables[e]);let r=n?t.filter(e=>!e.trainable):null,a=t.length;te((t=t.filter(e=>e.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${a} variables is trainable.`);let{value:s,grads:i}=aH.gradients(e,t,null,!0);te(i.some(e=>null!=e),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),te(0===s.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${s.rank} tensor`);let o={};return t.forEach((e,t)=>{null!=i[t]&&(o[e.name]=i[t])}),null!=r&&r.forEach(e=>o[e.name]=null),{value:s,grads:o}}(e,t)}dispose(){null!=this.iterations_&&sn(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:sQ(this.iterations_,"int32")}}async getWeights(){throw Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(s6,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});class s8 extends s6{static get className(){return"Adadelta"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=aH.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{let r=aH.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:st(()=>sZ(r).variable(!1))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:st(()=>sZ(r).variable(!1))});let a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;let s=this.accumulatedGrads[n].variable,i=this.accumulatedUpdates[n].variable;st(()=>{let e=sG(sK(s,this.rho),sK(sY(a),1-this.rho)),t=sK(sq(sX(sG(i,this.epsilon)),sX(sG(s,this.epsilon))),a),n=sG(sK(i,this.rho),sK(sY(t),1-this.rho));s.assign(e),i.assign(n);let o=sG(sK(t,-this.learningRate),r);r.assign(o)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(sn(this.accumulatedGrads.map(e=>e.variable)),sn(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){let t=(e=await this.extractIterations(e)).length/2;this.accumulatedGrads=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.accumulatedUpdates=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}function s7(e,t,n){tO(e),n=n||tC(t);let r={shape:e,value:t,dtype:n};return aH.runKernel(nF,{},r)}class s9 extends s6{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{let r=aH.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:st(()=>s7(r.shape,this.initialAccumulatorValue).variable(!1))});let a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;let s=this.accumulatedGrads[n].variable;st(()=>{let e=sG(s,sY(a));s.assign(e);let t=sG(sK(sq(a,sX(sG(e,aH.backend.epsilon()))),-this.learningRate),r);r.assign(t)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&sn(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),this.accumulatedGrads=e.map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}let ie=a4({pow_:function(e,t){let n=a1(e,"base","pow"),r=a1(t,"exp","pow");[n,r]=az(n,r);let a={a:n,b:r};return aH.runKernel("Pow",a)}}),it=a4({sub_:function(e,t){let n=a1(e,"a","sub"),r=a1(t,"b","sub");[n,r]=az(n,r);let a={a:n,b:r};return aH.runKernel("Sub",a)}});class ir extends s6{static get className(){return"Adam"}constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],st(()=>{this.accBeta1=sQ(t).variable(),this.accBeta2=sQ(n).variable()}),null==r&&(this.epsilon=aH.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);st(()=>{let n=it(1,this.accBeta1),r=it(1,this.accBeta2);t.forEach((t,a)=>{let s=aH.registeredVariables[t];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:st(()=>sZ(s).variable(!1))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:`${t}/v`,variable:st(()=>sZ(s).variable(!1))});let i=Array.isArray(e)?e[a].tensor:e[t];if(null==i)return;let o=this.accumulatedFirstMoment[a].variable,l=this.accumulatedSecondMoment[a].variable,u=sG(sK(o,this.beta1),sK(i,1-this.beta1)),h=sG(sK(l,this.beta2),sK(sY(i),1-this.beta2)),p=sq(u,n),d=sq(h,r);o.assign(u),l.assign(h);let c=sG(sK(sq(p,sG(sX(d),this.epsilon)),-this.learningRate),s);s.assign(c)}),this.accBeta1.assign(sK(this.accBeta1,this.beta1)),this.accBeta2.assign(sK(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&sn(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedSecondMoment&&sn(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),st(()=>{this.accBeta1.assign(ie(this.beta1,this.iterations_+1)),this.accBeta2.assign(ie(this.beta2,this.iterations_+1))});let t=e.length/2;this.accumulatedFirstMoment=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.accumulatedSecondMoment=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}let ia=a4({abs_:function(e){let t=a1(e,"x","abs");return"complex64"===t.dtype?aH.runKernel(na,{x:t}):aH.runKernel("Abs",{x:t})}});function is(e,t){let n=e.length,r=[];for(let a=0;a<n;a++){let s=n-1-a,i=e[s]||1;(t[t.length-1-a]||1)>1&&1===i&&r.unshift(s)}return r}function ii(e,t){let n=[];for(let r=0;r<t.length;r++){let a=e[e.length-r-1],s=t.length-r-1,i=t[s];(null==a||1===a&&i>1)&&n.unshift(s)}return n}function io(e,t){let n=Math.max(e.length,t.length),r=Array(n);for(let a=0;a<n;a++){let s=e[e.length-a-1];null==s&&(s=1);let i=t[t.length-a-1];if(null==i&&(i=1),1===s)r[n-a-1]=i;else if(1===i)r[n-a-1]=s;else if(s!==i)throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`);else r[n-a-1]=s}return r}e.s(["assertAndGetBroadcastShape",()=>io,"getBroadcastDims",()=>is,"getReductionAxes",()=>ii],25663);let il=a4({maximum_:function(e,t){let n=a1(e,"a","maximum"),r=a1(t,"b","maximum");[n,r]=az(n,r),"bool"===n.dtype&&(n=sU(n,"int32"),r=sU(r,"int32")),io(n.shape,r.shape);let a={a:n,b:r};return aH.runKernel(n2,a)}});class iu extends s6{static get className(){return"Adamax"}constructor(e,t,n,r=null,a=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],st(()=>{this.iteration=sQ(0).variable(),this.accBeta1=sQ(t).variable()}),null==r&&(this.epsilon=aH.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);st(()=>{let n=it(1,this.accBeta1),r=sq(-this.learningRate,sG(sK(this.iteration,this.decay),1));t.forEach((t,a)=>{let s=aH.registeredVariables[t];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:sZ(s).variable(!1)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:`${t}/v`,variable:sZ(s).variable(!1)});let i=Array.isArray(e)?e[a].tensor:e[t];if(null==i)return;let o=this.accumulatedFirstMoment[a].variable,l=this.accumulatedWeightedInfNorm[a].variable,u=sG(sK(o,this.beta1),sK(i,1-this.beta1)),h=il(sK(l,this.beta2),ia(i));o.assign(u),l.assign(h);let p=sG(sK(sq(r,n),sq(u,sG(h,this.epsilon))),s);s.assign(p)}),this.iteration.assign(sG(this.iteration,1)),this.accBeta1.assign(sK(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&sn(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedWeightedInfNorm&&sn(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class ih extends s6{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{let r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;let a=aH.registeredVariables[t];st(()=>{let e=sG(sK(this.c,r),a);a.assign(e)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=sr(sQ(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class ip extends ih{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=sQ(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{let r=aH.registeredVariables[t];null==this.accumulations[n]&&(this.accumulations[n]={originalName:`${t}/momentum`,variable:st(()=>sZ(r).variable(!1))});let a=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];null!=s&&st(()=>{let e,t=sG(sK(this.m,a),s);e=this.useNesterov?sG(sK(this.c,sG(s,sK(t,this.m))),r):sG(sK(this.c,t),r),a.assign(t),r.assign(e)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&sn(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),this.accumulations=e.map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class id extends s6{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,r=null,a=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==r&&(this.epsilon=aH.backend.epsilon()),null==e)throw Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{let r=aH.registeredVariables[t];null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:st(()=>sZ(r).variable(!1))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:st(()=>sZ(r).variable(!1))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:st(()=>sZ(r).variable(!1))});let a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;let s=this.accumulatedMeanSquares[n].variable,i=this.accumulatedMoments[n].variable;st(()=>{let e=sG(sK(s,this.decay),sK(sY(a),1-this.decay));if(this.centered){let t=this.accumulatedMeanGrads[n].variable,o=sG(sK(t,this.decay),sK(a,1-this.decay)),l=sq(sK(a,this.learningRate),sX(it(e,sG(sY(o),this.epsilon)))),u=sG(sK(i,this.momentum),l);s.assign(e),t.assign(o),i.assign(u);let h=it(r,u);r.assign(h)}else{let e=sG(sK(s,this.decay),sK(sY(a),1-this.decay)),t=sG(sK(i,this.momentum),sq(sK(a,this.learningRate),sX(sG(e,this.epsilon))));s.assign(e),i.assign(t);let n=it(r,t);r.assign(n)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&sn(this.accumulatedMeanSquares.map(e=>e.variable)),null!=this.accumulatedMeanGrads&&this.centered&&sn(this.accumulatedMeanGrads.map(e=>e.variable)),null!=this.accumulatedMoments&&sn(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2;this.accumulatedMeanSquares=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.accumulatedMoments=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}for(let e of[s8,s9,ir,iu,ip,id,ih])s4(e);let ic=a4({step_:function(e,t=0){let n=a1(e,"x","step");return aH.runKernel(ae,{x:n},{alpha:t})}}),im={kernelName:"Abs",inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sK(e,ic(sU(n,"float32"),-1))}}},ig=a4({neg_:function(e){let t=a1(e,"x","neg");return aH.runKernel("Neg",{x:t})}}),iy=a4({reshape_:function(e,t){let n=a1(e,"x","reshape","string_or_numeric");return aH.runKernel(rw,{x:n},{shape:t})}}),ix=a4({sum_:function(e,t=null,n=!1){let r=a1(e,"x","sum");"bool"===r.dtype&&(r=sU(r,"int32"));let a={x:r};return aH.runKernel("Sum",a,{axis:t,keepDims:n})}});function ib(e,t,n,r,a="NHWC",s){let i=[...t,e[3]];return ik(e,i,n,s,r,null,null,iF(a))}function iw(e,t,n,r,a,s,i="channelsLast"){let o,[l,u]=iS(t);if("channelsLast"===i)o=[l,u,e[3],e[3]];else if("channelsFirst"===i)o=[l,u,e[1],e[1]];else throw Error(`Unknown dataFormat ${i}`);return ik(e,o,n,r,a,s,!1,i)}function iv(e,t,n,r,a,s,i="NDHWC"){let o,l,[u,h,p]=iC(t);if("NDHWC"===i)l="channelsLast",o=[u,h,p,e[4],e[4]];else if("NCDHW"===i)l="channelsFirst",o=[u,h,p,e[1],e[1]];else throw Error(`Unknown dataFormat ${i}`);return iN(e,o,n,r,a,!1,l,s)}function ik(e,t,n,r,a,s,i=!1,o="channelsLast"){let l,[u,h,p,d]=[-1,-1,-1,-1];if("channelsLast"===o)[u,h,p,d]=e;else if("channelsFirst"===o)[u,d,h,p]=e;else throw Error(`Unknown dataFormat ${o}`);let[c,f,,m]=t,[g,y]=iS(n),[x,b]=iS(r),w=iT(c,x),v=iT(f,b),{padInfo:k,outHeight:N,outWidth:I}=function(e,t,n,r,a,s,i,o,l){let u,h,p;if("number"==typeof e){var d,c;let a,i,l=0===e?"VALID":"NUMBER";u={top:e,bottom:e,left:e,right:e,type:l};let f=(d=[t,n],null==(c=e)&&(c=iI(d,s,r)),a=d[0],i=d[1],[i$((a-s+2*c)/r+1,o),i$((i-s+2*c)/r+1,o)]);h=f[0],p=f[1]}else if("same"===e){let e=Math.max(0,((h=Math.ceil(t/r))-1)*r+s-t),o=Math.max(0,((p=Math.ceil(n/a))-1)*a+i-n),l=Math.floor(e/2),d=Math.floor(o/2);u={top:l,bottom:e-l,left:d,right:o-d,type:"SAME"}}else if("valid"===e)u={top:0,bottom:0,left:0,right:0,type:"VALID"},h=Math.ceil((t-s+1)/r),p=Math.ceil((n-i+1)/a);else if("object"==typeof e){let d="channelsLast"===l?e[1][0]:e[2][0],c="channelsLast"===l?e[1][1]:e[2][1],f="channelsLast"===l?e[2][0]:e[3][0],m="channelsLast"===l?e[2][1]:e[3][1];u={top:d,bottom:c,left:f,right:m,type:0===d&&0===c&&0===f&&0===m?"VALID":"EXPLICIT"},h=i$((t-s+d+c)/r+1,o),p=i$((n-i+f+m)/a+1,o)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:u,outHeight:h,outWidth:p}}(a,h,p,g,y,w,v,s,o),S=i?m*d:m;return"channelsFirst"===o?l=[u,S,N,I]:"channelsLast"===o&&(l=[u,N,I,S]),{batchSize:u,dataFormat:o,inHeight:h,inWidth:p,inChannels:d,outHeight:N,outWidth:I,outChannels:S,padInfo:k,strideHeight:g,strideWidth:y,filterHeight:c,filterWidth:f,effectiveFilterHeight:w,effectiveFilterWidth:v,dilationHeight:x,dilationWidth:b,inShape:e,outShape:l,filterShape:t}}function iN(e,t,n,r,a,s=!1,i="channelsLast",o){let l,[u,h,p,d,c]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[u,h,p,d,c]=e;else if("channelsFirst"===i)[u,c,h,p,d]=e;else throw Error(`Unknown dataFormat ${i}`);let[f,m,g,,y]=t,[x,b,w]=iC(n),[v,k,N]=iC(r),I=iT(f,v),S=iT(m,k),C=iT(g,N),{padInfo:T,outDepth:$,outHeight:E,outWidth:A}=function(e,t,n,r,a,s,i,o,l,u,h){let p,d,c,f;if("valid"===e&&(e=0),"number"==typeof e){let m=0===e?"VALID":"NUMBER";p={top:e,bottom:e,left:e,right:e,front:e,back:e,type:m};let g=function(e,t,n,r,a,s){null==a&&(a=iI(e,t[0],r[0]));let i=[0,0,0,1];for(let n=0;n<3;n++)e[n]+2*a>=t[n]&&(i[n]=i$((e[n]-t[n]+2*a)/r[n]+1,s));return i}([t,n,r,1],[o,l,u],0,[a,s,i],e,h);d=g[0],c=g[1],f=g[2]}else if("same"===e){let e=((d=Math.ceil(t/a))-1)*a+o-t,h=((c=Math.ceil(n/s))-1)*s+l-n,m=((f=Math.ceil(r/i))-1)*i+u-r,g=Math.floor(e/2),y=Math.floor(h/2),x=Math.floor(m/2);p={top:y,bottom:h-y,left:x,right:m-x,front:g,back:e-g,type:"SAME"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:p,outDepth:d,outHeight:c,outWidth:f}}(a,h,p,d,x,b,w,I,S,C,o),R=s?y*c:y;return"channelsFirst"===i?l=[u,R,$,E,A]:"channelsLast"===i&&(l=[u,$,E,A,R]),{batchSize:u,dataFormat:i,inDepth:h,inHeight:p,inWidth:d,inChannels:c,outDepth:$,outHeight:E,outWidth:A,outChannels:R,padInfo:T,strideDepth:x,strideHeight:b,strideWidth:w,filterDepth:f,filterHeight:m,filterWidth:g,effectiveFilterDepth:I,effectiveFilterHeight:S,effectiveFilterWidth:C,dilationDepth:v,dilationHeight:k,dilationWidth:N,inShape:e,outShape:l,filterShape:t}}function iI(e,t,n,r=1){let a=iT(t,r);return Math.floor((e[0]*(n-1)-n+a)/2)}function iS(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function iC(e){return"number"==typeof e?[e,e,e]:e}function iT(e,t){return t<=1?e:e+(e-1)*(t-1)}function i$(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw Error(`Unknown roundingMode ${t}`)}}function iE(e){let[t,n,r]=iS(e);return 1===t&&1===n&&1===r}function iA(e,t){return iE(e)||iE(t)}function iR(e){return iS(e).every(e=>e>0)}function iF(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw Error(`Unknown dataFormat ${e}`)}function i_(e,t,n){if(null!=n)if("string"==typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if("number"==typeof t)te(to(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if("object"==typeof t)t.forEach(t=>{t.forEach(t=>{te(to(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}e.s(["checkPadOnDimRoundingMode",()=>i_,"computeConv2DInfo",()=>ik,"computeConv3DInfo",()=>iN,"computeDefaultPad",()=>iI,"computeDilation2DInfo",()=>ib,"computePool2DInfo",()=>iw,"computePool3DInfo",()=>iv,"convertConv2DDataFormat",()=>iF,"eitherStridesOrDilationsAreOne",()=>iA,"stridesOrDilationsArePositive",()=>iR,"tupleValuesAreOne",()=>iE],68523);let iD=a4({avgPool3dGrad_:function(e,t,n,r,a,s){let i=a1(e,"dy","avgPool3dGrad"),o=a1(t,"input","avgPool3dGrad"),l=i,u=o,h=!1;4===o.rank&&(h=!0,l=iy(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=iy(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),te(5===l.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),te(5===u.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),i_("avgPool3dGrad",a,s);let p={dy:l,input:u},d=aH.runKernel(t4,p,{filterSize:n,strides:r,pad:a,dimRoundingMode:s});return h?iy(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),iO=a4({avgPoolGrad_:function(e,t,n,r,a){let s=a1(e,"dy","avgPoolGrad"),i=a1(t,"input","avgPoolGrad");te(i.rank===s.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`);let o=i,l=s,u=!1;3===i.rank&&(u=!0,o=iy(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=iy(s,[1,s.shape[0],s.shape[1],s.shape[2]])),te(4===l.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),te(4===o.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);let h={dy:l,input:o},p=aH.runKernel(t2,h,{filterSize:n,strides:r,pad:a});return u?iy(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),iM=a4({matMul_:function(e,t,n=!1,r=!1){let a=a1(e,"a","matMul"),s=a1(t,"b","matMul");[a,s]=az(a,s);let i={a:a,b:s};return aH.runKernel(t5,i,{transposeA:n,transposeB:r})}}),iL=a4({spaceToBatchND_:function(e,t,n){let r=a1(e,"x","spaceToBatchND");return te(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),te(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),te(r.shape.reduce((e,r,a)=>a>0&&a<=t.length?e&&(r+n[a-1][0]+n[a-1][1])%t[a-1]==0:e,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`),aH.runKernel(rB,{x:r},{blockShape:t,paddings:n})}}),iz=a4({greaterEqual_:function(e,t){let n=a1(e,"a","greaterEqual","string_or_numeric"),r=a1(t,"b","greaterEqual","string_or_numeric");[n,r]=az(n,r),io(n.shape,r.shape);let a={a:n,b:r};return aH.runKernel(nB,a)}}),iP=a4({lessEqual_:function(e,t){let n=a1(e,"a","lessEqual","string_or_numeric"),r=a1(t,"b","lessEqual","string_or_numeric");[n,r]=az(n,r),io(n.shape,r.shape);let a={a:n,b:r};return aH.runKernel(nX,a)}}),iB=a4({logicalAnd_:function(e,t){let n=a1(e,"a","logicalAnd","bool"),r=a1(t,"b","logicalAnd","bool");return io(n.shape,r.shape),aH.runKernel(nJ,{a:n,b:r})}}),iW=a4({broadcastTo_:function(e,t){let n=a1(e,"broadcastTo","x"),r=n.shape;if(tO(t),t.length<n.rank)throw Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=iy(n,e)}let a=n.shape,s=Array.from(t);for(let e=t.length-1;e>=0;e--)if(a[e]===t[e])s[e]=1;else if(1!==n.shape[e])throw Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(0===s.map((e,t)=>e>1?t:-1).filter(e=>e>=0).length)return sj(n);let i={x:n};return aH.runKernel(r2,i,{reps:s})}}),iU=a4({where_:function(e,t,n){let r=a1(t,"a","where"),a=a1(n,"b","where"),s=a1(e,"condition","where","bool"),i=io(io(s.shape,r.shape),a.shape),o=iW(s,i),l=iW(r,i),u=iW(a,i);return aH.runKernel(rF,{condition:o,t:l,e:u})}}),ij={kernelName:na,inputsToSave:["x"],gradFunc:im.gradFunc},iV=a4({split_:function(e,t,n=0){let r=a1(e,"x","split");return aH.runKernel(rW,{x:r},{numOrSizeSplits:t,axis:n})}}),iG=a4({conv2DBackpropFilter_:function(e,t,n,r,a,s="NHWC",i){let o=e;3===e.rank&&(o=iy(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=iy(t,[1,t.shape[0],t.shape[1],t.shape[2]])),te(4===o.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),te(4===l.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),te(4===n.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);let u="NHWC"===s?o.shape[3]:o.shape[1],h="NHWC"===s?l.shape[3]:l.shape[1];te(u===n[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`),te(h===n[3],()=>`Error in conv2dDerFilter: depth of dy (${h}) must match output depth for filter (${n[3]}).`),i_("conv2dDerFilter",a,i);let p={x:o,dy:l};return aH.runKernel(no,p,{strides:r,pad:a,dataFormat:s,dimRoundingMode:i,filterShape:n})}}),iH=a4({conv2DBackpropInput_:function(e,t,n,r,a,s="NHWC",i){te(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,l=t,u=!1;3===t.rank&&(u=!0,l=iy(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),te(4===o.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),te(4===l.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),te(4===n.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);let h="NHWC"===s?o[3]:o[1],p="NHWC"===s?l.shape[3]:l.shape[1];te(h===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${h}) must match input depth for filter ${n.shape[2]}.`),te(p===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${n.shape[3]}.`),i_("conv2dDerInput",a,i);let d={dy:l,filter:n},c={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,inputShape:o},f=aH.runKernel(nl,d,c);return u?iy(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),iq=a4({conv2d_:function(e,t,n,r,a="NHWC",s=[1,1],i){let o=a1(e,"x","conv2d","float32"),l=a1(t,"filter","conv2d","float32"),u=o,h=!1;3===o.rank&&(h=!0,u=iy(o,[1,o.shape[0],o.shape[1],o.shape[2]])),te(4===u.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),te(4===l.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),i_("conv2d",r,i);let p="NHWC"===a?u.shape[3]:u.shape[1];te(p===l.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${l.shape[2]}.`),te(iA(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),te(iR(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),te(iR(n),()=>"Error in conv2D: Strides should be larger than 0.");let d={x:u,filter:l},c=aH.runKernel(ni,d,{strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i});return h?iy(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),iK=a4({conv3DBackpropFilter_:function(e,t,n,r,a){let s=e;4===e.rank&&(s=iy(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;4===i.rank&&(i=iy(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),te(5===s.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),te(5===i.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),te(5===n.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),te(s.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`),te(i.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`);let o={x:s,dy:i};return aH.runKernel(nh,o,{strides:r,pad:a,filterShape:n})}}),iX=a4({conv3DBackpropInput_:function(e,t,n,r,a){te(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let s=e,i=t,o=!1;4===t.rank&&(o=!0,i=iy(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);let l=s[4],u=i.shape[4];te(5===s.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),te(5===i.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),te(5===n.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),te(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),te(u===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`);let h={dy:i,filter:n},p={pad:a,strides:r,inputShape:s},d=aH.runKernel(np,h,p);return o?iy(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),iY=a4({sin_:function(e){let t=a1(e,"x","sin","float32");return aH.runKernel("Sin",{x:t})}}),iZ=a4({sinh_:function(e){let t=a1(e,"x","sinh");return aH.runKernel(rO,{x:t})}});function iJ(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function iQ(e,t,n){let r=e.length+t.length,a=[],s=0,i=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?a.push(e[s++]):a.push(t[i++]);return a}function i0(e,t){let n=[],r=e.length;for(let a=0;a<r;a++)-1===t.indexOf(a)&&n.push(e[a]);return[n,t.map(t=>e[t])]}function i1(e,t){return iQ(e,t.map(e=>1),t)}function i2(e,t,n){te(iJ(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function i3(e,t){if(iJ(e,t))return null;let n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach(e=>n.push(e)),n}function i4(e){return e.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function i5(e,t){let n=[];for(let r=t-e;r<t;++r)n.push(r);return n}e.s(["assertAxesAreInnerMostDims",()=>i2,"axesAreInnerMostDims",()=>iJ,"combineLocations",()=>iQ,"computeOutAndReduceShapes",()=>i0,"expandShapeToKeepDim",()=>i1,"getAxesPermutation",()=>i3,"getInnerMostAxes",()=>i5,"getUndoAxesPermutation",()=>i4],56016);let i6=a4({cumsum_:function(e,t=0,n=!1,r=!1){let a=a1(e,"x","cumsum");return aH.runKernel(nf,{x:a},{axis:t,exclusive:n,reverse:r})}}),i8=a4({imag_:function(e){let t=a1(e,"input","imag");return aH.runKernel(nj,{input:t})}}),i7=a4({real_:function(e){let t=a1(e,"input","real");return aH.runKernel(ry,{input:t})}}),i9=a4({transpose_:function(e,t,n){let r=a1(e,"x","transpose");if(null==t&&(t=r.shape.map((e,t)=>t).reverse()),te(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(e=>{te(e>=0&&e<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`)}),r.rank<=1)return r.clone();let a={perm:t};return"complex64"===r.dtype?st(()=>{let e=i7(r),t=i8(r);return e=aH.runKernel(r5,{x:e},a),t=aH.runKernel(r5,{x:t},a),n&&(t=ig(t)),a5(e,t)}):aH.runKernel(r5,{x:r},a)}});e.s(["transpose",0,i9],33212);let oe=a4({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,r,a,s=[1,1],i){let o=e;3===e.rank&&(o=iy(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=iy(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={x:o,dy:l};return aH.runKernel(nb,u,{strides:r,pad:a,dimRoundingMode:i,dilations:s,filterShape:n})}}),ot=a4({depthwiseConv2dNativeBackpropInput_:function(e,t,n,r,a,s=[1,1],i){let o=t,l=!1;3===t.rank&&(l=!0,o=iy(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={dy:o,filter:n},h=aH.runKernel(nw,u,{strides:r,pad:a,dimRoundingMode:i,dilations:s,inputShape:e});return l?iy(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),on=a4({exp_:function(e){let t=a1(e,"x","exp");return aH.runKernel("Exp",{x:t})}}),or=a4({rsqrt_:function(e){let t=a1(e,"x","rsqrt","float32");return aH.runKernel(r$,{x:t})}}),oa=a4({tile_:function(e,t){let n=a1(e,"x","tile","string_or_numeric");return te(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`),aH.runKernel(r2,{x:n},{reps:t})}}),os=a4({stack_:function(e,t=0){let n=a2(e,"tensors","stack","string_or_numeric");return te(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&te(t<=n[0].rank,()=>"Axis must be <= rank of the tensor"),aH.runKernel(ru,n,{axis:t})}}),oi=a4({unsortedSegmentSum_:function(e,t,n){let r=a1(e,"x","unsortedSegmentSum"),a=a1(t,"segmentIds","unsortedSegmentSum","int32");return te(to(n),()=>"numSegments must be of dtype int"),aH.runKernel(r7,{x:r,segmentIds:a},{numSegments:n})}});function oo(e,t){let n=[];for(let r=e;r<t;++r)n.push(r);return n}function ol(e){let t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}let ou=a4({greater_:function(e,t){let n=a1(e,"a","greater","string_or_numeric"),r=a1(t,"b","greater","string_or_numeric");[n,r]=az(n,r),io(n.shape,r.shape);let a={a:n,b:r};return aH.runKernel(nP,a)}}),oh=a4({localResponseNormalizationBackprop_:function(e,t,n,r=5,a=1,s=1,i=.5){return aH.runKernel(n1,{x:e,y:t,dy:n},{depthRadius:r,bias:a,alpha:s,beta:i})}}),op=a4({equal_:function(e,t){let n=a1(e,"a","equal","string_or_numeric"),r=a1(t,"b","equal","string_or_numeric");[n,r]=az(n,r),io(n.shape,r.shape);let a={a:n,b:r};return aH.runKernel(nE,a)}});function od(e,t,n,r){return t.rank<n.rank&&(t=iy(t,i1(t.shape,r))),e.rank<n.rank&&(e=iy(e,i1(e.shape,r))),{x:()=>sK(e,sU(op(n,t),e.dtype))}}let oc={kernelName:"Max",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let{reductionIndices:r}=n,a=t[0],s=t[1],i=tf(r,a.shape),o=od(e,s,a,i);return{x:()=>o.x()}}},of=a4({less_:function(e,t){let n=a1(e,"a","less","string_or_numeric"),r=a1(t,"b","less","string_or_numeric");[n,r]=az(n,r),io(n.shape,r.shape);let a={a:n,b:r};return aH.runKernel(nK,a)}}),om=a4({maxPool3dGrad_:function(e,t,n,r,a,s,i){let o=a1(e,"dy","maxPool3dGrad"),l=a1(t,"input","maxPool3dGrad"),u=a1(n,"output","maxPool3dGrad"),h=o,p=l,d=u,c=!1;4===l.rank&&(c=!0,h=iy(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),p=iy(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=iy(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),te(5===h.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${h.rank}.`),te(5===p.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),te(5===d.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),i_("maxPool3dGrad",s,i);let f={dy:h,input:p,output:d},m=aH.runKernel(n6,f,{filterSize:r,strides:a,pad:s,dimRoundingMode:i});return c?iy(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),og=a4({maxPoolGrad_:function(e,t,n,r,a,s,i){let o=a1(e,"dy","maxPoolGrad"),l=a1(t,"input","maxPoolGrad"),u=a1(n,"output","maxPoolGrad");return te(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),te(4===o.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),te(4===l.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),i_("maxPoolGrad",s,i),aH.runKernel(n4,{dy:o,input:l,output:u},{filterSize:r,strides:a,pad:s,dimRoundingMode:i})}});function oy(e,t="float32"){if(tO(e),"complex64"===t)return a5(oy(e,"float32"),oy(e,"float32"));let n=t_(tr(e),t);return aH.makeTensor(n,e,t)}function ox(e,t="float32"){if(tO(e),"complex64"===t)return a5(ox(e,"float32"),oy(e,"float32"));let n=tF(tr(e),t);return aH.makeTensor(n,e,t)}let ob=a4({slice_:function(e,t,n){let r=a1(e,"x","slice","string_or_numeric");if(0===r.rank)throw Error("Slicing scalar is not possible");return aH.runKernel(rD,{x:r},{begin:t,size:n})}}),ow=a4({floor_:function(e){let t=a1(e,"x","floor","float32");return aH.runKernel(nD,{x:t})}}),ov=a4({unstack_:function(e,t=0){let n=a1(e,"x","unstack","string_or_numeric");return te(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`),aH.runKernel(r8,{value:n},{axis:t})}}),ok={kernelName:rh,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,s=a.map(e=>e[0]);return{x:()=>ob(e,s,r.shape)}}},oN=a4({log_:function(e){let t=a1(e,"x","log","float32");return aH.runKernel("Log",{x:t})}});function oI(e,t,n){let r=e.shape.length;te(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),te(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let a=0;a<r;++a)te(t[a]+n[a]<=e.shape[a],()=>`Error in slice${r}D: begin[${a}] + size[${a}] (${t[a]+n[a]}) would overflow input.shape[${a}] (${e.shape[a]})`)}function oS(e){let t=[],n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function oC(e,t,n){let r=[];for(let a=0;a<e.length;a++)r[a]=Math.ceil((t[a]-e[a])/n[a]);return r}function oT(e,t,n,r){let a=[...e];for(let e=a.length;e<r.length;e++)a.push(1);for(let e=0;e<n;e++)0===e?a[t]=1:(a.splice(t,0,1),a.pop());return a}function o$(e,t){let n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function oE(e,t,n,r,a,s,i,o,l){let u=e.length,h=Array(u),p=Array(u),d=Array(u);if(t.length&&n>0){let l=t[0],u=n+1;h=oA(i,l,u,r,e),p=oR(o,l,u,a,e),d=oT(s,l,u,e)}else for(let t=0;t<u;t++)h[t]=o_(i,r,s,e,t,l),p[t]=oD(o,a,s,e,t,l),d[t]=oF(s,t,l);return{begin:h,end:p,strides:d}}function oA(e,t,n,r,a){let s=[...a],i=o$(n,t);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=0;else{var o,l,u;let i=(o=t,l=n,(u=a)<=o?u:u-(l-1)),h=r[i];e&1<<i&&(h=0),s[a]=h}return s}function oR(e,t,n,r,a){let s=[...a],i=o$(n,t);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=Number.MAX_SAFE_INTEGER;else{var o,l,u;let i=(o=t,l=n,(u=a)<=o?u:u-(l-1)),h=r[i];e&1<<i&&(h=Number.MAX_SAFE_INTEGER),s[a]=h}for(let e=0;e<s.length;e++){let t=a[e];s[e]<0&&(s[e]+=t),s[e]=e4(0,s[e],a[e])}return s}function oF(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function o_(e,t,n,r,a,s){let i=t[a],o=n[a]||1;(e&1<<a||s&1<<a||null==i)&&(i=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);let l=r[a];return i<0&&(i+=l),i=e4(0,i,l-1)}function oD(e,t,n,r,a,s){let i=t[a],o=n[a]||1;(e&1<<a||s&1<<a||null==i)&&(i=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);let l=r[a];return i<0&&(i+=l),i=o>0?e4(0,i,l):e4(-1,i,l-1)}function oO(e,t,n){let r=n.length;for(let e=0;e<n.length;e++)if(n[e]>1){r=e;break}for(let a=r+1;a<n.length;a++)if(t[a]>0||n[a]!==e[a])return!1;return!0}function oM(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function oL(e,t,n){let r,a,s=e.shape.length;return(r="number"==typeof t?[t,...Array(s-1).fill(0)]:t.length<s?t.concat(Array(s-t.length).fill(0)):t.slice()).forEach(e=>{te(-1!==e,()=>"slice() does not support negative begin indexing.")}),a=(a=null==n?Array(s).fill(-1):"number"==typeof n?[n,...Array(s-1).fill(-1)]:n.length<s?n.concat(Array(s-n.length).fill(-1)):n).map((t,n)=>t>=0?t:(te(-1===t,()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`),e.shape[n]-r[n])),[r,a]}function oz(e,t,n,r,a,s,i,o,l){let u;if(null==r?(u=Array(t.length)).fill(1):u=r,null!=i&&(i&i-1)!=0)throw Error("Multiple ellipses in slice is not allowed.");let h=!1,p={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let e=0;e<p.dims;e++)h&&(1<<e&o)!=0&&p.numAddAxisAfterEllipsis++,1<<e&i&&(h=!0);!h&&(p.ellipsisMask|=1<<p.dims,p.dims++);let d={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};var c=p,f=d;f.beginMask=0,f.endMask=0,f.shrinkAxisMask=0;let m=0;f.beginValid=null!=c.begin,f.endValid=null!=c.end,f.begin=Array(f.dims),f.end=Array(f.dims),f.strides=Array(f.dims),f.finalShapeGatherIndices=[],f.finalShapeGatherIndicesSparse=[],f.inputShapeGatherIndicesSparse=Array(f.dims);for(let e=0;e<c.dims;e++)if(1<<e&c.ellipsisMask){let t=Math.min(f.dims-(c.dims-e)+1+c.numAddAxisAfterEllipsis,f.dims);for(;m<t;m++)f.begin[m]=0,f.end[m]=0,f.strides[m]=1,f.beginMask|=1<<m,f.endMask|=1<<m,f.finalShapeGatherIndices.push(m),f.finalShapeGatherIndicesSparse.push(-1),f.inputShapeGatherIndicesSparse[m]=e}else if(1<<e&c.newAxisMask)f.finalShapeGatherIndices.push(-2),f.finalShapeGatherIndicesSparse.push(-1);else{if(m===f.begin.length)throw Error(`Index out of range using input dim ${m}; input has only ${f.dims} dims, ${f.begin.length}.`);null!=c.begin&&(f.begin[m]=c.begin[e]),null!=c.end&&(f.end[m]=c.end[e]),f.strides[m]=c.strides[e],c.beginMask&1<<e&&(f.beginMask|=1<<m),c.endMask&1<<e&&(f.endMask|=1<<m),c.shrinkAxisMask&1<<e?(f.finalShapeGatherIndices.push(-1),f.finalShapeGatherIndicesSparse.push(-1),f.shrinkAxisMask|=1<<m):(f.finalShapeGatherIndices.push(m),f.finalShapeGatherIndicesSparse.push(e)),f.inputShapeGatherIndicesSparse[m]=e,m++}let g=!0,y=!0,x=!0,b=[],w=[];for(let t=0;t<e.length;++t){let n;if(0===d.strides[t])throw Error(`strides[${t}] must be non-zero`);let r=!!(d.shrinkAxisMask&1<<t),a=e[t];if(-1===a){b.push(r?1:-1);continue}let s=[d.beginMask&1<<t,d.endMask&1<<t],i=[d.strides[t]>0?0:-1,d.strides[t]>0?a:a-1];if(r&&d.strides[t]<=0)throw Error("only stride 1 allowed on non-range indexing.");x=x&&1===d.strides[t];let o=!!(d.beginMask&1<<t&&d.endMask&1<<t);if(d.beginValid&&d.endValid){if(r){let e=d.begin[t]<0?a+d.begin[t]:d.begin[t];if(d.begin[t]=e,d.end[t]=d.begin[t]+1,e<0||e>=a)throw Error(`slice index ${d.begin[t]} of dimension ${t} out of bounds.`)}else d.begin[t]=oP(d.begin[t],0,d.strides[t],a,s,i),d.end[t]=oP(d.end[t],1,d.strides[t],a,s,i);let e=1===d.strides[t]&&0===d.begin[t]&&d.end[t]===a;g=g&&e,y=y&&(0===t&&1===d.strides[t]||e)}else g=g&&1===d.strides[t]&&o,y=y&&(0===t&&1===d.strides[t]||o);let l=!1;if(d.beginValid&&d.endValid?(n=d.end[t]-d.begin[t],l=!0):r?(n=1,l=!0):o&&a>=0&&(n=d.strides[t]<0?-a:a,l=!0),l){let e;e=0===n||n<0!=d.strides[t]<0?0:Math.trunc(n/d.strides[t])+ +(n%d.strides[t]!=0),b.push(e)}else b.push(-1)}for(let e=0;e<d.finalShapeGatherIndices.length;++e){let t=d.finalShapeGatherIndices[e];t>=0?w.push(b[t]):-2===t&&w.push(1)}return{finalShapeSparse:w.filter((e,t)=>-2!==d.finalShapeGatherIndices[t]),finalShape:w,isIdentity:g,sliceDim0:y,isSimpleSlice:x,begin:d.begin,end:d.end,strides:d.strides}}function oP(e,t,n,r,a,s){if(a[t])return n>0?s[t]:s[t+1&1];{let t=e<0?r+e:e;return t<s[0]?s[0]:t>s[1]?s[1]:t}}e.s(["assertParamsValid",()=>oI,"computeFlatOffset",()=>oM,"computeOutShape",()=>oC,"getNormalizedAxes",()=>oE,"isSliceContinous",()=>oO,"maskToAxes",()=>oS,"parseSliceParams",()=>oL,"sliceInfo",()=>oz,"startForAxis",()=>o_,"startIndicesWithElidedDims",()=>oA,"stopForAxis",()=>oD,"stopIndicesWithElidedDims",()=>oR,"stridesForAxis",()=>oF,"stridesWithElidedDims",()=>oT],77652);var oB=e.i(77652);function oW(e){return e<=30?e:t$(e,Math.floor(Math.sqrt(e)))}function oU(e,t){let n,r=!1;for(e<=30?(n=e,r=!0):n=t$(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=t$(e,n+1);return n}function oj(e,t,n){let r=[],a=e.length;for(let s=0;s<a;s++)s!==t?r.push(e[s]):r.push(n);return r}function oV(e,t,n,r){let a=t.shape.length,s=e.shape.length;if(0!==r&&(r<-a||r>a))throw Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${r}`);if(r<0&&(r+=a),r>s)throw Error(`batchDims (${r}) must be less than rank(x) (
    ${s}).`);if(n<r)throw Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let n=0;n<r;++n)if(e.shape[n]!==t.shape[n])throw Error(`x.shape[${n}]: ${e.shape[n]} should be equal to indices.shape[${n}]: ${t.shape[n]}.`);let i=e.shape[n],o=[],l=1,u=1,h=1;for(let t=0;t<r;++t)o.push(e.shape[t]),l*=e.shape[t];for(let t=r;t<n;t++)o.push(e.shape[t]),u*=e.shape[t];for(let e=r;e<a;e++)o.push(t.shape[e]);for(let t=n+1;t<s;t++)o.push(e.shape[t]),h*=e.shape[t];return{batchSize:l,sliceSize:h,outerSize:u,dimSize:i,outputShape:o}}e.s(["PARALLELIZE_THRESHOLD",0,30,"computeOptimalWindowSize",()=>oW],27584),e.s(["collectGatherOpShapeInfo",()=>oV,"computeOutShape",()=>oj,"segOpComputeOptimalWindowSize",()=>oU],77427);var oG=e.i(77427);function oH(e){try{return e.map(e=>ab(e))}catch(e){throw Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function oq(e){return e.map(e=>ax(e))}e.s(["fromStringArrayToUint8",()=>oq,"fromUint8ToStringArray",()=>oH],54857),e.i(54857),e.i(56016);var oK=e.i(25663);function oX(e,t){let n=e[0].length;e.forEach((e,t)=>{te(e.length===n,()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`)}),te(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);let r=e[0];e.forEach((e,a)=>{for(let s=0;s<n;s++)te(s===t||e[s]===r[s],()=>`Error in concat${n}D: Shape of tensors[${a}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`)})}function oY(e,t){let n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}e.s(["assertParamsConsistent",()=>oX,"computeOutShape",()=>oY],83523),e.i(83523),e.i(68523);let oZ=a4({elu_:function(e){let t=a1(e,"x","elu","float32");return aH.runKernel("Elu",{x:t})}}),oJ=a4({leakyRelu_:function(e,t=.2){let n=a1(e,"x","leakyRelu");return aH.runKernel(nq,{x:n},{alpha:t})}}),oQ=a4({prelu_:function(e,t){let n=a1(e,"x","prelu"),r=a1(t,"alpha","prelu");return aH.runKernel(rp,{x:n,alpha:r})}}),o0=a4({relu_:function(e){let t=a1(e,"x","relu");return aH.runKernel(rb,{x:t})}}),o1=a4({relu6_:function(e){let t=a1(e,"x","relu6");return aH.runKernel(rS,{x:t})}}),o2=a4({sigmoid_:function(e){let t=a1(e,"x","sigmoid","float32");return aH.runKernel(rL,{x:t})}});function o3(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return sK(e,ic(t));throw Error(`Cannot compute gradient for fused activation ${n}.`)}function o4(e,t){let n=t,r=ii(e.shape,t.shape);return r.length>0&&(n=ix(n,r)),iy(n,e.shape)}function o5(e,t,n,r){if("linear"===t)return e;if("relu"===t)return o0(e);if("elu"===t)return oZ(e);if("relu6"===t)return o1(e);if("prelu"===t)return oQ(e,n);else if("leakyrelu"===t)return oJ(e,r);else if("sigmoid"===t)return o2(e);throw Error(`Unknown fused activation ${t}.`)}let o6=(e,t)=>!(e>0)||"linear"===t;function o8(e,t,n){let r=[];if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let a=1;a<n.length;++a){let s=n[a],i=r[r.length-n.length+a],o=r[i];if(s>=0)if(o>=0){if(o!==s)throw Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${a+e}] = ${s} but shape[${a+e}] = ${o}`)}else r[i]=s}return r}function o7(e){let t={FIRST_DIM_SIZE:A.FIRST_DIM_SIZE,VALUE_ROWIDS:A.VALUE_ROWIDS,ROW_LENGTHS:A.ROW_LENGTHS,ROW_SPLITS:A.ROW_SPLITS,ROW_LIMITS:A.ROW_LIMITS,ROW_STARTS:A.ROW_STARTS},n=[];for(let r of e)if(r in t)n.push(t[r]);else break;return n}function o9(e){return 0===e.length?0:e[0]===A.FIRST_DIM_SIZE?e.length-1:e.length}function le(e,t){if(null==e||null==t)return;let n=e.length,r=t.length;if(n>=r)throw Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let a=0;a<Math.min(n,r-1);++a){let n=e[a],r=t[a+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${a-e.length}] = ${n} but ragged tensor input.flatValues.shape[${a-e.length}] = ${r}`)}}function lt(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function ln(e,t,n,r=!0){let a=[];if(r)(a=a.concat(t.slice(0))).push(e[0]/n),a=a.concat(e.slice(1));else{a=a.concat(e[0]);let n=t.length;for(let r=0;r<n;++r)a=a.concat([e[r+1]/t[r],t[r]]);a=a.concat(e.slice(n+1))}return a}function lr(e,t,n=!0){let r=[];if(n){r.push(t);for(let n=t+1;n<e;++n)n<=2*t?(r.push(n),r.push(n-(t+1))):r.push(n)}else{let n=[],a=[];for(let r=1;r<e;++r)r>=2*t+1||r%2==1?a.push(r):n.push(r);r.push(...n),r.push(0),r.push(...a)}return r}function la(e,t,n,r=!0){let a=[];r?a.push(e[0]/n):a.push(e[0]*n);for(let n=1;n<e.length;++n)n<=t.length?r?a.push(t[n-1]*e[n]):a.push(e[n]/t[n-1]):a.push(e[n]);return a}function ls(e,t){let n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function li(e,t,n){let r=e.slice(0,1);for(let a=0;a<n;++a)r.push(e[a+1]-t[a][0]-t[a][1]);return r}function lo(e,t){let n=e.shape.length,r=t.shape.length;if(n<1)throw Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===tr(e.shape))throw Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let a=t.shape,s=a[a.length-1],i=1;for(let e=0;e<a.length-1;++e)i*=a[e];let o=e.shape,l=a.slice();l.pop();let u=1;for(let e=s;e<n;++e)u*=o[e],l.push(o[e]);let h=[...tE(e.shape).map(e=>e/u),1].slice(0,s);return[l,i,u,h]}function ll(e,t,n){let r=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${a}.`;if(n.rank<a)throw Error(s+` update.rank < ${a}. `);if(e.length<r+(n.rank-a))throw Error(s+` Output shape length < ${r+(n.rank-a)}`);if(n.rank!==a+e.length-r)throw Error(s+` update.rank != ${a+e.length-r}`);for(let e=0;e<a;++e)if(n.shape[e]!==t.shape[e])throw Error(s+` updates.shape[${e}] (${n.shape[e]}) != indices.shape[${e}] (${t.shape[e]}).`);for(let t=0;t<n.rank-a;++t)if(n.shape[t+a]!==e[t+r])throw Error(s+` updates.shape[${t+a}] (${n.shape[t+a]}) != shape[${t+a}] (${e[t+a]})`)}function lu(e,t,n){if(t.rank<1)throw Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw Error(`Updates specified for empty output. updates shape: ${e.shape}`)}ll(n,t,e)}function lh(e,t,n){let r=t.shape.length,a=r>1?t.shape[r-1]:1,s=n.length,i=1;for(let e=a;e<s;++e)i*=n[e];let o=a<1?1:a,l=tr(t.shape)/o,u=[...tE(n.slice(0,a)),1];return{sliceRank:a,numUpdates:l,sliceSize:i,strides:u,outputSize:tr(n)}}function lp(e,t){if(e.length!==t.length)throw Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function ld(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function lc(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=0;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function lf(e){let t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=2;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function lm(e,t){return{real:e[2*t],imag:e[2*t+1]}}function lg(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function ly(e,t){let n=new Float32Array(e/2),r=new Float32Array(e/2);for(let a=0;a<Math.ceil(e/2);a++){let s=(t?2:-2)*Math.PI*(a/e);n[a]=Math.cos(s),r[a]=Math.sin(s)}return{real:n,imag:r}}function lx(e,t,n){let r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}e.s(["applyActivation",()=>o5,"getFusedBiasGradient",()=>o4,"getFusedDyActivation",()=>o3,"shouldFuse",0,o6],51259),e.i(51259),e.s([],33261),e.i(33261),(f=A||(A={}))[f.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",f[f.VALUE_ROWIDS=1]="VALUE_ROWIDS",f[f.ROW_LENGTHS=2]="ROW_LENGTHS",f[f.ROW_SPLITS=3]="ROW_SPLITS",f[f.ROW_LIMITS=4]="ROW_LIMITS",f[f.ROW_STARTS=5]="ROW_STARTS",e.s(["RowPartitionType",()=>A,"combineRaggedTensorToTensorShapes",()=>o8,"getRaggedRank",()=>o9,"getRowPartitionTypesHelper",()=>o7,"validateDefaultValueShape",()=>le],24996),e.i(24996),e.i(27584),e.s(["getImageCenter",()=>lt],74428),e.i(74428),e.s(["getPermuted",()=>lr,"getReshaped",()=>ln,"getReshapedPermuted",()=>la,"getSliceBeginCoords",()=>ls,"getSliceSize",()=>li],3967),e.i(3967),e.s(["prepareAndValidate",()=>lo],3042),e.i(3042),e.s(["calculateShapes",()=>lh,"validateInput",()=>lu,"validateUpdateShape",()=>ll],59860),e.i(59860),e.s(["SELU_SCALE",0,1.0507009873554805,"SELU_SCALEALPHA",0,1.7580993408473768],77974),e.i(77974),e.s(["ERF_A1",0,.254829592,"ERF_A2",0,-.284496736,"ERF_A3",0,1.421413741,"ERF_A4",0,-1.453152027,"ERF_A5",0,1.061405429,"ERF_P",0,.3275911],2283),e.i(2283),e.i(91338),e.s(["assignToTypedArray",()=>lg,"complexWithEvenIndex",()=>lc,"complexWithOddIndex",()=>lf,"exponent",()=>lx,"exponents",()=>ly,"getComplexWithIndex",()=>lm,"mergeRealAndImagArrays",()=>lp,"splitRealAndImagArrays",()=>ld],83312),e.i(83312);let lb=/->/g;function lw(e,t){let n=((e=e.replace(/\s/g,"")).length-e.replace(lb,"").length)/2;if(n<1)throw Error("Equations without an arrow are not supported.");if(n>1)throw Error('Equation must contain exactly one arrow ("->").');let[r,a]=e.split("->");te(-1===r.indexOf("..."),()=>'The ellipsis notation ("...") is not supported yet.');let s=r.split(","),i=s.length;if(t!==i)throw Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw Error("Support for more than 2 input tensors is not implemented yet.");let o=[];for(let e=0;e<a.length;++e){let t=a[e];if(!s.some(e=>-1!==e.indexOf(t)))throw Error(`Output subscripts contain the label ${t} not present in the input subscripts.`);-1===o.indexOf(t)&&o.push(t)}for(let e=0;e<r.length;++e){let t=r[e];-1===o.indexOf(t)&&","!==t&&o.push(t)}let l=Array(s.length);for(let e=0;e<i;++e){if(new Set(s[e].split("")).size!==s[e].length)throw Error(`Found duplicate axes in input component ${s[e]}. Support for duplicate axes in input is not implemented yet.`);l[e]=[];for(let t=0;t<s[e].length;++t)l[e].push(o.indexOf(s[e][t]))}let u=o.length,h=a.length,p=[];for(let e=h;e<u;++e)p.push(e);return{allDims:o,summedDims:p,idDims:l}}function lv(e,t){let n=Array(e);n.fill(-1);for(let e=0;e<t.length;++e)n[t[e]]=e;let r=[];for(let t=0;t<e;++t)-1===n[t]&&r.push(t);return{permutationIndices:n=n.filter(e=>-1!==e),expandDims:r}}function lk(e,t,n){let r=Array(e);for(let e=0;e<n.length;++e){let a=n[e].shape;for(let n=0;n<t[e].length;++n)void 0===r[t[e][n]]?r[t[e][n]]=a[n]:te(r[t[e][n]]===a[n],()=>`Expected dimension ${r[t[e][n]]} at axis ${n} of input shaped ${JSON.stringify(a)}, but got dimension ${a[n]}`)}}function lN(e,t){let n=[],r=0;0===e.length&&e.push(-1),r=e.length+1;for(let e=0;e<r;++e)n.push([]);let a=[];for(let r=0;r<e.length;++r)for(let s of function(e,t){let n=[];for(let r=0;r<e.length;++r)(0===e[r].length||-1!==e[r].indexOf(t)||-1===t)&&n.push(r);return n}(t,e[r]))-1===a.indexOf(s)&&(n[r].push(s),a.push(s));return{path:e,steps:n}}function lI(e){return e.every((e,t)=>e===t)}function lS(e,t,n=0){let r=[];if("number"==typeof t)te(e.shape[n]%t==0,()=>"Number of splits must evenly divide the axis."),r=Array(t).fill(e.shape[n]/t);else{te(1>=t.reduce((e,t)=>(-1===t&&(e+=1),e),0),()=>"There should be only one negative value in split array.");let a=t.indexOf(-1);if(-1!==a){let r=t.reduce((e,t)=>t>0?e+t:e);t[a]=e.shape[n]-r}te(e.shape[n]===t.reduce((e,t)=>e+t),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function lC(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function lT(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function l$(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function lE(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function lA(e,t){return`size ${e} must be non-negative, not ${t}`}function lR(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function lF(e,t){let n=tr(e),r=tr(t);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${e} outputShape= ${t}`}function l_(e,t){let n=tr(e),r=tr(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${e} outputShape=${t}`}function lD(){return"segment ids must be >= 0"}function lO(){return"segment ids are not increasing"}function lM(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function lL(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}e.s(["checkEinsumDimSizes",()=>lk,"decodeEinsumEquation",()=>lw,"getEinsumComputePath",()=>lN,"getEinsumPermutation",()=>lv,"isIdentityPermutation",()=>lI],81874),e.i(81874),e.s(["prepareSplitSize",()=>lS],73025),e.i(73025),e.s(["getSparseFillEmptyRowsIndicesDenseShapeMismatch",()=>lC,"getSparseFillEmptyRowsNegativeIndexErrorMessage",()=>lT,"getSparseFillEmptyRowsOutOfRangeIndexErrorMessage",()=>l$],8104),e.i(8104),e.s(["getSparseReshapeEmptyTensorZeroOutputDimErrorMessage",()=>lR,"getSparseReshapeInputOutputMismatchErrorMessage",()=>l_,"getSparseReshapeInputOutputMultipleErrorMessage",()=>lF,"getSparseReshapeMultipleNegativeOneOutputDimErrorMessage",()=>lE,"getSparseReshapeNegativeOutputDimErrorMessage",()=>lA],20442),e.i(20442),e.s(["getSparseSegmentReductionIndicesOutOfRangeErrorMessage",()=>lL,"getSparseSegmentReductionNegativeSegmentIdsErrorMessage",()=>lD,"getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage",()=>lO,"getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage",()=>lM],66298),e.i(66298),e.s(["ERF_A1",0,.254829592,"ERF_A2",0,-.284496736,"ERF_A3",0,1.421413741,"ERF_A4",0,-1.453152027,"ERF_A5",0,1.061405429,"ERF_P",0,.3275911,"PARALLELIZE_THRESHOLD",0,30,"RowPartitionType",()=>A,"SELU_SCALE",0,1.0507009873554805,"SELU_SCALEALPHA",0,1.7580993408473768,"applyActivation",()=>o5,"assertAndGetBroadcastShape",()=>io,"assertAxesAreInnerMostDims",()=>i2,"assertParamsConsistent",()=>oX,"assignToTypedArray",()=>lg,"axesAreInnerMostDims",()=>iJ,"calculateShapes",()=>lh,"checkEinsumDimSizes",()=>lk,"checkPadOnDimRoundingMode",()=>i_,"combineLocations",()=>iQ,"combineRaggedTensorToTensorShapes",()=>o8,"complexWithEvenIndex",()=>lc,"complexWithOddIndex",()=>lf,"computeConv2DInfo",()=>ik,"computeConv3DInfo",()=>iN,"computeDefaultPad",()=>iI,"computeDilation2DInfo",()=>ib,"computeOptimalWindowSize",()=>oW,"computeOutAndReduceShapes",()=>i0,"computeOutShape",()=>oY,"computePool2DInfo",()=>iw,"computePool3DInfo",()=>iv,"convertConv2DDataFormat",()=>iF,"decodeEinsumEquation",()=>lw,"eitherStridesOrDilationsAreOne",()=>iA,"expandShapeToKeepDim",()=>i1,"exponent",()=>lx,"exponents",()=>ly,"fromStringArrayToUint8",()=>oq,"fromUint8ToStringArray",()=>oH,"getAxesPermutation",()=>i3,"getBroadcastDims",()=>is,"getComplexWithIndex",()=>lm,"getEinsumComputePath",()=>lN,"getEinsumPermutation",()=>lv,"getFusedBiasGradient",()=>o4,"getFusedDyActivation",()=>o3,"getImageCenter",()=>lt,"getInnerMostAxes",()=>i5,"getPermuted",()=>lr,"getRaggedRank",()=>o9,"getReductionAxes",()=>ii,"getReshaped",()=>ln,"getReshapedPermuted",()=>la,"getRowPartitionTypesHelper",()=>o7,"getSliceBeginCoords",()=>ls,"getSliceSize",()=>li,"getSparseFillEmptyRowsIndicesDenseShapeMismatch",()=>lC,"getSparseFillEmptyRowsNegativeIndexErrorMessage",()=>lT,"getSparseFillEmptyRowsOutOfRangeIndexErrorMessage",()=>l$,"getSparseReshapeEmptyTensorZeroOutputDimErrorMessage",()=>lR,"getSparseReshapeInputOutputMismatchErrorMessage",()=>l_,"getSparseReshapeInputOutputMultipleErrorMessage",()=>lF,"getSparseReshapeMultipleNegativeOneOutputDimErrorMessage",()=>lE,"getSparseReshapeNegativeOutputDimErrorMessage",()=>lA,"getSparseSegmentReductionIndicesOutOfRangeErrorMessage",()=>lL,"getSparseSegmentReductionNegativeSegmentIdsErrorMessage",()=>lD,"getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage",()=>lO,"getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage",()=>lM,"getUndoAxesPermutation",()=>i4,"isIdentityPermutation",()=>lI,"log",()=>ao,"mergeRealAndImagArrays",()=>lp,"prepareAndValidate",()=>lo,"prepareSplitSize",()=>lS,"segment_util",0,oG,"shouldFuse",0,o6,"slice_util",0,oB,"splitRealAndImagArrays",()=>ld,"stridesOrDilationsArePositive",()=>iR,"tupleValuesAreOne",()=>iE,"upcastType",()=>aD,"validateDefaultValueShape",()=>le,"validateInput",()=>lu,"validateUpdateShape",()=>ll,"warn",()=>ai],66521);var lz=e.i(66521),lz=lz;let lP=a4({cumprod_:function(e,t=0,n=!1,r=!1){let a=a1(e,"x","cumprod");return aH.runKernel(nc,{x:a},{axis:t,exclusive:n,reverse:r})}}),lB=a4({reverse_:function(e,t){let n=a1(e,"x","reverse");return aH.runKernel(rC,{x:n},{dims:t})}}),lW=a4({logicalNot_:function(e){let t=a1(e,"x","logicalNot","bool");return aH.runKernel(nQ,{x:t})}}),lU=a4({cos_:function(e){let t=a1(e,"x","cos","float32");return aH.runKernel("Cos",{x:t})}}),lj=a4({cosh_:function(e){let t=a1(e,"x","cosh","float32");return aH.runKernel(nd,{x:t})}}),lV=a4({pad_:function(e,t,n=0){let r=a1(e,"x","pad");if(0===r.rank)throw Error("pad(scalar) is not defined. Pass non-scalar to pad");return aH.runKernel(rh,{x:r},{paddings:t,constantValue:n})}}),lG=a4({batchToSpaceND_:function(e,t,n){let r=a1(e,"x","batchToSpaceND"),a=t.reduce((e,t)=>e*t);return te(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),te(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),te(r.shape[0]%a==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${a}`),aH.runKernel(t6,{x:r},{blockShape:t,crops:n})}}),lH={kernelName:rB,gradFunc:(e,t,n)=>{let{blockShape:r,paddings:a}=n;return{x:()=>lG(e,r,a)}}},lq=a4({concat_:function(e,t=0){te(e.length>=1,()=>"Pass at least one tensor to concat");let n=a2(e,"tensors","concat","string_or_numeric");return("complex64"===n[0].dtype&&n.forEach(e=>{if("complex64"!==e.dtype)throw Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${e.dtype}. `)}),1===n.length)?sj(n[0]):aH.runKernel(ns,n,{axis:t})}}),lK={kernelName:rW,gradFunc:(e,t,n)=>{let{axis:r}=n;return{x:()=>lq(e,r)}}},lX=a4({expandDims_:function(e,t=0){let n=a1(e,"x","expandDims","string_or_numeric");return te(t<=n.rank,()=>"Axis must be <= rank of the tensor"),aH.runKernel(nA,{input:n},{dim:t})}}),lY=a4({gather_:function(e,t,n=0,r=0){let a=a1(e,"x","gather"),s=a1(t,"indices","gather","int32");return aH.runKernel(nL,{x:a,indices:s},{axis:n,batchDims:r})}});for(let e of[im,{kernelName:tG,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=sY(sU(n,"float32"));return ig(sq(e,sX(it(sQ(1),t))))}}}},{kernelName:tH,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sq(e,sX(it(sY(sU(n,"float32")),1)))}}},{kernelName:"Add",inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=io(n.shape,r.shape);return{a:()=>{let t=e,r=ii(n.shape,a);return r.length>0&&(t=ix(t,r)),iy(t,n.shape)},b:()=>{let t=e,n=ii(r.shape,a);return n.length>0&&(t=ix(t,n)),iy(t,r.shape)}}}},{kernelName:tq,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach((t,r)=>{n[r]=()=>e.clone()}),n}},{kernelName:tK,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sZ(n)}}},{kernelName:tX,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sZ(n)}}},{kernelName:tY,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sq(e,sX(it(sQ(1),sY(sU(n,"float32")))))}}},{kernelName:tZ,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sq(e,sX(sG(sQ(1),sY(sU(n,"float32")))))}}},{kernelName:t0,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=io(n.shape,r.shape);return{a:()=>{let t=sG(sY(n),sY(r)),s=sK(e,sq(r,t)),i=ii(n.shape,a);return i.length>0&&(s=ix(s,i)),iy(s,n.shape)},b:()=>{let t=sG(sY(n),sY(r)),s=ig(sK(e,sq(n,t))),i=ii(r.shape,a);return i.length>0&&(s=ix(s,i)),iy(s,r.shape)}}}},{kernelName:tJ,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sq(e,sG(sY(sU(n,"float32")),1))}}},{kernelName:tQ,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sq(e,it(sQ(1),sY(sU(n,"float32"))))}}},{kernelName:t3,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:s,pad:i,dimRoundingMode:o}=n;return{x:()=>iD(e,r,a,s,i,o)}}},{kernelName:t1,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:s,pad:i}=n;return{x:()=>iO(e,r,a,s,i)}}},{kernelName:t5,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{let[r,a]=t,{transposeA:s,transposeB:i}=n;return s||i?!s&&i?{a:()=>iM(e,a,!1,!1),b:()=>iM(e,r,!0,!1)}:s&&!i?{a:()=>iM(a,e,!1,!0),b:()=>iM(r,e,!1,!1)}:{a:()=>iM(a,e,!0,!0),b:()=>iM(e,r,!0,!0)}:{a:()=>iM(e,a,!1,!0),b:()=>iM(r,e,!0,!1)}}},{kernelName:t6,gradFunc:(e,t,n)=>{let{blockShape:r,crops:a}=n;return{x:()=>iL(e,r,a)}}},{kernelName:"BroadcastTo",gradFunc:(e,t,n)=>{let r=n.inputShape,a=n.shape,s=Array.from(a);for(let e=r.length-1;e>=0;e--)if(r[e]===a[e])s[e]=1;else if(1!==r[e])throw Error(`broadcastTo(): [${r}] cannot be broadcast to [${a}].`);let i=[];for(let e=0;e<s.length;e++)s[e]>1&&i.push(e);return{x:()=>ix(e,i,!0)}}},{kernelName:ne,gradFunc:e=>({x:()=>e.clone()})},{kernelName:nt,gradFunc:e=>({x:()=>sZ(e)})},{kernelName:nn,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{clipValueMin:a,clipValueMax:s}=n;return{x:()=>iU(iB(iz(r,a),iP(r,s)),e,sZ(e))}}},ij,{kernelName:ns,saveAllInputs:!0,gradFunc:(e,t,n)=>{let r=t.map(e=>e.shape),{axis:a}=n,s=tf(a,t[0].shape)[0];return iV(e,r.map(e=>e[s]),s).map(e=>()=>e)}},{kernelName:nl,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{strides:s,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>iq(e,a,s,i,o,1,l),filter:()=>iG(e,r,a.shape,s,i,o,l)}}},{kernelName:ni,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{dilations:s,strides:i,pad:o,dataFormat:l}=n;return te(iE(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>iH(r.shape,e,a,i,o,l),filter:()=>iG(r,e,a.shape,i,o,l)}}},{kernelName:nu,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:s}=n;te(iE(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);let[i,o]=t;return{x:()=>iX(i.shape,e,o,a,s),filter:()=>iK(i,e,o.shape,a,s)}}},{kernelName:"Cos",inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sK(ig(iY(sU(n,"float32"))),e)}}},{kernelName:nd,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sK(iZ(sU(n,"float32")),e)}}},{kernelName:nf,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a,exclusive:s,reverse:i}=n;return{x:()=>{let t=i3([a],r.rank),n=i6(e,a,s,!i);return null!=t&&(n=i9(n,t)),n}}}},{kernelName:nx,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:s,dimRoundingMode:i}=n,o=null==r?[1,1]:r;te(iE(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);let[l,u]=t;return te(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),te(4===u.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),te(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),te(iA(a,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${a} and dilations '${o}'.`),i_("depthwiseConv2d",s,i),{x:()=>ot(l.shape,e,u,a,s,o,i),filter:()=>oe(l,e,u.shape,a,s,o,i)}}},{kernelName:nk,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,s={x:r,filter:a,dy:e},i={x:r,filter:a,dy:e};return{x:()=>aH.runKernel(nN,s,n),filter:()=>aH.runKernel(nI,i,n)}}},{kernelName:nC,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=io(n.shape,r.shape);return{a:()=>{let t=sq(e,sU(r,"float32")),s=ii(n.shape,a);return s.length>0?iy(ix(t,s),n.shape):t},b:()=>{let t=sK(e,sU(n,"float32")),s=ii(r.shape,a);return s.length>0&&(t=iy(ix(t,s),r.shape)),ig(sq(t,sU(sY(r),"float32")))}}}},{kernelName:"Elu",outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,r={dy:e,y:n};return{x:()=>aH.runKernel(n$,r)}}},{kernelName:"Erf",inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=sK(on(ig(sY(n))),2/Math.sqrt(Math.PI));return{x:()=>sK(e,r)}}},{kernelName:"Exp",outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sK(e,n)}}},{kernelName:nA,inputsToSave:["input"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>iy(e,n.shape)}}},{kernelName:nR,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sK(e,on(n))}}},{kernelName:nO,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=io(n.shape,r.shape);return{a:()=>{let t=sq(e,sU(r,"float32")),s=ii(n.shape,a);return s.length>0?iy(ix(t,s),n.shape):t},b:()=>{let t=sK(e,sU(n,"float32")),s=ii(r.shape,a);return s.length>0&&(t=iy(ix(t,s),r.shape)),ig(sq(t,sU(sY(r),"float32")))}}}},{kernelName:nD,gradFunc:e=>({x:()=>sZ(e)})},{kernelName:nM,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{let{varianceEpsilon:r}=n,[a,s,i,o]=t,l=null==o?sQ(1):o,u=ii(s.shape,a.shape),h=[];if(1===s.rank){for(let e=0;e<a.shape.length-1;++e)h.push(a.shape[e]);h.push(1)}let p=it(a,s),d=sK(e,l),c=or(sG(i,sQ(r))),f=sK(sK(sK(c,c),c),sQ(-.5));return{x:()=>1===s.rank?iy(sK(sK(e,oa(iy(c,[1,1,1,s.shape[0]]),h)),l),a.shape):iy(sK(sK(e,c),l),a.shape),mean:()=>{let e=sK(sK(c,sQ(-1)),d);return 1===s.rank&&(e=ix(e,u)),iy(e,s.shape)},variance:()=>{let e=sK(sK(f,p),d);return 1===s.rank&&(e=ix(e,u)),iy(e,s.shape)},scale:()=>{let t=sK(p,c),n=sK(e,t);return 1===s.rank&&(n=ix(n,u)),iy(n,s.shape)},offset:()=>{let t=e;return 1===s.rank&&(t=ix(t,u)),iy(t,s.shape)}}}},{kernelName:nL,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{let[r,a]=t,{axis:s,batchDims:i}=n,o=tf(s,r.shape)[0],l=(e,t,n)=>()=>{let r=e.shape,a=t.size,i=r.slice(0,o),l=i.length,u=r.slice(s,r.length).slice(1),h=u.length,p=oo(0,l),d=oo(l+1,l+1+h),c=iy(n,ol([i,[a],u])),f=iy(t,[a]),m=ol([[l],p,d]),g=oi(i9(c,m),f,e.shape[o]);return i9(g,i4(m))};if(1!==i)return{x:l(r,a,e),indices:()=>a};{let t=r.shape[0],n=r.split(t,0);return{x:()=>os(n.map((t,n)=>l(t,a.slice(n,1),e.slice(n,1))())).reshape(r.shape),indices:()=>a}}}},{kernelName:nB,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>sZ(n),b:()=>sZ(r)}}},{kernelName:nW,gradFunc:e=>({x:()=>sU(e,"float32")})},{kernelName:nV,gradFunc:e=>({x:()=>sZ(e)})},{kernelName:nG,gradFunc:e=>({x:()=>sZ(e)})},{kernelName:nH,gradFunc:e=>({x:()=>sZ(e)})},{kernelName:nq,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{alpha:a}=n,s=ou(r,0);return{x:()=>iU(s,e,sK(e,a))}}},{kernelName:nZ,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sq(e,sG(n,1))}}},{kernelName:"Log",inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sq(e,sU(n,"float32"))}}},{kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n;return{logits:()=>{let t=on(r);return it(e,sK(ix(e,a,!0),t))}}}},{kernelName:"LRN",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{depthRadius:s,bias:i,alpha:o,beta:l}=n;return{x:()=>oh(r,a,e,s,i,o,l)}}},oc,oc,{kernelName:n2,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>sK(e,sU(iz(n,r),"float32")),b:()=>sK(e,sU(of(n,r),"float32"))}}},{kernelName:n5,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>om(e,r,a,s,i,o,l)}}},{kernelName:n3,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:s,strides:i,pad:o}=n;return{x:()=>og(e,r,a,s,i,o)}}},{kernelName:n7,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,s=tf(a,r.shape),i=tr(i0(r.shape,s)[1]);return{x:()=>{let t=r.shape.slice();return s.forEach(e=>{t[e]=1}),sq(sK(iy(e,t),ox(r.shape,"float32")),i)}}}},{kernelName:"Min",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let{axis:r}=n,[a,s]=t,i=tf(r,a.shape),o=od(e,s,a,i);return{x:()=>o.x()}}},{kernelName:n9,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>sK(e,sU(iP(n,r),"float32")),b:()=>sK(e,sU(ou(n,r),"float32"))}}},{kernelName:re,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,s=a.map(e=>e[0]);return{x:()=>ob(e,s,r.shape)}}},{kernelName:"Mod",inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=io(n.shape,r.shape);return{a:()=>{let t=ii(n.shape,a);return t.length>0?iy(ix(e,t),n.shape):e},b:()=>{let t=sK(e,ig(ow(sq(n,r)))),s=ii(r.shape,a);return s.length>0?iy(ix(t,s),r.shape):t}}}},{kernelName:rn,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=io(n.shape,r.shape);return{a:()=>{let t=sK(e,sU(r,"float32")),s=ii(n.shape,a);return s.length>0?iy(ix(t,s),n.shape):t},b:()=>{let t=sK(e,sU(n,"float32")),s=ii(r.shape,a);return s.length>0?iy(ix(t,s),r.shape):t}}}},{kernelName:"Neg",gradFunc:e=>({x:()=>ig(e)})},{kernelName:rl,inputsToSave:["indices"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>oy(n.shape,"float32")}}},{kernelName:ro,gradFunc:e=>({x:()=>sZ(e)})},{kernelName:ru,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:r}=n;return ov(e,r).map(e=>()=>e)}},ok,ok,{kernelName:"Pow",inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,r,a]=t,s=io(n.shape,r.shape);return{a:()=>{let t=sU(r,"float32"),a=sK(e,sK(t,ie(n,it(t,sQ(1))))),i=ii(n.shape,s);return i.length>0&&(a=ix(a,i)),iy(a,n.shape)},b:()=>{let t=sK(e,sK(a,iU(ou(n,0),oN(n),sZ(n)))),i=ii(r.shape,s);return i.length>0&&(t=ix(t,i)),iy(t,r.shape)}}}},{kernelName:rp,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[n,r]=t,a=ou(n,0);return{x:()=>iU(a,e,sK(e,r)),alpha:()=>{let t=iU(a,sZ(e),sK(e,n)),s=ii(r.shape,e.shape);return s.length>0&&(t=ix(t,s)),iy(t,r.shape)}}}},{kernelName:rd,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,s=[];return s=null==a?r.shape.map((e,t)=>t):"number"==typeof a?[a]:a,{x:()=>{var t,n;let a,i,o,l,u,h,p,d,c,f;return t=s,i=(a=r.shape.length)-t.length,o=lz.getAxesPermutation(t,a),l=r,null!=o&&(l=i9(r,o)),h=(u=l.shape.slice()).splice(a-t.length,t.length).reduce((e,t)=>e*t,1),u.push(h),f=(n=l.reshape(u),(p=n.shape.slice())[i]=1,d=iy(e,p),c=sK(lP(n,i,!0,!1),lP(n,i,!0,!0)),f=sK(d,c)).reshape(l.shape),null!=o&&(f=i9(f,lz.getUndoAxesPermutation(o))),f}}}},{kernelName:rx,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sq(e,ig(sY(n)))}}},{kernelName:rS,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=sK(iP(n,6),ic(n));return{x:()=>sK(e,sU(r,"float32"))}}},{kernelName:rb,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sK(e,sU(ic(n),"float32"))}}},{kernelName:rw,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>iy(e,n.shape)}}},{kernelName:rN,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>aH.runKernel(rI,a,n)}}},{kernelName:rv,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>aH.runKernel(rk,a,n)}}},{kernelName:rC,gradFunc:(e,t,n)=>{let{dims:r}=n,a=tf(r,e.shape);return{x:()=>lB(e,a)}}},{kernelName:rT,gradFunc:e=>({x:()=>sZ(e)})},{kernelName:r$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ig(sq(e,sK(ie(n,1.5),2)))}}},{kernelName:rF,inputsToSave:["condition"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>sU(sZ(n),"float32"),t:()=>sK(e,sU(n,e.dtype)),e:()=>sK(e,sU(lW(n),e.dtype))}}},{kernelName:r_,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=ou(n,sQ(0)),r=sQ(1.7580993408473768);return iU(t,sK(e,sQ(1.0507009873554805)),sK(sK(e,r),on(sU(n,"float32"))))}}}},{kernelName:rL,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sK(e,sK(n,it(sQ(1),n)))}}},{kernelName:rM,gradFunc:e=>({x:()=>sZ(e)})},{kernelName:"Sin",inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sK(lU(sU(n,"float32")),e)}}},{kernelName:rO,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sK(lj(sU(n,"float32")),e)}}},{kernelName:rD,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{begin:a,size:s}=n,i=r.shape,[o,l]=oL(r,a,s),u=[];for(let t=0;t<e.rank;t++)u.push([o[t],i[t]-o[t]-l[t]]);return{x:()=>lV(e,u)}}},{kernelName:rU,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{dim:a}=n,s=sK(e,r);return{logits:()=>it(s,sK(ix(s,[a],!0),r))}}},{kernelName:rz,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sK(e,o2(n))}}},lH,lH,lK,lK,{kernelName:rP,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sq(e,sK(sX(sU(n,"float32")),2))}}},{kernelName:rK,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=sQ(2);return{a:()=>sK(e,sK(a,it(n,r))),b:()=>sK(e,sK(a,it(r,n)))}}},{kernelName:rX,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sK(e,sK(sU(n,"float32"),2))}}},{kernelName:ae,gradFunc:e=>({x:()=>sZ(e)})},{kernelName:"Sub",inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=io(n.shape,r.shape);return{a:()=>{let t=e,r=ii(n.shape,a);return r.length>0&&(t=ix(t,r)),iy(t,n.shape)},b:()=>{let t=e,n=ii(r.shape,a);return n.length>0&&(t=ix(t,n)),iy(ig(t),r.shape)}}}},{kernelName:"Sum",inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,a=r.shape.slice(),{axis:s}=n;tf(s,r.shape).forEach(e=>{a[e]=1});let i=sK(iy(e,a),ox(r.shape,"float32"));return{x:()=>i}}},{kernelName:"Tan",inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sq(e,sY(lU(n)))}}},{kernelName:r1,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sK(it(sQ(1),sY(n)),e)}}},{kernelName:r2,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{reps:a}=n;return{x:()=>{let t=sZ(r);if(1===r.rank)for(let n=0;n<a[0];++n)t=sG(t,ob(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)t=sG(t,ob(e,[n*r.shape[0],s*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let i=0;i<a[2];++i)t=sG(t,ob(e,[n*r.shape[0],s*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(4===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let i=0;i<a[2];++i)for(let o=0;o<a[3];++o)t=sG(t,ob(e,[n*r.shape[0],s*r.shape[1],i*r.shape[2],o*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return t}}}},{kernelName:r5,gradFunc:(e,t,n)=>{let{perm:r}=n,a=i4(r);return{x:()=>i9(e,a)}}},{kernelName:r8,gradFunc:(e,t,n)=>{let{axis:r}=n;return{value:()=>os(e,r)}}},{kernelName:r7,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>(function(e,t){let n=lY(e,il(t,sZ(t))),r=iz(t,sQ(0,"int32")),a=n.rank-r.rank;for(let e=0;e<a;++e)r=lX(r,e+1);r=iB(r,ox(n.shape,"bool"));let s=sZ(n);return iU(r,n,s)})(e,n)}}},{kernelName:r9,gradFunc:e=>({x:()=>sZ(e)})}])!function(e){let{kernelName:t}=e;au.has(t)&&tU.getBool("DEBUG")&&ai(`Overriding the gradient for '${t}'`),au.set(t,e)}(e);aR().prototype.abs=function(){return this.throwIfDisposed(),ia(this)};let lZ=a4({acos_:function(e){let t=a1(e,"x","acos");return aH.runKernel(tG,{x:t})}});aR().prototype.acos=function(){return this.throwIfDisposed(),lZ(this)};let lJ=a4({acosh_:function(e){let t=a1(e,"x","acosh");return aH.runKernel(tH,{x:t})}});aR().prototype.acosh=function(){return this.throwIfDisposed(),lJ(this)},aR().prototype.add=function(e){return this.throwIfDisposed(),sG(this,e)};let lQ=a4({all_:function(e,t=null,n=!1){let r=a1(e,"x","all","bool");return aH.runKernel("All",{x:r},{axis:t,keepDims:n})}});aR().prototype.all=function(e,t){return this.throwIfDisposed(),lQ(this,e,t)};let l0=a4({any_:function(e,t=null,n=!1){let r=a1(e,"x","any","bool");return aH.runKernel("Any",{x:r},{axis:t,keepDims:n})}});aR().prototype.any=function(e,t){return this.throwIfDisposed(),l0(this,e,t)};let l1=a4({argMax_:function(e,t=0){let n=a1(e,"x","argMax");return aH.runKernel(tK,{x:n},{axis:t})}});aR().prototype.argMax=function(e){return this.throwIfDisposed(),l1(this,e)};let l2=a4({argMin_:function(e,t=0){let n=a1(e,"x","argMin");return aH.runKernel(tX,{x:n},{axis:t})}});aR().prototype.argMin=function(e){return this.throwIfDisposed(),l2(this,e)},aR().prototype.asScalar=function(){return this.throwIfDisposed(),te(1===this.size,()=>"The array must have only 1 element."),iy(this,[])},aR().prototype.asType=function(e){return this.throwIfDisposed(),sU(this,e)},aR().prototype.as1D=function(){return this.throwIfDisposed(),iy(this,[this.size])},aR().prototype.as2D=function(e,t){return this.throwIfDisposed(),iy(this,[e,t])},aR().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),iy(this,[e,t,n])},aR().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),iy(this,[e,t,n,r])},aR().prototype.as5D=function(e,t,n,r,a){return this.throwIfDisposed(),iy(this,[e,t,n,r,a])};let l3=a4({asin_:function(e){let t=a1(e,"x","asin");return aH.runKernel(tY,{x:t})}});aR().prototype.asin=function(){return this.throwIfDisposed(),l3(this)};let l4=a4({asinh_:function(e){let t=a1(e,"x","asinh");return aH.runKernel(tZ,{x:t})}});aR().prototype.asinh=function(){return this.throwIfDisposed(),l4(this)};let l5=a4({atan_:function(e){let t=a1(e,"x","atan");return aH.runKernel(tJ,{x:t})}});aR().prototype.atan=function(){return this.throwIfDisposed(),l5(this)};let l6=a4({atan2_:function(e,t){let n=a1(e,"a","atan2"),r=a1(t,"b","atan2");[n,r]=az(n,r);let a={a:n,b:r};return aH.runKernel(t0,a)}});aR().prototype.atan2=function(e){return this.throwIfDisposed(),l6(this,e)};let l8=a4({atanh_:function(e){let t=a1(e,"x","atanh");return aH.runKernel(tQ,{x:t})}});aR().prototype.atanh=function(){return this.throwIfDisposed(),l8(this)};let l7=a4({avgPool_:function(e,t,n,r,a){let s=a1(e,"x","avgPool","float32");te(iA(n,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`);let i=s,o=!1;3===s.rank&&(o=!0,i=iy(s,[1,s.shape[0],s.shape[1],s.shape[2]])),te(4===i.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),i_("avgPool",r,a);let l={x:i},u=aH.runKernel(t1,l,{filterSize:t,strides:n,pad:r,dimRoundingMode:a});return(u=sU(u,s.dtype),o)?iy(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});aR().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),l7(this,e,t,n,r)},aR().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),lG(this,e,t)};let l9=a4({batchNorm_:function(e,t,n,r,a,s){let i,o;null==s&&(s=.001);let l=a1(e,"x","batchNorm"),u=a1(t,"mean","batchNorm"),h=a1(n,"variance","batchNorm");null!=a&&(i=a1(a,"scale","batchNorm")),null!=r&&(o=a1(r,"offset","batchNorm")),te(u.rank===h.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),te(null==o||u.rank===o.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),te(null==i||u.rank===i.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let p={x:0===l.rank||1===l.rank?iy(l,[1,1,1,l.size]):2===l.rank?iy(l,[1,1,l.shape[0],l.shape[1]]):3===l.rank?iy(l,[1,l.shape[0],l.shape[1],l.shape[2]]):l,scale:i,offset:o,mean:u,variance:h},d={varianceEpsilon:s};return iy(aH.runKernel(nM,p,d),l.shape)}});aR().prototype.batchNorm=function(e,t,n,r,a){return this.throwIfDisposed(),l9(this,e,t,n,r,a)},aR().prototype.broadcastTo=function(e){return this.throwIfDisposed(),iW(this,e)},aR().prototype.cast=function(e){return this.throwIfDisposed(),sU(this,e)};let ue=a4({ceil_:function(e){let t=a1(e,"x","ceil","float32");return aH.runKernel(nt,{x:t})}});aR().prototype.ceil=function(){return this.throwIfDisposed(),ue(this)};let ut=a4({clipByValue_:function(e,t,n){let r=a1(e,"x","clipByValue");return(te(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)?s7(r.shape,t,r.dtype):aH.runKernel(nn,{x:r},{clipValueMin:t,clipValueMax:n})}});aR().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),ut(this,e,t)},aR().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof aA&&(e=[e]),lq([this,...e],t)};let un=a4({conv1d_:function(e,t,n,r,a="NWC",s=1,i){let o=a1(e,"x","conv1d"),l=a1(t,"filter","conv1d"),u=o,h=!1;2===o.rank&&(h=!0,u=iy(o,[1,o.shape[0],o.shape[1]])),te(3===u.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),te(3===l.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),i_("conv1d",r,i),te(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),te(iA(n,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`),te(iR(s),()=>"Error in conv1D: Dilated rates should be larger than 0."),te(iR(n),()=>"Error in conv1D: Stride should be larger than 0."),te("NWC"===a,()=>`Error in conv1d: got dataFormat of ${a} but only NWC is currently supported.`);let p=iy(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=iq(iy(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p,[1,n],r,"NHWC",[1,s],i);return h?iy(d,[d.shape[2],d.shape[3]]):iy(d,[d.shape[0],d.shape[2],d.shape[3]])}});aR().prototype.conv1d=function(e,t,n,r,a,s){return this.throwIfDisposed(),un(this,e,t,n,r,a,s)};let ur=a4({conv2dTranspose_:function(e,t,n,r,a,s){return iH(n,a1(e,"x","conv2dTranspose"),a1(t,"filter","conv2dTranspose"),r,a,"NHWC",s)}});aR().prototype.conv2dTranspose=function(e,t,n,r,a){return this.throwIfDisposed(),ur(this,e,t,n,r,a)},aR().prototype.conv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),iq(this,e,t,n,r,a,s)},aR().prototype.cos=function(){return this.throwIfDisposed(),lU(this)},aR().prototype.cosh=function(){return this.throwIfDisposed(),lj(this)},aR().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),lP(this,e,t,n)},aR().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),i6(this,e,t,n)};let ua=a4({depthToSpace_:function(e,t,n="NHWC"){let r=a1(e,"x","depthToSpace","float32"),a="NHWC"===n?r.shape[1]:r.shape[2],s="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];return te(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),te(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${t}  for depthToSpace with input shape
    ${r.shape}`),te(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t} for depthToSpace with input shape
        ${r.shape}`),te(i%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`),aH.runKernel(ny,{x:r},{blockSize:t,dataFormat:n})}});aR().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),ua(this,e,t)};let us=a4({depthwiseConv2d_:function(e,t,n,r,a="NHWC",s=[1,1],i){let o=a1(e,"x","depthwiseConv2d","float32"),l=a1(t,"filter","depthwiseConv2d","float32"),u=o,h=!1;3===o.rank&&(h=!0,u=iy(o,[1,o.shape[0],o.shape[1],o.shape[2]])),te(4===u.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),te(4===l.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);let p="NHWC"===a?u.shape[3]:u.shape[1];te(p===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${p}) must match the inChannels dimension in filter ${l.shape[2]}.`),i_("depthwiseConv2d",r,i);let d={x:u,filter:l},c=aH.runKernel(nx,d,{strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i});return h?iy(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});aR().prototype.depthwiseConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),us(this,e,t,n,r,a,s)};let ui=a4({dilation2d_:function(e,t,n,r,a=[1,1],s="NHWC"){let i=a1(e,"x","dilation2d"),o=a1(t,"filter","dilation2d");te(3===i.rank||4===i.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),te(3===o.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),te("NHWC"===s,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let l=i,u=!1;3===i.rank&&(l=iy(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),te(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);let h={x:l,filter:o},p=aH.runKernel(nk,h,{strides:n,pad:r,dilations:a});return u?iy(p,[p.shape[1],p.shape[2],p.shape[3]]):p}});aR().prototype.dilation2d=function(e,t,n,r,a){return this.throwIfDisposed(),ui(this,e,t,n,r,a)};let uo=a4({divNoNan_:function(e,t){let n=a1(e,"a","div"),r=a1(t,"b","div");[n,r]=az(n,r);let a=sq(n,r),s=sZ(a);return iU(op(r,s),s,a)}});aR().prototype.divNoNan=function(e){return this.throwIfDisposed(),uo(this,e)},aR().prototype.div=function(e){return this.throwIfDisposed(),sq(this,e)};let ul=a4({dot_:function(e,t){let n=a1(e,"t1","dot"),r=a1(t,"t2","dot");te((1===n.rank||2===n.rank)&&(1===r.rank||2===r.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);let a=1===n.rank?n.size:n.shape[1],s=1===r.rank?r.size:r.shape[0];if(te(a===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${a} and ${s}.`),1===n.rank&&1===r.rank){let e=iM(iy(n,[1,-1]),iy(r,[-1,1]));return iy(e,[])}if(1===n.rank&&2===r.rank){let e=iM(iy(n,[1,-1]),iy(r,[r.shape[0],r.shape[1]]));return iy(e,[e.size])}if(2!==n.rank||1!==r.rank)return iM(n,iy(r,[r.shape[0],r.shape[1]]));{let e=iM(n,iy(r,[-1,1]));return iy(e,[e.size])}}});aR().prototype.dot=function(e){return this.throwIfDisposed(),ul(this,e)},aR().prototype.elu=function(){return this.throwIfDisposed(),oZ(this)},aR().prototype.equal=function(e){return this.throwIfDisposed(),op(this,e)};let uu=a4({erf_:function(e){let t=a1(e,"x","erf");te("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=sU(t,"float32"));let n={x:t};return aH.runKernel("Erf",n)}});aR().prototype.erf=function(){return this.throwIfDisposed(),uu(this)};let uh=a4({max_:function(e,t=null,n=!1){let r=a1(e,"x","max");return aH.runKernel("Max",{x:r},{reductionIndices:t,keepDims:n})}}),up=a4({min_:function(e,t=null,n=!1){let r=a1(e,"x","min");return aH.runKernel("Min",{x:r},{axis:t,keepDims:n})}}),ud=a4({norm_:function(e,t="euclidean",n=null,r=!1){let a=function e(t,n,r=null){if(0===t.rank)return ia(t);if(1!==t.rank&&null===r)return e(iy(t,[-1]),n,r);if(1===t.rank||"number"==typeof r||Array.isArray(r)&&1===r.length){if(1===n)return ix(ia(t),r);if(n===1/0)return uh(ia(t),r);if(n===-1/0)return up(ia(t),r);if("euclidean"===n||2===n)return sX(ix(ie(ia(t),sQ(2,"int32")),r));throw Error(`Error in norm: invalid ord value: ${n}`)}if(Array.isArray(r)&&2===r.length){if(1===n)return uh(ix(ia(t),r[0]),r[1]-1);if(n===1/0)return uh(ix(ia(t),r[1]),r[0]);if(n===-1/0)return up(ix(ia(t),r[1]),r[0]);if("fro"===n||"euclidean"===n)return sX(ix(sY(t),r));throw Error(`Error in norm: invalid ord value: ${n}`)}throw Error(`Error in norm: invalid axis: ${r}`)}(e=a1(e,"x","norm"),t,n),s=a.shape;if(r){let t=tf(n,e.shape);s=i1(a.shape,t)}return iy(a,s)}});e.s(["norm",0,ud],97791);let uc=a4({euclideanNorm_:function(e,t=null,n=!1){return ud(e,"euclidean",t,n)}});aR().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),uc(this,e,t)},aR().prototype.exp=function(){return this.throwIfDisposed(),on(this)},aR().prototype.expandDims=function(e){return this.throwIfDisposed(),lX(this,e)};let uf=a4({expm1_:function(e){let t=a1(e,"x","expm1");return aH.runKernel(nR,{x:t})}});aR().prototype.expm1=function(){return this.throwIfDisposed(),uf(this)};let um=a4({fft_:function(e){return te("complex64"===e.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`),aH.runKernel("FFT",{input:e})}});aR().prototype.fft=function(){return this.throwIfDisposed(),um(this)},aR().prototype.flatten=function(){return this.throwIfDisposed(),iy(this,[this.size])},aR().prototype.floor=function(){return this.throwIfDisposed(),ow(this)},aR().prototype.floorDiv=function(e){return this.throwIfDisposed(),sH(this,e)},aR().prototype.gather=function(e,t,n){return this.throwIfDisposed(),lY(this,e,t,n)},aR().prototype.greaterEqual=function(e){return this.throwIfDisposed(),iz(this,e)},aR().prototype.greater=function(e){return this.throwIfDisposed(),ou(this,e)};let ug=a4({ifft_:function(e){return te("complex64"===e.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`),aH.runKernel(nU,{input:e})}});aR().prototype.ifft=function(){return this.throwIfDisposed(),ug(this)};let uy=a4({irfft_:function(e){let t,n=e.shape[e.shape.length-1],r=e.size/n;if(n<=2)t=ug(iy(e,[r,n]));else{let a=[r,2*(n-1)],s=iy(i7(e),[r,n]),i=iy(i8(e),[r,n]),o=lB(ob(s,[0,1],[r,n-2]),1),l=sK(lB(ob(i,[0,1],[r,n-2]),1),sQ(-1));t=ug(iy(a5(lq([s,o],1),lq([i,l],1)),[a[0],a[1]]))}if(t=i7(t),3===e.rank&&0!==e.shape[0]){let n=t,r=e.shape[0];t=iy(t,[r,t.shape[0]/r,t.shape[1]]),n.dispose()}return t}});aR().prototype.irfft=function(){return this.throwIfDisposed(),uy(this)};let ux=a4({isFinite_:function(e){let t=a1(e,"x","isFinite");return aH.runKernel(nV,{x:t})}});aR().prototype.isFinite=function(){return this.throwIfDisposed(),ux(this)};let ub=a4({isInf_:function(e){let t=a1(e,"x","isInf");return aH.runKernel(nG,{x:t})}});aR().prototype.isInf=function(){return this.throwIfDisposed(),ub(this)};let uw=a4({isNaN_:function(e){let t=a1(e,"x","isNaN");return aH.runKernel(nH,{x:t})}});aR().prototype.isNaN=function(){return this.throwIfDisposed(),uw(this)},aR().prototype.leakyRelu=function(e){return this.throwIfDisposed(),oJ(this,e)},aR().prototype.lessEqual=function(e){return this.throwIfDisposed(),iP(this,e)},aR().prototype.less=function(e){return this.throwIfDisposed(),of(this,e)};let uv=a4({localResponseNormalization_:function(e,t=5,n=1,r=1,a=.5){let s=a1(e,"x","localResponseNormalization");te(4===s.rank||3===s.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),te(to(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=s,o=!1;3===s.rank&&(o=!0,i=iy(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let l={x:i},u=aH.runKernel("LRN",l,{depthRadius:t,bias:n,alpha:r,beta:a});return o?iy(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});aR().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),uv(this,e,t,n,r)};let uk=a4({softplus_:function(e){let t=a1(e,"x","softplus");return aH.runKernel(rz,{x:t})}}),uN=a4({logSigmoid_:function(e){let t=a1(e,"x","logSigmoid");return sJ(e=>({value:ig(uk(ig(e))),gradFunc:t=>sK(t,o2(ig(e)))}))(t)}});aR().prototype.logSigmoid=function(){return this.throwIfDisposed(),uN(this)};let uI=a4({logSoftmax_:function(e,t=-1){let n=a1(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return sJ((e,n)=>{let r=uh(e,t,!0),a=it(e,r),s=it(sU(a,"float32"),oN(ix(on(a),t,!0)));return n([s]),{value:s,gradFunc:(e,n)=>{let[r]=n,a=on(r);return it(e,sK(ix(e,t,!0),a))}}})(n)}});aR().prototype.logSoftmax=function(e){return this.throwIfDisposed(),uI(this,e)};let uS=a4({logSumExp_:function(e,t=null,n=!1){let r=a1(e,"x","logSumExp"),a=tf(t,r.shape),s=uh(r,a,!0),i=oN(ix(on(it(r,s)),a)),o=sG(iy(s,i.shape),i);if(n){let e=i1(o.shape,a);return iy(o,e)}return o}});aR().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),uS(this,e,t)},aR().prototype.log=function(){return this.throwIfDisposed(),oN(this)};let uC=a4({log1p_:function(e){let t=a1(e,"x","log1p");return aH.runKernel(nZ,{x:t})}});aR().prototype.log1p=function(){return this.throwIfDisposed(),uC(this)},aR().prototype.logicalAnd=function(e){return this.throwIfDisposed(),iB(this,e)},aR().prototype.logicalNot=function(){return this.throwIfDisposed(),lW(this)};let uT=a4({logicalOr_:function(e,t){let n=a1(e,"a","logicalOr","bool"),r=a1(t,"b","logicalOr","bool");return io(n.shape,r.shape),aH.runKernel(n0,{a:n,b:r})}});aR().prototype.logicalOr=function(e){return this.throwIfDisposed(),uT(this,e)};let u$=a4({logicalXor_:function(e,t){let n=a1(e,"a","logicalXor","bool"),r=a1(t,"b","logicalXor","bool");return io(n.shape,r.shape),iB(uT(e,t),lW(iB(e,t)))}});aR().prototype.logicalXor=function(e){return this.throwIfDisposed(),u$(this,e)},aR().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),iM(this,e,t,n)};let uE=a4({maxPool_:function(e,t,n,r,a){let s=a1(e,"x","maxPool"),i=s,o=!1;3===s.rank&&(o=!0,i=iy(s,[1,s.shape[0],s.shape[1],s.shape[2]])),te(4===i.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),te(iA(n,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`),i_("maxPool",r,a);let l={x:i},u=aH.runKernel(n3,l,{filterSize:t,strides:n,pad:r,dimRoundingMode:a});return o?iy(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});aR().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),uE(this,e,t,n,r)},aR().prototype.max=function(e,t){return this.throwIfDisposed(),uh(this,e,t)},aR().prototype.maximum=function(e){return this.throwIfDisposed(),il(this,e)};let uA=a4({mean_:function(e,t=null,n=!1){let r=a1(e,"x","mean");return aH.runKernel(n7,{x:r},{axis:t,keepDims:n})}});aR().prototype.mean=function(e,t){return this.throwIfDisposed(),uA(this,e,t)},aR().prototype.min=function(e,t){return this.throwIfDisposed(),up(this,e,t)};let uR=a4({minimum_:function(e,t){let n=a1(e,"a","minimum"),r=a1(t,"b","minimum");[n,r]=az(n,r),"bool"===n.dtype&&(n=sU(n,"int32"),r=sU(r,"int32")),io(n.shape,r.shape);let a={a:n,b:r};return aH.runKernel(n9,a)}});aR().prototype.minimum=function(e){return this.throwIfDisposed(),uR(this,e)};let uF=a4({mirrorPad_:function(e,t,n){te("reflect"===n||"symmetric"===n,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);let r=a1(e,"x","mirrorPad");if(0===r.rank)throw Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");te(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);let a=+("reflect"===n);for(let e=0;e<r.rank;e++)te(2===t[e].length,()=>"Invalid number of paddings. Must be length of 2 each."),te(t[e][0]>=0&&t[e][0]<=r.shape[e]-a&&t[e][1]>=0&&t[e][1]<=r.shape[e]-a,()=>`Padding in dimension ${e} cannot be greater than or equal to ${r.shape[e]-a} or less than 0 for input of shape ${r.shape}`);return aH.runKernel(re,{x:r},{paddings:t,mode:n})}});aR().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),uF(this,e,t)};let u_=a4({mod_:function(e,t){let n=a1(e,"a","mod"),r=a1(t,"b","mod");[n,r]=az(n,r);let a={a:n,b:r};return aH.runKernel("Mod",a)}});aR().prototype.mod=function(e){return this.throwIfDisposed(),u_(this,e)},aR().prototype.mul=function(e){return this.throwIfDisposed(),sK(this,e)},aR().prototype.neg=function(){return this.throwIfDisposed(),ig(this)},aR().prototype.norm=function(e,t,n){return this.throwIfDisposed(),ud(this,e,t,n)};let uD=a4({notEqual_:function(e,t){let n=a1(e,"a","notEqual","string_or_numeric"),r=a1(t,"b","notEqual","string_or_numeric");[n,r]=az(n,r),io(n.shape,r.shape);let a={a:n,b:r};return aH.runKernel(rr,a)}});aR().prototype.notEqual=function(e){return this.throwIfDisposed(),uD(this,e)};let uO=a4({oneHot_:function(e,t,n=1,r=0,a="int32"){if(t<2)throw Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let s=a1(e,"indices","oneHot","int32");return aH.runKernel(rl,{indices:s},{dtype:a,depth:t,onValue:n,offValue:r})}});aR().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),uO(this,e,t,n)};let uM=a4({onesLike_:function(e){let t=a1(e,"x","onesLike");return aH.runKernel(ro,{x:t})}});aR().prototype.onesLike=function(){return this.throwIfDisposed(),uM(this)},aR().prototype.pad=function(e,t){return this.throwIfDisposed(),lV(this,e,t)};let uL=a4({pool_:function(e,t,n,r,a,s,i){var o,l,u,h,p;let d,c,f,m,g,y,x,b,w;null==a&&(a=[1,1]),null==s&&(s=1),0===r&&(r="valid");let v=a1(e,"x","maxPool"),k=v,N=!1;3===v.rank&&(N=!0,k=iy(v,[1,v.shape[0],v.shape[1],v.shape[2]])),te(iA(s,a),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${a}'`);let I=iw(k.shape,t,s,a,r),S=[I.dilationHeight,I.dilationWidth];d="same"===r?(o=[I.filterHeight,I.filterWidth],l=S,f=(c=o.map((e,t)=>e+(e-1)*(l[t]-1)).map(e=>e-1)).map(e=>Math.floor(e/2)),m=c.map((e,t)=>e-f[t]),c.map((e,t)=>[f[t],m[t]])):[[0,0],[0,0]];let C=1===S[0]&&1===S[1],[T,$]=(u=[I.inHeight,I.inWidth],h=S,g=(p=d).map(e=>e[0]),x=u.concat(g,y=p.map(e=>e[1])),b=h.map((e,t)=>(e-x[t]%e)%e),w=y.map((e,t)=>e+b[t]),[h.map((e,t)=>[g[t],w[t]]),h.map((e,t)=>[0,b[t]])]),E=C?r:"valid",A=C?k:iL(k,S,T),R=("avg"===n?()=>l7(A,t,s,E,i):()=>uE(A,t,s,E,i))(),F=C?R:lG(R,S,$);return N?iy(F,[F.shape[1],F.shape[2],F.shape[3]]):F}});aR().prototype.pool=function(e,t,n,r,a,s){return this.throwIfDisposed(),uL(this,e,t,n,r,a,s)},aR().prototype.pow=function(e){return this.throwIfDisposed(),ie(this,e)},aR().prototype.prelu=function(e){return this.throwIfDisposed(),oQ(this,e)};let uz=a4({prod_:function(e,t=null,n=!1){let r=a1(e,"x","prod");"bool"===r.dtype&&(r=sU(r,"int32"));let a={x:r};return aH.runKernel(rd,a,{axis:t,keepDims:n})}});aR().prototype.prod=function(e,t){return this.throwIfDisposed(),uz(this,e,t)};let uP=a4({reciprocal_:function(e){let t=a1(e,"x","reciprocal");return aH.runKernel(rx,{x:t})}});aR().prototype.reciprocal=function(){return this.throwIfDisposed(),uP(this)},aR().prototype.relu=function(){return this.throwIfDisposed(),o0(this)},aR().prototype.relu6=function(){return this.throwIfDisposed(),o1(this)},aR().prototype.reshapeAs=function(e){return this.throwIfDisposed(),iy(this,e.shape)},aR().prototype.reshape=function(e){return this.throwIfDisposed(),iy(this,e)};let uB=a4({resizeBilinear_:function(e,t,n=!1,r=!1){let a=a1(e,"images","resizeBilinear");te(3===a.rank||4===a.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${a.rank}.`),te(2===t.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),te(!1===r||!1===n,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=a,i=!1;3===a.rank&&(i=!0,s=iy(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let[]=t,o={images:s},l=aH.runKernel(rN,o,{alignCorners:n,halfPixelCenters:r,size:t});return i?iy(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});aR().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),uB(this,e,t,n)};let uW=a4({resizeNearestNeighbor_:function(e,t,n=!1,r=!1){let a=a1(e,"images","resizeNearestNeighbor");te(3===a.rank||4===a.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${a.rank}.`),te(2===t.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),te("float32"===a.dtype||"int32"===a.dtype,()=>"`images` must have `int32` or `float32` as dtype"),te(!1===r||!1===n,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=a,i=!1;3===a.rank&&(i=!0,s=iy(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let[]=t,o={images:s},l=aH.runKernel(rv,o,{alignCorners:n,halfPixelCenters:r,size:t});return i?iy(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});aR().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),uW(this,e,t,n)},aR().prototype.reverse=function(e){return this.throwIfDisposed(),lB(this,e)};let uU=a4({rfft_:function(e,t){let n;te("float32"===e.dtype,()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let r=e.shape[e.shape.length-1],a=e.size/r;if(null!=t&&t<r){let a=e.shape.map(e=>0),s=e.shape.map(e=>e);s[e.shape.length-1]=t,n=ob(e,a,s),r=t}else if(null!=t&&t>r){let a=e.shape.map(e=>e);a[e.shape.length-1]=t-r,n=lq([e,oy(a)],e.shape.length-1),r=t}else n=e;let s=sZ(n),i=um(iy(a5(n,s),[a,r])),o=Math.floor(r/2)+1,l=i7(i),u=i8(i),h=iV(l,[o,r-o],l.shape.length-1),p=iV(u,[o,r-o],u.shape.length-1),d=n.shape.slice();return d[n.shape.length-1]=o,iy(a5(h[0],p[0]),d)}});aR().prototype.rfft=function(){return this.throwIfDisposed(),uU(this)};let uj=a4({round_:function(e){let t=a1(e,"x","round");return aH.runKernel(rT,{x:t})}});aR().prototype.round=function(){return this.throwIfDisposed(),uj(this)},aR().prototype.rsqrt=function(){return this.throwIfDisposed(),or(this)};let uV=a4({selu_:function(e){let t=a1(e,"x","selu");return aH.runKernel(r_,{x:t})}});aR().prototype.selu=function(){return this.throwIfDisposed(),uV(this)};let uG=a4({separableConv2d_:function(e,t,n,r,a,s=[1,1],i="NHWC"){let o=a1(e,"x","separableConv2d"),l=a1(t,"depthwiseFilter","separableConv2d"),u=a1(n,"pointwiseFilter","separableConv2d"),h=o,p=!1;if(3===o.rank&&(p=!0,h=iy(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===i)throw Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");te(4===h.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${h.rank}.`),te(4===l.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),te(4===u.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),te(1===u.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),te(1===u.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);let d=l.shape[2],c=l.shape[3];te(u.shape[2]===d*c,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*c}, but got ${u.shape[2]}.`);let f=iq(us(h,l,r,a,i,s),u,1,"valid",i);return p?iy(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});aR().prototype.separableConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),uG(this,e,t,n,r,a,s)},aR().prototype.sigmoid=function(){return this.throwIfDisposed(),o2(this)};let uH=a4({sign_:function(e){let t=a1(e,"x","sign");return aH.runKernel(rM,{x:t})}});aR().prototype.sign=function(){return this.throwIfDisposed(),uH(this)},aR().prototype.sin=function(){return this.throwIfDisposed(),iY(this)},aR().prototype.sinh=function(){return this.throwIfDisposed(),iZ(this)},aR().prototype.slice=function(e,t){return this.throwIfDisposed(),ob(this,e,t)};let uq=a4({softmax_:function(e,t=-1){let n=a1(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let r={dim:t};return aH.runKernel(rU,{logits:n},r)}});aR().prototype.softmax=function(e){return this.throwIfDisposed(),uq(this,e)},aR().prototype.softplus=function(){return this.throwIfDisposed(),uk(this)},aR().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),iL(this,e,t)},aR().prototype.split=function(e,t){return this.throwIfDisposed(),iV(this,e,t)},aR().prototype.sqrt=function(){return this.throwIfDisposed(),sX(this)},aR().prototype.square=function(){return this.throwIfDisposed(),sY(this)};let uK=a4({squaredDifference_:function(e,t){let n=a1(e,"a","squaredDifference"),r=a1(t,"b","squaredDifference");[n,r]=az(n,r),io(n.shape,r.shape);let a={a:n,b:r};return aH.runKernel(rK,a,{})}});aR().prototype.squaredDifference=function(e){return this.throwIfDisposed(),uK(this,e)};let uX=a4({squeeze_:function(e,t){let n=a1(e,"x","squeeze","string_or_numeric");return iy(n,tm(n.shape,t).newShape)}});aR().prototype.squeeze=function(e){return this.throwIfDisposed(),uX(this,e)},aR().prototype.stack=function(e,t){return this.throwIfDisposed(),os(e instanceof aA?[this,e]:[this,...e],t)},aR().prototype.step=function(e){return this.throwIfDisposed(),ic(this,e)};let uY=a4({stridedSlice_:function(e,t,n,r,a=0,s=0,i=0,o=0,l=0){let u=a1(e,"x","stridedSlice","string_or_numeric");return aH.runKernel(rZ,{x:u},{begin:t,end:n,strides:r,beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l})}});aR().prototype.stridedSlice=function(e,t,n,r,a,s,i,o){return this.throwIfDisposed(),uY(this,e,t,n,r,a,s,i,o)},aR().prototype.sub=function(e){return this.throwIfDisposed(),it(this,e)},aR().prototype.sum=function(e,t){return this.throwIfDisposed(),ix(this,e,t)};let uZ=a4({tan_:function(e){let t=a1(e,"x","tan","float32");return aH.runKernel("Tan",{x:t})}});aR().prototype.tan=function(){return this.throwIfDisposed(),uZ(this)};let uJ=a4({tanh_:function(e){let t=a1(e,"x","tanh","float32");return aH.runKernel(r1,{x:t})}});aR().prototype.tanh=function(){return this.throwIfDisposed(),uJ(this)},aR().prototype.tile=function(e){return this.throwIfDisposed(),oa(this,e)},aR().prototype.toBool=function(){return this.throwIfDisposed(),sU(this,"bool")},aR().prototype.toFloat=function(){return this.throwIfDisposed(),sU(this,"float32")},aR().prototype.toInt=function(){return this.throwIfDisposed(),sU(this,"int32")};let uQ=a4({topk_:function(e,t=1,n=!0){let r=a1(e,"x","topk");if(0===r.rank)throw Error("topk() expects the input to be of rank 1 or higher");let a=r.shape[r.shape.length-1];if(t<0)throw Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>a)throw Error(`'k' passed to topk() must be <= the last dimension (${a}) but got ${t}`);let[s,i]=aH.runKernel(r3,{x:r},{k:t,sorted:n});return{values:s,indices:i}}});aR().prototype.topk=function(e,t){return this.throwIfDisposed(),uQ(this,e,t)},aR().prototype.transpose=function(e){return this.throwIfDisposed(),i9(this,e)};let u0=a4({unique_:function(e,t=0){let n=a1(e,"x","unique","string_or_numeric");te(n.rank>0,()=>"The input tensor must be at least 1D");let[r,a]=aH.runKernel(r6,{x:n},{axis:t});return{values:r,indices:a}}});aR().prototype.unique=function(e){return this.throwIfDisposed(),u0(this,e)},aR().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),oi(this,e,t)},aR().prototype.unstack=function(e){return this.throwIfDisposed(),ov(this,e)},aR().prototype.where=function(e,t){return this.throwIfDisposed(),iU(e,this,t)},aR().prototype.zerosLike=function(){return this.throwIfDisposed(),sZ(this)},e.i(94150),e.i(63385);var u1=e.i(53373);let u2=u1.default||u1;function u3(e){return u2.fromString(e,!0,16)}let u4=u3("c3a5c85c97cb3127"),u5=u3("b492b66fbe98f273"),u6=u3("9ae16a3b2f90404f");function u8(e){return e.xor(e.shru(47))}function u7(e,t,n){let r=e.slice(t,t+n);return u2.fromBytes(Array.from(r),!0,!0)}function u9(e,t){return u7(e,t,8)}function he(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function ht(e,t,n=u3("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let a=t.xor(r).mul(n);return(a=a.xor(a.shru(47))).mul(n)}function hn(e,t,n,r){var a,s,i,o,l,u;let h;return a=u9(e,t),s=u9(e,t+8),i=u9(e,t+16),o=u9(e,t+24),l=n,u=r,l=l.add(a),u=he(u.add(l).add(o),21),h=l,l=(l=l.add(s)).add(i),u=u.add(he(l,44)),[l.add(o),u.add(h)]}function hr(e,t=e.length){let n=u2.fromNumber(81,!0);if(t<=32)if(t<=16)return function(e,t=e.length){if(t>=8){let n=u6.add(2*t),r=u9(e,0).add(u6),a=u9(e,t-8);return ht(he(a,37).mul(n).add(r),he(r,25).add(a).mul(n),n)}if(t>=4){let n=u6.add(2*t);return ht(u7(e,0,4).shl(3).add(t),u7(e,t-4,4),n)}if(t>0){let n=e[0],r=e[t>>1],a=e[t-1];return u8(u6.mul(n+(r<<8)).xor(u4.mul(t+(a<<2)))).mul(u6)}return u6}(e,t);else return function(e,t=e.length){let n=u6.add(2*t),r=u9(e,0).mul(u5),a=u9(e,8),s=u9(e,t-8).mul(n),i=u9(e,t-16).mul(u6);return ht(he(r.add(a),43).add(he(s,30)).add(i),r.add(he(a.add(u6),18)).add(s),n)}(e,t);if(t<=64)return function(e,t=e.length){let n=u6.add(2*t),r=u9(e,0).mul(u6),a=u9(e,8),s=u9(e,t-8).mul(n),i=u9(e,t-16).mul(u6),o=he(r.add(a),43).add(he(s,30)).add(i),l=ht(o,r.add(he(a.add(u6),18)).add(s),n),u=u9(e,16).mul(n),h=u9(e,24),p=o.add(u9(e,t-32)).mul(n),d=l.add(u9(e,t-24)).mul(n);return ht(he(u.add(h),43).add(he(p,30)).add(d),u.add(he(h.add(r),18)).add(p),n)}(e,t);let r=n,a=n.mul(u5).add(113),s=u8(a.mul(u6).add(113)).mul(u6),i=[u2.UZERO,u2.UZERO],o=[u2.UZERO,u2.UZERO];r=r.mul(u6).add(u9(e,0));let l=0,u=(t-1>>6)*64,h=u+(t-1&63)-63;do r=he(r.add(a).add(i[0]).add(u9(e,l+8)),37).mul(u5),a=he(a.add(i[1]).add(u9(e,l+48)),42).mul(u5),r=r.xor(o[1]),a=a.add(i[0]).add(u9(e,l+40)),s=he(s.add(o[0]),33).mul(u5),i=hn(e,l,i[1].mul(u5),r.add(o[0])),o=hn(e,l+32,s.add(o[1]),a.add(u9(e,l+16))),[s,r]=[r,s],l+=64;while(l!==u)let p=u5.add(s.and(255).shl(1));return l=h,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=he(r.add(a).add(i[0]).add(u9(e,l+8)),37).mul(p),a=he(a.add(i[1]).add(u9(e,l+48)),42).mul(p),r=r.xor(o[1].mul(9)),a=a.add(i[0].mul(9).add(u9(e,l+40))),s=he(s.add(o[0]),33).mul(p),i=hn(e,l,i[1].mul(p),r.add(o[0])),o=hn(e,l+32,s.add(o[1]),a.add(u9(e,l+16))),[s,r]=[r,s],ht(ht(i[0],o[0],p).add(u8(a).mul(u4)).add(s),ht(i[1],o[1],p).add(r),p)}e.s(["fingerPrint64",()=>hr,"hexToLong",()=>u3],45463),e.i(45463),e.s(["arraysEqual",()=>ti,"arraysEqualWithNull",()=>ts,"assert",()=>te,"assertNonNegativeIntegerDimensions",()=>tO,"assertNonNull",()=>tn,"assertShapesMatch",()=>tt,"bytesFromStringArray",()=>tk,"bytesPerElement",()=>tv,"checkConversionForErrors",()=>tx,"clamp",()=>e4,"computeStrides",()=>tE,"convertBackendValuesAndArrayBuffer",()=>tR,"createScalarValue",()=>af,"createShuffledIndices",()=>th,"decodeString",()=>ab,"distSquared",()=>e9,"encodeString",()=>ax,"fetch",()=>ay,"fingerPrint64",()=>hr,"flatten",()=>av,"getArrayFromDType",()=>ty,"getTypedArrayFromDType",()=>tg,"hasEncodingLoss",()=>tw,"hexToLong",()=>u3,"indexToLoc",()=>tL,"inferDtype",()=>tC,"inferFromImplicitShape",()=>tc,"isBoolean",()=>tI,"isFunction",()=>tT,"isInt",()=>to,"isNumber",()=>tS,"isPromise",()=>tz,"isScalarShape",()=>ta,"isString",()=>tN,"isTypedArray",()=>aw,"isValidDtype",()=>tb,"locToIndex",()=>tM,"makeOnesTypedArray",()=>tF,"makeZerosNestedTypedArray",()=>tD,"makeZerosTypedArray",()=>t_,"nearestDivisor",()=>t$,"nearestLargerEven",()=>e5,"now",()=>ag,"parseAxisParam",()=>tf,"randUniform",()=>e7,"repeatedTry",()=>td,"rightPad",()=>tp,"shuffle",()=>e2,"shuffleCombo",()=>e3,"sizeFromShape",()=>tr,"sizeToSquarishShape",()=>tu,"squeezeShape",()=>tm,"sum",()=>e8,"swap",()=>e6,"tanh",()=>tl,"toNestedArray",()=>tA,"toTypedArray",()=>am],93730);var ha=e.i(93730),ha=ha;class hs extends Error{constructor(e){super(e),Object.setPrototypeOf(this,hs.prototype)}}class hi extends Error{constructor(e){super(e),Object.setPrototypeOf(this,hi.prototype)}}class ho extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ho.prototype)}}class hl extends Error{constructor(e){super(e),Object.setPrototypeOf(this,hl.prototype)}}class hu extends Error{constructor(e){super(e),Object.setPrototypeOf(this,hu.prototype)}}class hh{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}}var ha=ha;function hp(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{let n=Array(t);return n.fill(e),n}}function hd(e,t){if(!e)throw new hu(t)}function hc(e,t){let n=0;for(let r of e)r===t&&n++;return n}function hf(e){return 1===e.length?e[0]:e}function hm(e){return Array.isArray(e)?e:[e]}function hg(e){let t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function hy(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let hx={};function hb(e){if(null==e)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function hw(e,t={},n={},r="object",a=!1){if("string"==typeof e){let a;if(e in n)a=n[e];else if(e in hx)a=hx[e];else if(null==(a=t[e]))throw new ho(`Unknown ${r}: ${e}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}{let s,i;if(null==e.className||null==e.config)throw new ho(`${r}: Improper config format: ${JSON.stringify(e)}.
'className' and 'config' must set.`);let o=e.className;if(o in n?[s,i]=n[o]:o in hx?[s,i]=hx.className:o in t&&([s,i]=t[o]),null==s)throw new ho(`Unknown ${r}: ${o}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=i){let t={};for(let e of Object.keys(hx))t[e]=hx[e];for(let e of Object.keys(n))t[e]=n[e];e.config.customObjects=t;let r=Object.assign({},hx);for(let e of Object.keys(n))hx[e]=n[e];!function e(t){if(null!=t&&"object"==typeof t)if(Array.isArray(t))t.forEach(t=>e(t));else for(let n of Object.keys(t)){let r=t[n];null!=r&&"object"==typeof r&&(Array.isArray(r)||"ndarray"!==r.type||"number"!=typeof r.value?e(r):t[n]=r.value)}}(e.config);let o=i(s,e.config,n,a);return hx=Object.assign({},r),o}{let t=Object.assign({},hx);for(let e of Object.keys(n))hx[e]=n[e];let r=new s(e.config);return hx=Object.assign({},t),r}}}function hv(e,t){return -1*(e<t?-1:+(e>t))}function hk(e){if(null==e)return e;let t=[];for(let n of e)-1===t.indexOf(n)&&t.push(n);return t}function hN(e,t,n){if(null!=n&&0>e.indexOf(n))throw new ho(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function hI(e,t,n=0,r=1/0){return hd(n>=0),hd(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every(e=>typeof e===t)}function hS(e,t){Array.isArray(e)?(ha.assert(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((e,n)=>hS(e,`element ${n+1} of ${t}`))):ha.assert(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${function e(t){return null===t?"null":Array.isArray(t)?"["+t.map(t=>e(t)).join(",")+"]":"string"==typeof t?`"${t}"`:`${t}`}(e)}.`)}function hC(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}var hT=e.i(4976),hT=hT;let h$=0,hE={};function hA(e=""){return e in hE||(hE[e]=0),hE[e]+=1,e+hE[e].toString()}var hT=hT,ha=ha;let hR=["channelsFirst","channelsLast"],hF=["nearest","bilinear"],h_=["valid","same","causal"],hD=["max","avg"],hO=["sum","mul","concat","ave"],hM=new Map;function hL(e){hN(hR,"DataFormat",e)}function hz(e){hN(h_,"PaddingMode",e)}function hP(e){hN(hD,"PoolMode",e)}let hB=[];function hW(e,t){hB.push(e);try{let e=t();return hB.pop(),e}catch(e){throw hB.pop(),e}}function hU(e){if(!hG(e))throw Error("Not a valid tensor name: '"+e+"'");return(0===hB.length?"":hB.join("/")+"/")+e}function hj(e){if(!hG(e))throw Error("Not a valid tensor name: '"+e+"'");hM.has(e)||hM.set(e,0);let t=hM.get(e);if(hM.set(e,hM.get(e)+1),!(t>0))return e;{let n=`${e}_${t}`;return hM.set(n,1),n}}let hV=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function hG(e){return!!e.match(hV)}let hH=a4({eye_:function(e,t,n,r="float32"){null==t&&(t=e);let a=sW([e,t],r),s=e<=t?e:t;for(let e=0;e<s;++e)a.set(1,e,e);let i=iy(a.toTensor(),[e,t]);if(null==n)return i;if(1===n.length)return oa(lX(i,0),[n[0],1,1]);if(2===n.length)return oa(lX(lX(i,0),0),[n[0],n[1],1,1]);if(3===n.length)return oa(lX(lX(lX(i,0),0),0),[n[0],n[1],n[2],1,1]);throw Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}}),hq=a4({fusedConv2d_:function({x:e,filter:t,strides:n,pad:r,dataFormat:a="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:h}){let p,d;if(l=l||"linear",!1===o6(aH.state.gradientDepth,l)){te("NHWC"===a,()=>`Error in fused conv2d: got dataFormat of ${a} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let p=iq(e,t,n,r,a,s,i);return null!=o&&(p=sG(p,o)),o5(p,l,u,h)}let c=a1(e,"x","conv2d","float32"),f=a1(t,"filter","conv2d","float32"),m=c,g=!1;3===c.rank&&(g=!0,m=iy(c,[1,c.shape[0],c.shape[1],c.shape[2]])),te(4===m.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${m.rank}.`),te(4===f.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${f.rank}.`),i_("fused conv2d",r,i);let y="NHWC"===a?m.shape[3]:m.shape[1];te(f.shape[2]===y,()=>`Error in conv2d: depth of input (${y}) must match input depth for filter ${f.shape[2]}.`),te(iA(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`);let x=ik(m.shape,f.shape,n,s,r,i);if(null!=o&&(p=a1(o,"bias","fused conv2d"),[p]=az(p,c),"NHWC"===a?io(x.outShape,p.shape):(te(p.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${p.shape.length}.`),te(0===p.shape.length||p.shape[0]===x.outChannels||1===p.shape[0],()=>`Error in fused conv2d: bias shape (${p.shape}) is not compatible with the number of output channels (${x.outChannels})`))),null!=u){let e=u.shape;if(te(e.length<=1||3===e.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`),1===e.length)te(1===e[0]||e[0]===x.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${x.outChannels}).`);else if(3===e.length)try{io(e,x.outShape)}catch(t){throw Error(`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${x.outShape}).`)}d=a1(u,"prelu weights","fused conv2d")}let b=(e,t)=>{te("NHWC"===a,()=>`Error in gradient of fused conv2D: got dataFormat of ${a} but only NHWC is currently supported.`);let[i,o,u,h]=t,p=o3(e,u,l);te(iE(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let d=[iH(o.shape,p,i,n,r),iG(o,p,i.shape,n,r)];if(null!=h){let e=o4(h,p);d.push(e)}return d},w={x:m,filter:f,bias:p,preluActivationWeights:d},v={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:h};return null==o?sJ((e,t,n)=>{let r=aH.runKernel(aa,w,v);return n([t,e,r]),g&&(r=iy(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:b}})(m,f):sJ((e,t,n,r)=>{let a=aH.runKernel(aa,w,v);return r([t,e,a,n]),g&&(a=iy(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:b}})(m,f,p)}}),hK=a4({fusedDepthwiseConv2d_:function({x:e,filter:t,strides:n,pad:r,dataFormat:a="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:h}){let p,d;if(!1===o6(aH.state.gradientDepth,l)){let p=us(e,t,n,r,a,s,i);return null!=o&&(p=sG(p,o)),o5(p,l,u,h)}let c=a1(e,"x","depthwiseConv2d","float32"),f=a1(t,"filter","depthwiseConv2d","float32"),m=c,g=!1;3===c.rank&&(g=!0,m=iy(c,[1,c.shape[0],c.shape[1],c.shape[2]])),te(4===m.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${m.rank}.`),te(4===f.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${f.rank}.`),te(m.shape[3]===f.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${m.shape[3]}) must match the inChannels dimension in filter ${f.shape[2]}.`),null==s&&(s=[1,1]),te(iA(n,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),i_("fused depthwiseConv2d",r,i);let y=ik(m.shape,f.shape,n,s,r,i,!0);null!=o&&(p=a1(o,"bias","fused conv2d"),[p]=az(p,c),io(y.outShape,p.shape)),null!=u&&(d=a1(u,"prelu weights","fused depthwiseConv2d"));let x=(e,t)=>{te(iE(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[a,o,u,h]=t,d=o3(e,u,l),c=ot(o.shape,d,a,n,r,s,i),f=oe(o,d,a.shape,n,r,s,i);return null!=h?[c,f,o4(p,d)]:[c,f]},b={x:m,filter:f,bias:p,preluActivationWeights:d},w={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:h};return null==o?sJ((e,t,n)=>{let r=aH.runKernel(as,b,w);return n([t,e,r]),g&&(r=iy(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}})(m,f):sJ((e,t,n,r)=>{let a=aH.runKernel(as,b,w);return r([t,e,a,n]),g&&(a=iy(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:x}})(m,f,p)}}),hX=a4({fusedMatMul_:function({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:a,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){let l,u;if(!1===o6(aH.state.gradientDepth,s)){let l=iM(e,t,n,r);return null!=a&&(l=sG(l,a)),o5(l,s,i,o)}let h=a1(e,"a","fused matMul"),p=a1(t,"b","fused matMul");[h,p]=az(h,p);let d=n?h.shape[h.rank-2]:h.shape[h.rank-1],c=r?p.shape[p.rank-1]:p.shape[p.rank-2],f=n?h.shape[h.rank-1]:h.shape[h.rank-2],m=r?p.shape[p.rank-2]:p.shape[p.rank-1],g=h.shape.slice(0,-2),y=p.shape.slice(0,-2),x=tr(g),b=tr(y);te(d===c,()=>`Error in fused matMul: inner shapes (${d}) and (${c}) of Tensors with shapes ${h.shape} and ${p.shape} and transposeA=${n} and transposeB=${r} must match.`);let w=io(h.shape.slice(0,-2),p.shape.slice(0,-2)).concat([f,m]),v=n?iy(h,[x,d,f]):iy(h,[x,f,d]),k=r?iy(p,[b,m,c]):iy(p,[b,c,m]);null!=a&&(l=a1(a,"bias","fused matMul"),[l]=az(l,h),io(w,l.shape)),null!=i&&(u=a1(i,"prelu weights","fused matMul"));let N=(e,t)=>{let i,o,[l,u,h,p]=t,d=o3(iy(e,h.shape),h,s);return(n||r?!n&&r?(i=iM(d,u,!1,!1),o=iM(d,l,!0,!1)):n&&!r?(i=iM(u,d,!1,!0),o=iM(l,d,!1,!1)):(i=iM(u,d,!0,!0),o=iM(d,l,!0,!0)):(i=iM(d,u,!1,!0),o=iM(l,d,!0,!1)),null!=a)?[i,o,o4(p,d)]:[i,o]},I={a:v,b:k,bias:l,preluActivationWeights:u},S={transposeA:n,transposeB:r,activation:s,leakyreluAlpha:o};return null==a?sJ((e,t,n)=>{let r=aH.runKernel(ar,I,S);return n([e,t,r]),{value:iy(r,w),gradFunc:N}})(v,k):sJ((e,t,n,r)=>{let a=aH.runKernel(ar,I,S);return r([e,t,a,n]),{value:iy(a,w),gradFunc:N}})(v,k,l)}});e.s([],9428),e.i(9428),e.s(["conv2d",0,hq,"depthwiseConv2d",0,hK,"matMul",0,hX],32616);var hY=e.i(32616);function hZ(e,t){tn(e);let n=aQ(e,t);if(1!==n.length)throw Error("tensor1d() requires values to be a flat/TypedArray");return a6(e,null,n,t)}function hJ(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function hQ(e,t,n){let r=1-e%2,a=new Float32Array(e);for(let s=0;s<e;++s){let i=2*Math.PI*s/(e+r-1);a[s]=t-n*Math.cos(i)}return hZ(a,"float32")}e.s(["cosineWindow",()=>hQ,"enclosingPowerOfTwo",()=>hJ],52616);let h0=a4({hammingWindow_:function(e){return hQ(e,.54,.46)}}),h1=a4({hannWindow_:function(e){return hQ(e,.5,.5)}});function h2(e,t,n){if(tn(e),null!=t&&2!==t.length)throw Error("tensor2d() requires shape to have two numbers");let r=aQ(e,n);if(2!==r.length&&1!==r.length)throw Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return a6(e,t,r,n)}let h3=a4({frame_:function(e,t,n,r=!1,a=0){let s=0,i=[];for(;s+t<=e.size;)i.push(ob(e,s,t)),s+=n;if(r)for(;s<e.size;){let r=s+t-e.size,o=lq([ob(e,s,t-r),s7([r],a)]);i.push(o),s+=n}return 0===i.length?h2([],[0,t]):iy(lq(i),[i.length,t])}}),h4=a4({stft_:function(e,t,n,r,a=h1){return null==r&&(r=hJ(t)),uU(sK(h3(e,t,n),a(t)),r)}}),h5=a4({cropAndResize_:function(e,t,n,r,a="bilinear",s=0){let i=a1(e,"image","cropAndResize"),o=a1(t,"boxes","cropAndResize","float32"),l=a1(n,"boxInd","cropAndResize","int32"),u=o.shape[0];return te(4===i.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),te(2===o.rank&&4===o.shape[1],()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`),te(1===l.rank&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`),te(2===r.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),te(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),te("bilinear"===a||"nearest"===a,()=>`method must be bilinear or nearest, but was ${a}`),aH.runKernel(nm,{image:i,boxes:o,boxInd:l},{method:a,extrapolationValue:s,cropSize:r})}}),h6=a4({flipLeftRight_:function(e){let t=a1(e,"image","flipLeftRight","float32");return te(4===t.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`),aH.runKernel(n_,{image:t},{})}}),h8=a4({grayscaleToRGB_:function(e){let t=a1(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];te(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),te(1===r,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);let a=Array(t.rank);return a.fill(1,0,n),a[n]=3,oa(t,a)}}),h7=a4({einsum_:function(e,...t){let n=t.map((e,t)=>a1(e,`tensors${t}`,"einsum"));return aH.runKernel(nT,n,{equation:e})}}),h9=a4({rgbToGrayscale_:function(e){let t,n=a1(e,"image","RGBToGrayscale"),r=n.rank-1,a=n.shape[r];te(n.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${n.rank}.`),te(3===a,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${a}.`);let s=n.dtype,i=sU(n,"float32"),o=hZ([.2989,.587,.114]);switch(n.rank){case 2:t=h7("ij,j->i",i,o);break;case 3:t=h7("ijk,k->ij",i,o);break;case 4:t=h7("ijkl,l->ijk",i,o);break;case 5:t=h7("ijklm,m->ijkl",i,o);break;case 6:t=h7("ijklmn,n->ijklm",i,o);break;default:throw Error("Not a valid tensor rank.")}return sU(t=lX(t,-1),s)}}),pe=a4({rotateWithOffset_:function(e,t,n=0,r=.5){let a=a1(e,"image","rotateWithOffset","float32");return te(4===a.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${a.rank}.`),aH.runKernel(an,{image:a},{radians:t,fillValue:n,center:r})}});function pt(e,t,n,r,a,s){null==r&&(r=.5),null==a&&(a=-1/0),null==s&&(s=0);let i=e.shape[0];return n=Math.min(n,i),te(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),te(2===e.rank,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),te(4===e.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),te(1===t.rank,()=>"scores must be a 1D tensor"),te(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),te(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s}}let pn=a4({nonMaxSuppression_:function(e,t,n,r=.5,a=-1/0){let s=a1(e,"boxes","nonMaxSuppression","float32"),i=a1(t,"scores","nonMaxSuppression","float32"),o=pt(s,i,n,r,a);n=o.maxOutputSize;let l={maxOutputSize:n,iouThreshold:r=o.iouThreshold,scoreThreshold:a=o.scoreThreshold};return aH.runKernel(ra,{boxes:s,scores:i},l)}});function pr(e,t){return e>t?1:e<t?-1:0}function pa(e,t,n,r,a){return po(e,t,n,r,a,0)}function ps(e,t,n,r,a,s){return po(e,t,n,r,a,0,!1,s,!0)}function pi(e,t,n,r,a,s){return po(e,t,n,r,a,s,!0)}function po(e,t,n,r,a,s,i=!1,o=!1,l=!1){let u=[];for(let e=0;e<t.length;e++)t[e]>a&&u.push({score:t[e],boxIndex:e,suppressBeginIndex:0});u.sort(pl);let h=s>0?-.5/s:0,p=[],d=[];for(;p.length<n&&u.length>0;){let t=u.pop(),{score:n,boxIndex:s,suppressBeginIndex:i}=t;if(n<a)break;let o=!1;for(let n=p.length-1;n>=i;--n){let i=function(e,t,n){let r=e.subarray(4*t,4*t+4),a=e.subarray(4*n,4*n+4),s=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(a[0],a[2]),h=Math.min(a[1],a[3]),p=Math.max(a[0],a[2]),d=Math.max(a[1],a[3]),c=(o-s)*(l-i),f=(p-u)*(d-h);if(c<=0||f<=0)return 0;let m=Math.max(Math.min(o,p)-Math.max(s,u),0)*Math.max(Math.min(l,d)-Math.max(i,h),0);return m/(c+f-m)}(e,s,p[n]);if(i>=r){o=!0;break}if(t.score=t.score*function(e,t,n){let r=Math.exp(t*n*n);return n<=e?r:0}(r,h,i),t.score<=a)break}t.suppressBeginIndex=p.length,!o&&(t.score===n?(p.push(s),d.push(t.score)):t.score>a&&function(e,t,n){let r=function(e,t,n){let r=0,a=e.length,s=0,i=!1;for(;r<a;){let o=n(t,e[s=r+(a-r>>>1)]);o>0?r=s+1:(a=s,i=!o)}return i?r:-r-1}(e,t,n||pr);e.splice(r<0?-(r+1):r,0,t)}(u,t,pl))}let c=p.length,f=n-c;o&&f>0&&(p.push(...Array(f).fill(0)),d.push(...Array(f).fill(0)));let m={selectedIndices:p};return i&&(m.selectedScores=d),l&&(m.validOutputs=c),m}function pl(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}async function pu(e,t,n,r=.5,a=-1/0){let s=a1(e,"boxes","nonMaxSuppressionAsync"),i=a1(t,"scores","nonMaxSuppressionAsync"),o=pt(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;let l=await Promise.all([s.data(),i.data()]),{selectedIndices:u}=pa(l[0],l[1],n,r,a);return s!==e&&s.dispose(),i!==t&&i.dispose(),hZ(u,"int32")}let ph=a4({nonMaxSuppressionWithScore_:function(e,t,n,r=.5,a=-1/0,s=0){let i=a1(e,"boxes","nonMaxSuppression"),o=a1(t,"scores","nonMaxSuppression"),l=pt(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold;let u={maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s=l.softNmsSigma},h=aH.runKernel(ri,{boxes:i,scores:o},u);return{selectedIndices:h[0],selectedScores:h[1]}}});async function pp(e,t,n,r=.5,a=-1/0,s=0){let i=a1(e,"boxes","nonMaxSuppressionAsync"),o=a1(t,"scores","nonMaxSuppressionAsync"),l=pt(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;let u=await Promise.all([i.data(),o.data()]),{selectedIndices:h,selectedScores:p}=pi(u[0],u[1],n,r,a,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:hZ(h,"int32"),selectedScores:hZ(p)}}let pd=a4({nonMaxSuppressionPadded_:function(e,t,n,r=.5,a=-1/0,s=!1){let i=a1(e,"boxes","nonMaxSuppression"),o=a1(t,"scores","nonMaxSuppression"),l=pt(i,o,n,r,a,null),u=l.maxOutputSize,h=l.iouThreshold,p=l.scoreThreshold,d=aH.runKernel(rs,{boxes:i,scores:o},{maxOutputSize:u,iouThreshold:h,scoreThreshold:p,padToMaxOutputSize:s});return{selectedIndices:d[0],validOutputs:d[1]}}});async function pc(e,t,n,r=.5,a=-1/0,s=!1){let i=a1(e,"boxes","nonMaxSuppressionAsync"),o=a1(t,"scores","nonMaxSuppressionAsync"),l=pt(i,o,n,r,a,null),u=l.maxOutputSize,h=l.iouThreshold,p=l.scoreThreshold,[d,c]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=ps(d,c,u,h,p,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:hZ(f,"int32"),validOutputs:sQ(m,"int32")}}let pf=a4({bincount_:function(e,t,n){let r=a1(e,"x","bincount"),a=a1(t,"weights","bincount");return te("int32"===r.dtype,()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),te(n>=0,()=>`size must be non-negative, but got ${n}.`),te(a.size===r.size||0===a.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${a.shape}.`),aH.runKernel(t8,{x:r,weights:a},{size:n})}});function pm(e,t,n=1,r="float32"){if(0===n)throw Error("Cannot have a step of zero");return aH.runKernel(rg,{},{start:e,stop:t,step:n,dtype:r})}let pg=a4({threshold_:function(e,t="binary",n=!1,r=.5){let a,s,i,o,l=a1(e,"image","threshold"),u=l.shape[0]*l.shape[1],h=sK(hZ([r]),255);if(te(3===l.rank,()=>`Error in threshold: image must be rank 3,but got rank ${l.rank}.`),te(3===l.shape[2]||1===l.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${l.shape[2]}.`),te("int32"===l.dtype||"float32"===l.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${l.dtype}.`),te("otsu"===t||"binary"===t,()=>`Method must be binary or otsu, but was ${t}`),3===l.shape[2]){[a,s,i]=iV(l,[1,1,1],-1);let e=sK(a,.2989),t=sK(s,.587),n=sK(i,.114);o=sG(sG(e,t),n)}else o=e;return"otsu"===t&&(h=function(e,t){let n,r,a,s,i,o,l=hZ([-1]),u=hZ([0]),h=hZ([0]);for(let p=0;p<e.size-1;p++){n=ob(e,0,p+1),r=ob(e,p+1),i=sq(ix(n),t),o=sq(ix(r),t),a=sq(ix(sK(n,pm(0,n.size))),ix(n));let d=s7(r.shape,n.size),c=sG(pm(0,r.size),d),f=it(a,s=sq(ix(sK(r,c)),ix(r))),m=it(a,s),g=sK(i,o),y=ou(h=sK(sK(g,f),m),u);u=iU(y,h,u),l=iU(y,hZ([p]),l)}return l}(pf(sU(uj(o),"int32"),a8([]),256),u)),sU(sK(n?iP(o,h):ou(o,h),255),"int32")}}),py=a4({transform_:function(e,t,n="nearest",r="constant",a=0,s){let i=a1(e,"image","transform","float32"),o=a1(t,"transforms","transform","float32");return te(4===i.rank,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),te(2===o.rank&&(o.shape[0]===i.shape[0]||1===o.shape[0])&&8===o.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),te(null==s||2===s.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`),aH.runKernel(r4,{image:i,transforms:o},{interpolation:n,fillMode:r,fillValue:a,outputShape:s})}}),px=a4({bandPart_:function(e,t,n){let r,a,s=a1(e,"a","bandPart");te(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);let i=s.shape,[o,l]=s.shape.slice(-2);"number"==typeof t?(te(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),te(t<=o,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${o}).`),r=a1(t<0?o:t,"numLower","bandPart")):(te("int32"===t.dtype,()=>"bandPart(): numLower's dtype must be an int32."),r=iU(of(t,0),o,uR(t,o))),"number"==typeof n?(te(n%1==0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),te(n<=l,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${l}).`),a=a1(n<0?l:n,"numUpper","bandPart")):(te("int32"===n.dtype,()=>"bandPart(): numUpper's dtype must be an int32."),a=iU(of(n,0),l,uR(n,l)));let u=it(iy(pm(0,o,1,"int32"),[-1,1]),pm(0,l,1,"int32")),h=iB(iP(u,r),iz(u,ig(a))),p=oy([o,l],s.dtype);return iy(os(ov(iy(s,[-1,o,l])).map(e=>iU(h,e,p))),i)}}),pb=a4({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,te(null!=e&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let n=e[0].shape[0];for(let t=1;t<e.length;++t)te(e[t].shape[0]===n,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`)}else t=!0,e=iV(e,e.shape[0],0).map(e=>uX(e,[0]));te(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);let n=[],r=e;for(let t=0;t<e.length;++t)n.push(aH.tidy(()=>{let e=r[t];if(t>0)for(let r=0;r<t;++r){let t=sK(ix(sK(n[r],e)),n[r]);e=it(e,t)}return sq(e,ud(e,"euclidean"))}));return t?os(n,0):n}});function pw(e,t=!1){return aH.tidy(()=>{te(2===e.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);let n=e.shape[0],r=e.shape[1],a=hH(n),s=sj(e),i=h2([[1]],[1,1]),o=sj(i),l=n>=r?r:n;for(let e=0;e<l;++e){let t=s,l=o,u=a;[o,s,a]=aH.tidy(()=>{let t=ob(s,[e,e],[n-e,1]),l=ud(t),u=ob(s,[e,e],[1,1]),h=iU(ou(u,0),h2([[-1]]),h2([[1]])),p=it(u,sK(h,l)),d=sq(t,p);o=1===d.shape[0]?sj(i):lq([i,ob(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);let c=ig(sq(iM(h,p),l)),f=ob(s,[e,0],[n-e,r]),m=sK(c,o),g=i9(o);if(0===e)s=it(f,iM(m,iM(g,f)));else{let t=it(f,iM(m,iM(g,f)));s=lq([ob(s,[0,0],[e,r]),t],0)}let y=i9(m),x=ob(a,[0,e],[n,a.shape[1]-e]);if(0===e)a=it(x,iM(iM(x,o),y));else{let t=it(x,iM(iM(x,o),y));a=lq([ob(a,[0,0],[n,e]),t],1)}return[o,s,a]}),sn([t,l,u])}return!t&&n>r&&(a=ob(a,[0,0],[n,r]),s=ob(s,[0,0],[r,r])),[a,s]})}let pv=a4({qr_:function(e,t=!1){if(te(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),2===e.rank)return pw(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce((e,t)=>e*t),r=ov(iy(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),a=[],s=[];return r.forEach(e=>{let[n,r]=pw(e,t);a.push(n),s.push(r)}),[iy(os(a,0),e.shape),iy(os(s,0),e.shape)]}}});(m=R||(R={}))[m.NONE=0]="NONE",m[m.MEAN=1]="MEAN",m[m.SUM=2]="SUM",m[m.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS";let pk=a4({computeWeightedLoss_:function(e,t,n=R.SUM_BY_NONZERO_WEIGHTS){let r=a1(e,"losses","computeWeightedLoss"),a=null;null!=t&&(a=a1(t,"weights","computeWeightedLoss"));let s=null==a?r:sK(r,a);if(n===R.NONE)return s;if(n===R.SUM)return ix(s);if(n===R.MEAN)if(null==a)return uA(s);else{let e=r.size/a.size,t=sq(ix(s),ix(a));return e>1?sq(t,sQ(e)):t}if(n===R.SUM_BY_NONZERO_WEIGHTS)if(null==a)return sq(ix(s),sQ(r.size));else{let e=sU(ix(uD(sK(a,ox(r.shape)),sQ(0))),"float32");return sq(ix(s),e)}throw Error(`Unknown reduction: ${n}`)}}),pN=a4({absoluteDifference_:function(e,t,n,r=R.SUM_BY_NONZERO_WEIGHTS){let a=a1(e,"labels","absoluteDifference"),s=a1(t,"predictions","absoluteDifference"),i=null;return null!=n&&(i=a1(n,"weights","absoluteDifference")),tt(a.shape,s.shape,"Error in absoluteDifference: "),pk(ia(it(a,s)),i,r)}}),pI=a4({cosineDistance_:function(e,t,n,r,a=R.SUM_BY_NONZERO_WEIGHTS){let s=a1(e,"labels","cosineDistance"),i=a1(t,"predictions","cosineDistance"),o=null;return null!=r&&(o=a1(r,"weights","cosineDistance")),tt(s.shape,i.shape,"Error in cosineDistance: "),pk(it(sQ(1),ix(sK(s,i),n,!0)),o,a)}}),pS=a4({hingeLoss_:function(e,t,n,r=R.SUM_BY_NONZERO_WEIGHTS){let a=a1(e,"labels","hingeLoss"),s=a1(t,"predictions","hingeLoss"),i=null;null!=n&&(i=a1(n,"weights","hingeLoss")),tt(a.shape,s.shape,"Error in hingeLoss: ");let o=sQ(1);return a=it(sK(sQ(2),a),o),pk(o0(it(o,sK(a,s))),i,r)}}),pC=a4({huberLoss_:function(e,t,n,r=1,a=R.SUM_BY_NONZERO_WEIGHTS){let s=a1(e,"labels","huberLoss"),i=a1(t,"predictions","huberLoss"),o=null;null!=n&&(o=a1(n,"weights","huberLoss")),tt(s.shape,i.shape,"Error in huberLoss: ");let l=sQ(r),u=ia(it(i,s)),h=uR(u,l),p=it(u,h);return pk(sG(sK(sQ(.5),sY(h)),sK(l,p)),o,a)}}),pT=a4({logLoss_:function(e,t,n,r=1e-7,a=R.SUM_BY_NONZERO_WEIGHTS){let s=a1(e,"labels","logLoss"),i=a1(t,"predictions","logLoss"),o=null;null!=n&&(o=a1(n,"weights","logLoss")),tt(s.shape,i.shape,"Error in logLoss: ");let l=sQ(1),u=sQ(r),h=ig(sK(s,oN(sG(i,u)))),p=sK(it(l,s),oN(sG(it(l,i),u)));return pk(it(h,p),o,a)}}),p$=a4({meanSquaredError_:function(e,t,n,r=R.SUM_BY_NONZERO_WEIGHTS){let a=a1(e,"labels","meanSquaredError"),s=a1(t,"predictions","meanSquaredError"),i=null;return null!=n&&(i=a1(n,"weights","meanSquaredError")),tt(a.shape,s.shape,"Error in meanSquaredError: "),pk(uK(a,s),i,r)}}),pE=a4({sigmoidCrossEntropy_:function(e,t,n,r=0,a=R.SUM_BY_NONZERO_WEIGHTS){let s,i,o,l,u,h=a1(e,"multiClassLabels","sigmoidCrossEntropy"),p=a1(t,"logits","sigmoidCrossEntropy"),d=null;if(null!=n&&(d=a1(n,"weights","sigmoidCrossEntropy")),tt(h.shape,p.shape,"Error in sigmoidCrossEntropy: "),r>0){let e=sQ(r),t=sQ(1),n=sQ(.5);h=sG(sK(h,it(t,e)),sK(n,e))}return pk((s=a1(h,"labels","sigmoidCrossEntropyWithLogits"),i=a1(p,"logits","sigmoidCrossEntropyWithLogits"),tt(s.shape,i.shape,"Error in sigmoidCrossEntropyWithLogits: "),o=o0(i),l=sK(i,s),u=uC(on(ig(ia(i)))),sG(it(o,l),u)),d,a)}}),pA=a4({softmaxCrossEntropy_:function(e,t,n,r=0,a=R.SUM_BY_NONZERO_WEIGHTS){let s=a1(e,"onehotLabels","softmaxCrossEntropy"),i=a1(t,"logits","softmaxCrossEntropy"),o=null;if(null!=n&&(o=a1(n,"weights","softmaxCrossEntropy")),tt(s.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){let e=sQ(r),t=sQ(1),n=sQ(s.shape[1]);s=sG(sK(s,it(t,e)),sq(e,n))}return pk(function(e,t,n=-1){if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return sJ((e,t,r)=>{let a=uS(t,[n],!0),s=it(sU(t,"float32"),a);return r([e,s]),{value:ix(ig(sK(s,e)),[n]),gradFunc:(e,t)=>{let[r,a]=t,s=i1(e.shape,[n]);return[sK(iy(e,s),it(sU(r,"float32"),on(a))),sK(iy(e,s),it(on(a),sU(r,"float32")))]}}})(e,t)}(s,i),o,a)}}),pR=a4({sparseFillEmptyRows_:function(e,t,n,r){let a=a1(e,"indices","sparseFillEmptyRows","int32"),s=a1(t,"values","sparseFillEmptyRows"),i=a1(n,"denseShape","sparseFillEmptyRows","int32"),o=a1(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==a.rank)throw Error(`Indices should be Tensor2D but received shape
        ${a.shape}`);if(1!==s.rank)throw Error(`Values should be Tensor1D but received shape ${s.shape}`);if(1!==i.rank)throw Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==o.rank)throw Error(`Default value should be a scalar but received shape ${o.shape}`);let l=aH.runKernel(rj,{indices:a,values:s,denseShape:i,defaultValue:o});return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}}),pF=a4({sparseReshape_:function(e,t,n){let r=a1(e,"inputIndices","sparseReshape","int32"),a=a1(t,"inputShape","sparseReshape","int32"),s=a1(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(1!==a.rank)throw Error(`Input shape should be Tensor1D but received shape ${a.shape}`);if(1!==s.rank)throw Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i=aH.runKernel(rV,{inputIndices:r,inputShape:a,newShape:s});return{outputIndices:i[0],outputShape:i[1]}}}),p_=a4({sparseSegmentMean_:function(e,t,n){let r=a1(e,"data","sparseSegmentMean"),a=a1(t,"indices","sparseSegmentMean","int32"),s=a1(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw Error(`Indices should be Tensor1D but received shape
          ${a.shape}`);if(1!==s.rank)throw Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);return aH.runKernel(rG,{data:r,indices:a,segmentIds:s})}}),pD=a4({sparseSegmentSum_:function(e,t,n){let r=a1(e,"data","sparseSegmentSum"),a=a1(t,"indices","sparseSegmentSum","int32"),s=a1(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw Error(`Indices should be Tensor1D but received shape
         ${a.shape}`);if(1!==s.rank)throw Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);return aH.runKernel(rH,{data:r,indices:a,segmentIds:s})}}),pO=a4({stringNGrams_:function(e,t,n,r,a,s,i,o){let l=a1(e,"data","stringNGrams","string");if("string"!==l.dtype)throw Error("Data must be of datatype string");if(1!==l.shape.length)throw Error(`Data must be a vector, saw: ${l.shape}`);let u=a1(t,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw Error("Data splits must be of datatype int32");let h=aH.runKernel(rJ,{data:l,dataSplits:u},{separator:n,nGramWidths:r,leftPad:a,rightPad:s,padWidth:i,preserveShortSequences:o});return{nGrams:h[0],nGramsSplits:h[1]}}}),pM=a4({stringSplit_:function(e,t,n=!0){let r=a1(e,"input","stringSplit","string"),a=a1(t,"delimiter","stringSplit","string");if(1!==r.rank)throw Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==a.rank)throw Error(`Delimiter should be a scalar but received shape ${a.shape}`);let s=aH.runKernel(rQ,{input:r,delimiter:a},{skipEmpty:n});return{indices:s[0],values:s[1],shape:s[2]}}}),pL=a4({stringToHashBucketFast_:function(e,t){let n=a1(e,"input","stringToHashBucketFast","string");if(t<=0)throw Error("Number of buckets must be at least 1");return aH.runKernel(r0,{input:n},{numBuckets:t})}}),pz=a4({staticRegexReplace_:function(e,t,n,r=!0){let a=a1(e,"input","staticRegexReplace","string");return aH.runKernel(rY,{x:a},{pattern:t,rewrite:n,replaceGlobal:r})}}),pP={fft:um,ifft:ug,rfft:uU,irfft:uy},pB={hammingWindow:h0,hannWindow:h1,frame:h3,stft:h4},pW={flipLeftRight:h6,grayscaleToRGB:h8,resizeNearestNeighbor:uW,resizeBilinear:uB,rgbToGrayscale:h9,rotateWithOffset:pe,cropAndResize:h5,nonMaxSuppression:pn,nonMaxSuppressionAsync:pu,nonMaxSuppressionWithScore:ph,nonMaxSuppressionWithScoreAsync:pp,nonMaxSuppressionPadded:pd,nonMaxSuppressionPaddedAsync:pc,threshold:pg,transform:py},pU={bandPart:px,gramSchmidt:pb,qr:pv},pj={absoluteDifference:pN,computeWeightedLoss:pk,cosineDistance:pI,hingeLoss:pS,huberLoss:pC,logLoss:pT,meanSquaredError:p$,sigmoidCrossEntropy:pE,softmaxCrossEntropy:pA},pV={sparseFillEmptyRows:pR,sparseReshape:pF,sparseSegmentMean:p_,sparseSegmentSum:pD},pG={stringNGrams:pO,stringSplit:pM,stringToHashBucketFast:pL,staticRegexReplace:pz};e.s(["image",()=>pW,"linalg",()=>pU,"losses",()=>pj,"signal",()=>pB,"sparse",()=>pV,"spectral",()=>pP,"string",()=>pG],27575);var pH=e.i(80586);class pq{constructor(e,t,n,r,a){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const s=a||Math.random();this.random=pH.alea(s.toString())}nextValue(){let e,t;if(!isNaN(this.nextVal)){let e=this.nextVal;return this.nextVal=NaN,e}let n=!1;for(;!n;){let r,a,s;do s=(r=2*this.random()-1)*r+(a=2*this.random()-1)*a;while(s>=1||0===s)let i=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*a*i,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class pK{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;const a=r||Math.random();this.randu=pH.alea(a.toString()),this.randn=new pq(0,1,n,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,a,s;for(;;){do r=this.randn.nextValue(),s=1+this.c*r;while(s<=0)if(s*=s*s,t=1-.331*(e=r*r)*e,n=.5*e+this.d*(1-s+Math.log(s)),(a=this.randu())<t||Math.log(a)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}class pX{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=pH.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}let pY=a4({randomUniform_:function(e,t=0,n=1,r="float32",a){tO(e);let s=sW(e,r),i=new pX(t,n,null,a);for(let e=0;e<s.values.length;e++)s.values[e]=i.nextValue();return s.toTensor()}});var hT=hT;let pZ=a4({truncatedNormal_:function(e,t=0,n=1,r,a){if(tO(e),null!=r&&"bool"===r)throw Error("Unsupported data type $ { dtype }");let s=new pq(t,n,r,!0,a),i=sW(e,r);for(let e=0;e<i.values.length;e++)i.values[e]=s.nextValue();return i.toTensor()}});var ha=ha;let pJ=a4({slice1d_:function(e,t,n){let r=a1(e,"x","slice1d");return te(1===r.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),ob(r,[t],[n])}}),pQ=a4({slice2d_:function(e,t,n){let r=a1(e,"x","slice2d");return te(2===r.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),ob(r,t,n)}}),p0=a4({slice3d_:function(e,t,n){let r=a1(e,"x","slice3d");return te(3===r.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),ob(r,t,n)}}),p1=a4({slice4d_:function(e,t,n){let r=a1(e,"x","slice4d");return te(4===r.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),ob(r,t,n)}}),p2=a4({concat1d_:function(e){return lq(e,0)}}),p3=a4({concat2d_:function(e,t){return lq(e,t)}}),p4=a4({concat3d_:function(e,t){return lq(e,t)}}),p5=a4({concat4d_:function(e,t){return lq(e,t)}}),p6=a4({randomNormal_:function(e,t=0,n=1,r,a){if(tO(e),null!=r&&"bool"===r)throw Error(`Unsupported data type ${r}`);let s=new pq(t,n,r,!1,a),i=sW(e,r);for(let e=0;e<i.values.length;e++)i.values[e]=s.nextValue();return i.toTensor()}});var p8=hY;let p7=a4({dropout_:function(e,t,n,r){let a=a1(e,"x","dropout");if(te("float32"===a.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${a.dtype} tensor instead.`),te(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),0===t)return e instanceof aA?a.clone():a;let s=function(e,t){if(null==t)return e.shape.slice();if(ti(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}(a,n),i=1-t;return sK(a,sq(ow(sG(pY(s,0,1,"float32",r),i)),i))}});function p9(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let a=t;a<n;++a)r*=e[a];return r}function de(e){if(0===e.length)return NaN;let t=1/0;for(let n=0;n<e.length;n++){let r=e[n];r<t&&(t=r)}return t}function dt(e){if(0===e.length)return NaN;let t=-1/0;for(let n=0;n<e.length;n++){let r=e[n];r>t&&(t=r)}return t}function dn(e,t){if(t<e)throw new ho(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let r=e;r<t;++r)n.push(r);return n}function dr(){return null==a&&(a=aH.backend.epsilon()),a}function da(){return"channelsLast"}e.s(["dropout",0,p7],59371);function ds(e,t=-1){let n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),iy(e,n)}function di(e,t,n){return st(()=>{switch(e.rank){case 1:return pJ(e,t,n);case 2:return pQ(e,[t,0],[n,e.shape[1]]);case 3:return p0(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return p1(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return ob(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return ob(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new ho(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function dl(e,t,n){return st(()=>{switch(e.rank){case 1:return pJ(e,t,n);case 2:return pQ(e,[0,t],[e.shape[0],n]);case 3:return p0(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return p1(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new ho(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function du(e,t,n,r){return st(()=>{switch(e.rank){case 1:return pJ(e,t,n);case 2:switch(r){case 1:return di(e,t,n);case 2:return dl(e,t,n);default:throw new ho(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return di(e,t,n);case 2:return p0(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return dl(e,t,n);default:throw new ho(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return di(e,t,n);case 2:return p1(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return p1(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return dl(e,t,n);default:throw new ho(`The axis is not within the rank of the tensor ${r}`)}default:throw new ho(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function dh(e,t=-1){let n;return t<0&&(t=0!==(n=e[0].rank)?n:0),t===e[0].rank&&(t=-1),lq(e,t)}function dp(e,t){switch(e.rank){case 1:return p2([e,t]);case 2:return p3([e,t],0);case 3:return p4([e,t],0);case 4:return p5([e,t],0);default:throw new ho(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function dd(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new ho(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return oa(e,t)}function dc(e,t=0,n=1,r,a){return p6(e,t,n,r,a)}function df(e,t,n,r){if(e.rank<2||t.rank<2)throw new hl(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3&&e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new hl(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`);if(2===e.rank&&2===t.rank)return p8.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?dg(e.rank,r,da()):null,activation:n});{let a=e.shape.slice();e=iy(e,[-1,a.pop()]);let s=t.shape.slice(),i=s.pop(),o=s.pop(),l=[...s,i],u=Array.from({length:t.rank},(e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n);t=iy(i9(t,u),[o,-1]);let h=[...a,...l];return iy(p8.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?dg(e.rank,r,da()):null,activation:n}),h)}}function dm(e,t,n){return st(()=>lY(e,t=Array.isArray(t)?hZ(t,"int32"):sU(t,"int32"),n))}function dg(e,t,n){let r=t.shape;if(1!==t.rank&&t.rank!==e)throw new ho(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)if(1===r.length)return iy(t,[1,r[0],1,1,1]);else return iy(t,[1,r[3],r[0],r[1],r[2]]);else if("channelsLast"===n)if(1===r.length)return iy(t,[1,1,1,1,r[0]]);else return iy(t,[1].concat(r))}else if(4===e){if("channelsFirst"===n)if(1===r.length)return iy(t,[1,r[0],1,1]);else return iy(t,[1,r[2],r[0],r[1]]);else if("channelsLast"===n)if(1===r.length)return iy(t,[1,1,1,r[0]]);else return iy(t,[1].concat(r))}else if(3===e){if("channelsFirst"===n)if(1===r.length)return iy(t,[1,r[0],1]);else return iy(t,[1,r[1],r[0]]);else if("channelsLast"===n)if(1===r.length)return iy(t,[1,1,r[0]]);else return iy(t,[1].concat(r))}else if(e<3)return t;throw new ho(`Unsupported input rank by biasAdd: ${t.rank}`)}function dy(e,t,n){return st(()=>(null==n&&(n=da()),hL(n),sG(e,dg(e.rank,t,n))))}function dx(e,t,n=!1){return n?e():t()}let db=["fanIn","fanOut","fanAvg"],dw=["normal","uniform","truncatedNormal"];class dv extends hT.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class dk extends dv{apply(e,t){return oy(e,t)}}dk.className="Zeros",hT.registerClass(dk);class dN extends dv{apply(e,t){return ox(e,t)}}dN.className="Ones",hT.registerClass(dN);class dI extends dv{constructor(e){if(super(),"object"!=typeof e)throw new ho(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new ho(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return st(()=>sK(sQ(this.value),ox(e,t)))}getConfig(){return{value:this.value}}}dI.className="Constant",hT.registerClass(dI);class dS extends dv{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return pY(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}dS.className="RandomUniform",hT.registerClass(dS);class dC extends dv{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new hl(`randomNormal does not support dType ${t}.`);return dc(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}dC.className="RandomNormal",hT.registerClass(dC);class dT extends dv{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new hl(`truncatedNormal does not support dType ${t}.`);return pZ(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}dT.className="TruncatedNormal",hT.registerClass(dT);class d$ extends dv{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return st(()=>{if(2===e.length&&e[0]===e[1])return sK(this.gain,hH(e[0]));throw new ho("Identity matrix initializer can only be used for 2D square matrices.")})}getConfig(){return{gain:this.gain}}}d$.className="Identity",hT.registerClass(d$);class dE extends dv{constructor(e){if(super(),e.scale<0)throw new ho(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,hN(db,"FanMode",this.mode),this.distribution=null==e.distribution?"normal":e.distribution,hN(dw,"Distribution",this.distribution),this.seed=e.seed}apply(e,t){let n=function(e,t="channelsLast"){let n,r;if(hL(t),2===e.length)n=e[0],r=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===t){let t=p9(e,2);n=e[1]*t,r=e[0]*t}else if("channelsLast"===t){let t=p9(e,0,e.length-2);n=e[e.length-2]*t,r=e[e.length-1]*t}}else{let t=p9(e);n=Math.sqrt(t),r=Math.sqrt(t)}return[n,r]}(e),r=n[0],a=n[1],s=this.scale;if("fanIn"===this.mode?s/=Math.max(1,r):"fanOut"===this.mode?s/=Math.max(1,a):s/=Math.max(1,(r+a)/2),"normal"===this.distribution){let n=Math.sqrt(s);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new hl(`${this.getClassName()} does not support dType ${t}.`);return pZ(e,0,n,t,this.seed)}{let n=Math.sqrt(3*s);return pY(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}dE.className="VarianceScaling",hT.registerClass(dE);class dA extends dE{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return dE.className}}dA.className="GlorotUniform",hT.registerClass(dA);class dR extends dE{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return dE.className}}dR.className="GlorotNormal",hT.registerClass(dR);class dF extends dE{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return dE.className}}dF.className="HeNormal",hT.registerClass(dF);class d_ extends dE{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return dE.className}}d_.className="HeUniform",hT.registerClass(d_);class dD extends dE{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return dE.className}}dD.className="LeCunNormal",hT.registerClass(dD);class dO extends dE{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return dE.className}}dO.className="LeCunUniform",hT.registerClass(dO);class dM extends dv{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return st(()=>{if(e.length<2)throw new hl("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw TypeError(`Unsupported data type ${t}.`);let n=ha.sizeFromShape(e.slice(0,-1)),r=e[e.length-1],a=n*r;a>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${a}) elements: Slowness may result.`);let s=dc([Math.max(r,n),Math.min(r,n)],0,1,t,this.seed),i=pU.qr(s,!1),o=i[0];return o=sK(o,i[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]).sign()),n<r&&(o=o.transpose()),sK(sQ(this.gain),o.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}dM.className="Orthogonal",hT.registerClass(dM);let dL={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function dz(e,t={}){return hw(e,hT.SerializationMap.getMap().classNameMap,t,"initializer")}function dP(e){if("string"==typeof e){let t=e in dL?dL[e]:e;if("GlorotNormal"===t)return new dR;{if("GlorotUniform"===t)return new dA;if("HeNormal"===t)return new dF;if("HeUniform"===t)return new d_;if("LeCunNormal"===t)return new dD;if("LeCunUniform"===t)return new dO;let e={};return e.className=t,e.config={},dz(e)}}return e instanceof dv?e:dz(e)}function dB(e){return Array.isArray(e)&&Array.isArray(e[0])}function dW(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function dU(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new ho(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function dj(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))return e;if(1===e.length)return e[0];throw new ho(`Expected exactly 1 Shape; got ${e.length}`)}function dV(e){let t=0;for(let n of e)0===n.shape.length?t+=1:t+=n.shape.reduce((e,t)=>e*t);return t}function dG(e,t=!0,n,r){return aH.makeVariable(e,t,n,r)}let dH="Variable";class dq{constructor(e,t="float32",n=dH,r=!0,a=null){this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=h$++,n=null==n?dH:n,this.originalName=hU(n),this.name=hj(this.originalName),this.trainable_=r,this.constraint=a,this.val=dG(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function dK(e){return e.map(e=>e.read())}function dX(e){e.forEach(e=>{e[0].write(e[1])})}class dY{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class dZ{constructor(e,t,n,r,a,s,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=a,this.outputTensorIndex=i,this.id=h$++,null!=s&&(this.originalName=hU(s),this.name=hj(this.originalName)),this.rank=t.length}}let dJ=0;class dQ{constructor(e,t){for(const n of(this.callArgs=t,this.id=dJ++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes,e.inboundLayers))null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let d0=0;class d1 extends hT.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=d0++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=hg(e)+"_"+hA(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new hi(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new ho(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return hf(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return hf(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new hs(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new hs(`Layer ${this.name} is not connected, no input to return.`);return hf(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new hs(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new hs(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return hf(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){let t=hm(e);if(null==this.inputSpec||0===this.inputSpec.length)return;let n=hm(this.inputSpec);if(t.length!==n.length)throw new ho(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let e=0;e<t.length;e++){let r=t[e],a=n[e];if(null==a)continue;let s=r.rank;if(null!=a.ndim&&s!==a.ndim)throw new ho(`Input ${e} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${s}`);if(null!=a.maxNDim&&s>a.maxNDim)throw new ho(`Input ${e} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${s}`);if(null!=a.minNDim&&s<a.minNDim)throw new ho(`Input ${e} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${s}.`);if(null!=a.dtype&&r.dtype!==a.dtype)throw new ho(`Input ${e} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${r.dtype}.`);if(a.axes){let t=r.shape;for(let n in a.axes){let r=Number(n),s=a.axes[n],i=r>=0?t[r]:t[t.length+r];if(null!=s&&-1===[s,null].indexOf(i))throw new ho(`Input ${e} is incompatible with layer ${this.name}: expected axis ${r} of input shape to have value ${s} but got shape ${t}.`)}}if(null!=a.shape)for(let t=0;t<a.shape.length;++t){let n=a.shape[t],s=r.shape[t];if(null!=n&&null!=s&&n!==s)throw new ho(`Input ${e} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=hm(e),r=function(e){let t=!0;for(let n of hm(e))if(!(n instanceof dZ)){t=!1;break}return t}(e),a=function(e){let t=!0;for(let n of hm(e))if(n instanceof dZ){t=!1;break}return t}(e);if(r===a)throw new ho("Arguments to apply() must be all SymbolicTensors or all Tensors");return hW(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);let t=[];for(let n of hm(e))t.push(n.shape);this.build(hf(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let r=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,r);let a=hm(r),s=[];for(let e of a)-1!==n.indexOf(e)&&(e=e.clone()),s.push(e);if(r=hf(s),null!=this.activityRegularizer)throw new hl("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{let n,r=function(e){e=hm(e);let t=[];for(let n of e)t.push(n.shape);return hf(t)}(e),a=this.computeOutputShape(r),s="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?r[0]:r),n=null!=a&&a.length>0&&Array.isArray(a[0])?a.map((n,r)=>new dZ(s,n,this,hm(e),t,this.name,r)):new dZ(s,a,this,hm(e),t,this.name),this.addInboundNode(e,n,null,null,r,a,t),this._refCount++,null!=this.activityRegularizer)throw new hl("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return n}})}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new hs(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){let e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new hs(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new hi(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return dV(this.weights)}build(e){this.built=!0}getWeights(e=!1){return dK(e?this.trainableWeights:this.weights)}setWeights(e){st(()=>{let t=this.weights;if(t.length!==e.length)throw new ho(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;let n=[],r=dK(t);for(let a=0;a<r.length;++a){let s=r[a],i=t[a],o=e[a];if(!ha.arraysEqual(s.shape,o.shape))throw new ho(`Layer weight shape ${s.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}dX(n)})}addWeight(e,t,n,r,a,s,i,o){if(-1!==this._addedWeightNames.indexOf(e))throw new ho(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=o?o():dP("zeros"));let l=r.apply(t,n),u=new dq(l,n,e,s,i);return l.dispose(),null!=a&&this.addLoss(()=>a.apply(u.read())),null==s&&(s=!0),s?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=hm(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t)if(Array.isArray(t))t.forEach(e=>{if(null!=e)throw TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;let r=this.computeMask(e,n),a=hm(t),s=hm(r);if(a.length!==s.length)throw Error(`${this.name} outputs ${a.length} tensors but ${a.length} masks for those tensors`);for(let e=0;e<a.length;e++)a[e].kerasMask=s[e]}addInboundNode(e,t,n,r,a,s,i=null){let o=hm(e);t=hm(t),n=hm(n),r=hm(r),a=dW(a),s=dW(s);let l=[],u=[],h=[];for(let e of o)l.push(e.sourceLayer),u.push(e.nodeIndex),h.push(e.tensorIndex);new dQ({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:h,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:a,outputShapes:s},i);for(let e=0;e<t.length;e++)t[e].sourceLayer=this,t[e].nodeIndex=this.inboundNodes.length-1,t[e].tensorIndex=e}getConfig(){let e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0==--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}class d2 extends d1{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:hA("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new ho("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t)if(null==e.inputShape)throw new ho("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");else t=[e.batchSize].concat(e.inputShape);else if(null!=e.batchSize)throw new ho("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const r=new dZ(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new dQ({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new ho(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}function d3(e){if(null==e.batchShape&&null==e.shape)throw Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new ho("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new d2({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}d2.className="InputLayer",hT.registerClass(d2);class d4{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof d4)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null==this.id2Value[e.id])this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return sU(t,e.dtype)}catch(n){throw new ho(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n);else throw new ho(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof dZ)if(null!=this.id2Value[e.id])return this.id2Value[e.id];else throw new ho(`Nonexistent key: ${e.name}`);{let t=this.name2Id[e];if(null==t)throw new ho(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof dZ)if(null!=this.id2Value[e.id])return this.id2Mask[e.id];else throw new ho(`Nonexistent key: ${e.name}`);{let t=this.name2Id[e];if(null==t)throw new ho(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&sn(this.id2Mask)}}let d5=new hh,d6=new hh;function d8(e,t,n,r){let a,s=null!=n&&n.training,i=Array.isArray(e),o=i?e:[e],l=o.map(e=>e.name),u=[],h=t.names();for(let e of l)-1!==h.indexOf(e)?u.push(t.getValue(e)):u.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);let p=l.join(",")+"|"+t.names().sort().join(","),d=d5.get(p);if(null==d){let e=function(e,t){ha.assert(null!=e&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],r={};if(1===e.length){let a=d7(e[0],t);n=a.sorted,r=a.recipientMap}else{let a=new Set;for(let s of e){let{sorted:e,recipientMap:i}=d7(s,t);for(let t of e)a.has(t.name)||(n.push(t),a.add(t.name));for(let e in i)null==r[e]&&(r[e]=new Set),i[e].forEach(t=>r[e].add(t))}}return{sorted:n,recipientCounts:function(e){let t={};for(let n in e)t[n]=e[n].size;return t}(r)}}(o,t);d=e.sorted,a=e.recipientCounts,d5.put(p,d),d6.put(p,a)}a={},s||Object.assign(a,d6.get(p));let c=new d4(t);for(let e=0;e<d.length;++e){if(null!=r){let e=se().numTensors;e>r.maxNumTensors&&(r.maxNumTensors=e),e<r.minNumTensors&&(r.minNumTensors=e)}let i=d[e],o=i.sourceLayer;if(o instanceof d2)continue;let h=[],p=[],f=[],m=!1;for(let e of i.inputs){let n=c.getValue(e),r=c.getMask(e);h.push(n),p.push(r),null!=r&&(m=!0),!s&&(a[e.name]--,0!==a[e.name]||t.hasKey(e)||-1!==l.indexOf(e.name)||n.isDisposed||!0===e.sourceLayer.stateful||f.push(n))}m&&((n=n||{}).mask=p[0]);let g=hm(o.apply(h,n)),y=null;o.supportsMasking&&(y=o.computeMask(h,p));let x=function(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(let r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}(i),b=Array.isArray(x)?x:[x];for(let e=0;e<b.length;++e){c.hasKey(b[e])||c.add(b[e],g[e],Array.isArray(y)?y[0]:y);let t=l.indexOf(b[e].name);-1!==t&&(u[t]=g[e])}s||sn(f)}return c.disposeMasks(),i?u:u[0]}function d7(e,t){let n=new Set,r=[],a={};for(let e of t.names())n.add(e);let s=[],i=[];for(s.push(e);s.length>0;){let e=s[s.length-1];if(n.has(e.name)){s.pop();continue}let t=i[i.length-1]===s.length-1;if(0===e.inputs.length||t)s.pop(),r.push(e),n.add(e.name),t&&i.pop();else for(let t of(i.push(s.length-1),e.inputs))null==a[t.name]&&(a[t.name]=new Set),a[t.name].add(e.name),n.has(t.name)||s.push(t)}return{sorted:r,recipientMap:a}}tU.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,function(e){null!=d5&&d5.setMaxEntries(e),null!=d6&&d6.setMaxEntries(e)});var hT=hT;function d9(e,t){return st(()=>sX(ix(sK(e,e),t,!0)))}class ce extends hT.Serializable{getConfig(){return{}}}class ct extends ce{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return st(()=>{let t=d9(e,this.axis);return sK(e,sq(ut(t,0,this.maxValue),sG(dr(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}ct.className="MaxNorm",hT.registerClass(ct);class cn extends ce{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return st(()=>sq(e,sG(dr(),d9(e,this.axis))))}getConfig(){return{axis:this.axis}}}cn.className="UnitNorm",hT.registerClass(cn);class cr extends ce{apply(e){return o0(e)}}cr.className="NonNeg",hT.registerClass(cr);class ca extends ce{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return st(()=>{let t=d9(e,this.axis),n=sG(sK(this.rate,ut(t,this.minValue,this.maxValue)),sK(1-this.rate,t));return sK(e,sq(n,sG(dr(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}ca.className="MinMaxNorm",hT.registerClass(ca);let cs={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function ci(e,t={}){return hw(e,hT.SerializationMap.getMap().classNameMap,t,"constraint")}function co(e){return null==e?null:"string"==typeof e?ci({className:e in cs?cs[e]:e,config:{}}):e instanceof ce?e:ci(e)}function cl(e){return new ct(e)}function cu(e){return new cn(e)}function ch(){return new cr}function cp(e){return new ca(e)}function cd(){return new dk}function cc(){return new dN}function cf(e){return new dI(e)}function cm(e){return new dS(e)}function cg(e){return new dC(e)}function cy(e){return new dT(e)}function cx(e){return new d$(e)}function cb(e){return new dE(e)}function cw(e){return new dA(e)}function cv(e){return new dR(e)}function ck(e){return new dF(e)}function cN(e){return new d_(e)}function cI(e){return new dD(e)}function cS(e){return new dO(e)}function cC(e){return new dM(e)}e.s(["maxNorm",()=>cl,"minMaxNorm",()=>cp,"nonNeg",()=>ch,"unitNorm",()=>cu],79028),e.i(79028),e.s(["constant",()=>cf,"glorotNormal",()=>cv,"glorotUniform",()=>cw,"heNormal",()=>ck,"heUniform",()=>cN,"identity",()=>cx,"leCunNormal",()=>cI,"leCunUniform",()=>cS,"ones",()=>cc,"orthogonal",()=>cC,"randomNormal",()=>cg,"randomUniform",()=>cm,"truncatedNormal",()=>cy,"varianceScaling",()=>cb,"zeros",()=>cd],30430),e.i(30430);let cT="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e();function c$(){return new Promise(e=>cT(()=>e()))}var ha=ha;async function cE(e){if(null==e)return;let t=[],n=[],r=[];for(let a in e){let s=e[a];"number"!=typeof s&&(t.push(s.data()),n.push(a),r.push(s))}if(t.length>0){let a=await Promise.all(t);for(let t=0;t<a.length;++t)e[n[t]]=a[t][0];sn(r)}}function cA(e){if(null!=e)for(let t in e){let n=e[t];"number"!=typeof n&&n.dispose()}}(g=F||(F={}))[g.SILENT=0]="SILENT",g[g.VERBOSE=1]="VERBOSE";class cR{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class cF{constructor(e,t=10){null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){for(let n of(null==t&&(t={}),this.callbacks))await n.onEpochBegin(e,t)}async onEpochEnd(e,t){for(let n of(null==t&&(t={}),this.callbacks))await n.onEpochEnd(e,t)}async onBatchBegin(e,t){for(let n of(null==t&&(t={}),this.callbacks))await n.onBatchBegin(e,t)}async onBatchEnd(e,t){for(let n of(null==t&&(t={}),this.callbacks))await n.onBatchEnd(e,t)}async onTrainBegin(e){for(let t of(null==e&&(e={}),this.callbacks))await t.onTrainBegin(e)}async onTrainEnd(e){for(let t of(null==e&&(e={}),this.callbacks))await t.onTrainEnd(e)}}class c_ extends cR{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});let n=null==t.size?0:t.size;for(let e in this.seen+=n,t){let r=t[e];if("number"==typeof r)this.totals.hasOwnProperty(e)||(this.totals[e]=0),this.totals[e]=this.totals[e]+r*n;else{let t;e in this.totals?t=this.totals[e]:this.totals[e]=0;let a=st(()=>sG(this.totals[e],sK(r,n)));this.totals[e]=a,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(let e of this.params.metrics)null!=this.totals[e]&&("number"==typeof this.totals[e]?t[e]=this.totals[e]/this.seen:st(()=>{let n=sK(sq(1,this.seen),this.totals[e]);t[e]=n,this.totals[e].dispose(),sr(t[e])}))}}class cD extends cR{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){for(let n in null==t&&(t={}),this.epoch.push(e),t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let r in this.history){let a=this.history[r];for(let s=0;s<a.length;++s)if("number"!=typeof a[s]){let i=a[s];e.push(i.data()),t.push(r),n.push(s)}}let r=await Promise.all(e);for(let e=0;e<r.length;++e)this.history[t[e]][n[e]].dispose(),this.history[t[e]][n[e]]=r[e][0]}}class cO extends cR{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||c$,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");ha.isNumber(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let r,a=null!=n?n():ha.now();return(...s)=>{let i=null!=n?n():ha.now();return i-a<t?r:(a=i,r=e(...s))}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let r=[];null!=this.yield&&(await cE(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await cE(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];null!=this.epochEnd&&(await cE(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await cE(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];null!=this.batchEnd&&(await cE(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):ha.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await cE(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await cE(e),await this.trainEnd(e))}}function cM(e,t){return(null==e&&(e={}),e instanceof cR)?[e]:Array.isArray(e)&&e[0]instanceof cR?e:hm(e).map(e=>new cO(e,t))}class cL{static registerCallbackConstructor(e,t){ha.assert(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),cL.checkForDuplicate(t),null==cL.constructors[e]&&(cL.constructors[e]=[]),cL.constructors[e].push(t)}static checkForDuplicate(e){for(let t in cL.constructors)cL.constructors[+t].forEach(t=>{if(t===e)throw new ho("Duplicate callback constructor.")})}static clear(){cL.constructors={}}static createCallbacks(e){let t=[];for(let n in cL.constructors){let r=+n;e>=r&&t.push(...cL.constructors[r])}return t.map(e=>new e)}}function cz(e,t,n,r,a,s,i,o,l){let u=new cD,h=[new c_,...cL.createCallbacks(t)];null!=e&&h.push(...e),h.push(u);let p=new cF(h);return p.setParams({epochs:n,initialEpoch:r,samples:a,steps:s,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:p,history:u}}function cP(e){return new Promise(e=>setTimeout(e)).then(e)}cL.constructors={};class cB{constructor(e){if(!tU.getBool("IS_BROWSER"))throw Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(cB.URL_SCHEME)&&(e=e.slice(cB.URL_SCHEME.length)),(null==e||0===e.length)&&(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"==typeof document)throw Error("Browser downloads are not supported in this environment since `document` is not present");let t=a9.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let t=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],r=sm(e,t),a=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),s=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(s.download=this.modelJsonFileName,s.href=a,await cP(()=>s.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){let e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await cP(()=>e.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:sx(e)}}}}cB.URL_SCHEME="downloads://";class cW{constructor(e){if(null==e||e.length<1)throw Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let n=new FileReader;n.onload=n=>{let r=JSON.parse(n.target.result),a=r.modelTopology;null==a?t(Error(`modelTopology field is missing from file ${this.jsonFile.name}`)):null==r.weightsManifest?t(Error(`weightManifest field is missing from file ${this.jsonFile.name}`)):0===this.weightsFiles.length?e({modelTopology:a}):e(sy(r,e=>this.loadWeights(e)))},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){let t=[],n=[];for(let r of e)t.push(...r.weights),n.push(...r.paths);let r=this.checkManifestAndWeightFiles(e);return Promise.all(n.map(e=>this.loadWeightsFile(e,r[e]))).then(e=>[t,e])}loadWeightsFile(e,t){return new Promise((n,r)=>{let a=new FileReader;a.onload=e=>{n(e.target.result)},a.onerror=t=>r(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map(e=>sf(e.name)),r={};for(let a of e)a.paths.forEach(e=>{let a=sf(e);if(-1!==t.indexOf(a))throw Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),-1===n.indexOf(a))throw Error(`Weight file with basename '${a}' is not provided.`);r[e]=this.weightsFiles[n.indexOf(a)]});if(t.length!==this.weightsFiles.length)throw Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}function cU(e){return new cW(e)}function cj(e,t,n,r){var a,s,i;te(null!=(a=e)&&Array.isArray(a)&&a.length>0,()=>"promises must be a none empty array"),s=n=null==n?0:n,i=r=null==r?1:r,te(s>=0&&s<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${s}`),te(i>=0&&i<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${i}`),te(i>=s,()=>`startFraction must be no more than endFraction, but got startFraction ${s} and endFraction ${i}`);let o=0;return Promise.all(e.map(a=>(a.then(a=>(t(n+ ++o/e.length*(r-n)),a)),a)))}async function cV(e,t){null==t&&(t={});let n=null==t.fetchFunc?tU.platform.fetch:t.fetchFunc,r=e.map(e=>n(e,t.requestInit,{isBinary:!0})),a=(null==t.onProgress?await Promise.all(r):await cj(r,t.onProgress,0,.5)).map(e=>e.arrayBuffer());return null==t.onProgress?await Promise.all(a):await cj(a,t.onProgress,.5,1)}async function cG(e,t="",n,r){return cH(e=>cV(e,{requestInit:r}))(e,t,n)}function cH(e){return async(t,n="",r)=>{let a=t.map(()=>!1),s={},i=null!=r?r.map(()=>!1):[],o=[];if(t.forEach((e,t)=>{let n=0;e.weights.forEach(e=>{let l=a7["quantization"in e?e.quantization.dtype:e.dtype]*tr(e.shape),u=()=>{a[t]=!0,null==s[t]&&(s[t]=[]),s[t].push({manifestEntry:e,groupOffset:n,sizeBytes:l})};null!=r?r.forEach((t,n)=>{t===e.name&&(u(),i[n]=!0)}):u(),o.push(e.name),n+=l})}),!i.every(e=>e)){let e=r.filter((e,t)=>!i[t]);throw Error(`Could not find weights in manifest with names: ${e.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}let l=a.reduce((e,t,n)=>(t&&e.push(n),e),[]),u=[];l.forEach(e=>{t[e].paths.forEach(e=>{let t=n+(n.endsWith("/")?"":"/")+e;u.push(t)})});let h=await e(u),p={},d=0;return l.forEach(e=>{let n=t[e].paths.length,r=new a9(h.slice(d,d+n));s[e].forEach(e=>{let t=si(r.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(let e in t)p[e]=t[e]}),d+=n}),p}}sw.registerSaveRouter(e=>tU.getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(cB.URL_SCHEME)?function(e="model"){return new cB(e)}(e.slice(cB.URL_SCHEME.length)):null);class cq{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(te("function"==typeof t.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=tU.platform.fetch,te(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&te(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=sm(e,n);if(t.body.append("model.json",new Blob([JSON.stringify(r)],{type:"application/json"}),"model.json"),null!=e.weightData){let n=a9.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}let a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:sx(e),responses:[a]};throw Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async loadModelJSON(){let e,t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);try{e=await t.json()}catch(t){let e=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",Error(e)}let n=e.modelTopology,r=e.weightsManifest;if(null==n&&null==r)throw Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return e}async load(){return this.loadOptions.streamWeights?this.loadStream():sy(await this.loadModelJSON(),e=>this.loadWeights(e))}async loadStream(){let e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=sb(e.weightsManifest),r=()=>{var e,n;let r,a,s;return a=null==(e=this.loadOptions).fetchFunc?tU.platform.fetch:e.fetchFunc,s=0,null==(n=e.onProgress)||n.call(e,0),new ReadableStream({pull:async n=>{for(var i;s<t.length;){r||(r=(await a(t[s],e.requestInit,{isBinary:!0})).body.getReader());let{done:o,value:l}=await r.read();if(o){s++,r=void 0,null==(i=e.onProgress)||i.call(e,s/t.length);continue}n.enqueue(l);return}n.close()}})};return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:r})}async getWeightUrls(e){var t;let n,r,[a,s]=(n=(t=Array.isArray(this.path)?this.path[1]:this.path).lastIndexOf("/"),r=t.lastIndexOf("?"),[t.substring(0,n)+"/",r>n?t.substring(r):""]),i=this.weightPathPrefix||a,o=[],l=[];for(let t of e)for(let e of t.paths)null!=this.weightUrlConverter?l.push(this.weightUrlConverter(e)):o.push(i+e+s);return this.weightUrlConverter&&o.push(...await Promise.all(l)),o}async loadWeights(e){let t=await this.getWeightUrls(e);return[sb(e),await cV(t,this.loadOptions)]}}function cK(e){return null!=e.match(cq.URL_SCHEME_REGEX)}cq.URL_SCHEME_REGEX=/^https?:\/\//;let cX=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc));else if(Array.isArray(e)?e.every(e=>cK(e)):cK(e))return cY(e,t);return null};function cY(e,t){return new cq(e,t)}function cZ(e,t){return cY(e,t)}sw.registerSaveRouter(cX),sw.registerLoadRouter(cX);class cJ{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class cQ{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class c0{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function c1(e,t,n,r){let a=arguments;return new c0(c2(...a))}function c2(e,t,n,r){return 1!=arguments.length?(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new cJ({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r})):null!=e.modelTopology||null!=e.weightSpecs?new cJ(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new cJ({modelTopology:e}))}function c3(e){return new cQ(e)}function c4(e){return new cQ(e)}e.s([],3615),e.i(3615),e.s(["CompositeArrayBuffer",()=>a9,"browserFiles",()=>cU,"browserHTTPRequest",()=>cZ,"concatenateArrayBuffers",()=>sc,"copyModel",()=>sP,"decodeWeights",()=>si,"decodeWeightsStream",()=>sh,"encodeWeights",()=>ss,"fromMemory",()=>c1,"fromMemorySync",()=>c2,"getLoadHandlers",0,(e,t)=>sw.getLoadHandlers(e,t),"getModelArtifactsForJSON",()=>sy,"getModelArtifactsForJSONSync",()=>sg,"getModelArtifactsInfoForJSON",()=>sx,"getSaveHandlers",0,e=>sw.getSaveHandlers(e),"getWeightSpecs",()=>sb,"http",()=>cY,"isHTTPScheme",()=>cK,"listModels",()=>sL,"loadWeights",()=>cG,"moveModel",()=>sB,"registerLoadRouter",0,e=>sw.registerLoadRouter(e),"registerSaveRouter",0,e=>sw.registerSaveRouter(e),"removeModel",()=>sz,"weightsLoaderFactory",()=>cH,"withSaveHandler",()=>c3,"withSaveHandlerSync",()=>c4],68403);var c5=e.i(68403),c5=c5,hT=hT,ha=ha,hT=hT;function c6(e,t={},n=!1){return hw(e,hT.SerializationMap.getMap().classNameMap,t,"layer",n)}var ha=ha;function c8(e,t){return st(()=>{var n;"float32"!==e.dtype&&(e=sU(e,"float32"));let r=ix(sK(n=e,n),t,!0),a=s7(r.shape,dr()),s=sX(il(r,a));return sq(e,s)})}function c7(e,t){return st(()=>{var n;return uA(sK(n=it(t,e),n),-1)})}function c9(e,t){return st(()=>uA(ia(it(t,e)),-1))}function fe(e,t){return st(()=>{let n=it(e,t),r=ut(ia(e),dr(),Number.MAX_VALUE);return sK(100,uA(ia(sq(n,r)),-1))})}function ft(e,t,n=!1){return st(()=>{if(n)t=uq(t);else{let e=ix(t,t.shape.length-1,!0);t=sq(t,e)}return t=ut(t,dr(),1-dr()),ig(ix(sK(sU(e,"float32"),oN(t)),t.shape.length-1))})}function fn(e,t,n=!1){return st(()=>{let r,a=sU(ow((r=[p9(e.shape)],iy(e,r))),"int32"),s=(t=ut(t,dr(),1-dr())).shape;return ft(iy(uO(a,s[s.length-1]),s),t,n)})}function fr(e,t){return st(()=>{let n;return uA(function(e,t){if(!ha.arraysEqual(e.shape,t.shape))throw new ho(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return st(()=>{let n=o0(t),r=ig(ia(t));return sG(it(n,sK(t,e)),uC(on(r)))})}(e,n=oN(sq(n=ut(t,dr(),1-dr()),it(1,n)))),-1)})}function fa(e,t){return st(()=>ig(ix(sK(c8(e,-1),c8(t,-1)),-1)))}let fs={meanSquaredError:c7,meanAbsoluteError:c9,meanAbsolutePercentageError:fe,meanSquaredLogarithmicError:function(e,t){return st(()=>{var n;return uA(sK(n=it(oN(sG(1,ut(t,dr(),Number.MAX_VALUE))),oN(sG(1,ut(e,dr(),Number.MAX_VALUE)))),n),-1)})},squaredHinge:function(e,t){return st(()=>{let n=il(0,it(1,sK(e,t)));return uA(sK(n,n),-1)})},hinge:function(e,t){return st(()=>uA(il(0,it(1,sK(e,t))),-1))},categoricalHinge:function(e,t){return st(()=>{let n=ix(sK(e,t),-1),r=uh(sK(it(1,e),t),-1);return il(0,sG(1,it(r,n)))})},logcosh:function(e,t){return st(()=>{let n=Math.log(2),r=it(t,e);return uA(it(sG(r,uk(sK(-2,r))),n),-1)})},categoricalCrossentropy:ft,sparseCategoricalCrossentropy:fn,binaryCrossentropy:fr,kullbackLeiblerDivergence:function(e,t){return st(()=>{let n=ut(e,dr(),1);return ix(sK(e,oN(sq(n,ut(t,dr(),1)))),-1)})},poisson:function(e,t){return st(()=>{let n=oN(sG(dr(),t));return uA(it(t,sK(e,n)),-1)})},cosineProximity:fa};function fi(e){if("string"!=typeof e)return e;{if(e in fs)return fs[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new ho(t)}}function fo(e,t){return st(()=>{let n=sK(.5,uM(t)),r=sU(ou(t,n),e.dtype);return uA(op(e,r),-1)})}function fl(e,t){return st(()=>sU(op(l1(e,-1),l1(t,-1)),"float32"))}function fu(e,t){return st(()=>sU(ix(iB(op(e,1),op(t,1))),"float32"))}function fh(e,t){return st(()=>{let n=fu(e,t),r=sG(n,st(()=>sU(ix(iB(op(e,0),op(t,1))),"float32")));return sU(iU(ou(r,0),sq(n,r),0),"float32")})}function fp(e,t){return fr(e,t)}function fd(e,t){return e.rank===t.rank&&(e=uX(e,[e.rank-1])),(t=l1(t,-1)).dtype!==e.dtype&&(t=sU(t,e.dtype)),sU(op(e,t),"float32")}let fc={binaryAccuracy:fo,categoricalAccuracy:fl,precision:fh,categoricalCrossentropy:ft,sparseCategoricalCrossentropy:fn,mse:c7,MSE:c7,mae:c9,MAE:c9,mape:fe,MAPE:fe,cosine:fa};function ff(e){if(hd(null!==e,`Unknown LossOrMetricFn ${e}`),"string"==typeof e)return e;{let t;for(let n of Object.keys(fs))if(fs[n]===e){t=n;break}if(void 0!==t)return t;for(let n of Object.keys(fc))if(fc[n]===e){t=n;break}return void 0!==t?t:e.name}}let fm=class{static sgd(e){return new ih(e)}static momentum(e,t,n=!1){return new ip(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,a=!1){return new id(e,t,n,r,a)}static adam(e=.001,t=.9,n=.999,r=null){return new ir(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new s8(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,a=0){return new iu(e,t,n,r,a)}static adagrad(e,t=.1){return new s9(e,t)}};function fg(e,t,n=!1){if(null==e||"object"!=typeof e||Object.getPrototypeOf(e)!==Object.prototype||!function e(t){if(null===t)return!0;if("object"==typeof t)if(Object.getPrototypeOf(t)===Object.prototype){for(let n of Object.keys(t))if("string"!=typeof n||!e(t[n]))return!1;return!0}else{if(!Array.isArray(t))return!1;for(let n of t)if(!e(n))return!1;return!0}{let e=typeof t;return"string"===e||"number"===e||"boolean"===e}}(e))throw Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let n=JSON.stringify(e);n.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function fy(e,t,n=console.log){let r="";for(let n=0;n<e.length;++n)n>0&&(r=r.slice(0,r.length-1)+" "),r+=e[n],r=r.slice(0,t[n]),r+=" ".repeat(t[n]-r.length);n(r)}function fx(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function fb(e,t){if(null===e)return null;if("string"==typeof e)return hy(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let r=e[a];fx(t,a,r)?n.push(r):n.push(fb(r,t))}return n}{let t={};for(let n of Object.keys(e)){let r=e[n];if("name"===n&&"string"==typeof r)t[n]=r;else{let e=hy(n);t[e]=fb(r,e)}}return t}}let fw="4.22.0";class fv extends d1{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=hA(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],hk(this.inputs).length!==this.inputs.length)throw new ho(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(e=>e.name)}`);for(const e of(hk(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(e=>e.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[],this.outputs)){const t=e.sourceLayer,n=e.nodeIndex,r=e.tensorIndex;this.outputLayers.push(t),this.outputLayersNodeIndices.push(n),this.outputLayersTensorIndices.push(r)}for(const e of this.inputs){const t=e.sourceLayer,n=e.nodeIndex,r=e.tensorIndex;hd(0===n,"input layer has >1 nodes"),hd(0===r,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(n),this.inputLayersTensorIndices.push(r)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let t=0;t<this.inputLayers.length;t++){const n=this.inputLayers[t];if(!(n instanceof d2))throw TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${t} (0-based) originates from layer type ${n.getClassName()}.`);this.inputNames.push(n.name),this.feedInputShapes.push(n.batchInputShape),this.feedInputNames.push(n.name)}for(const e of this.outputLayers)this.outputNames.push(e.name);this.internalInputShapes=this.inputs.map(e=>e.shape),this.internalOutputShapes=this.outputs.map(e=>e.shape);const t={},n={},r={},a={},s={},i=[],o=(e,t,n,r,a,l)=>{(null==r||null==a||null==l)&&(r=e.sourceLayer,a=e.nodeIndex,l=e.tensorIndex);let u=r.inboundNodes[a];if(-1!==n.indexOf(u))throw new hi(`The tensor ${e.name} at layer "${r.name}" is part of a cycle.`);if(-1!==t.indexOf(u))return;this.containerNodes.add(fv.nodeKey(r,a)),r.id in s||(s[r.id]=Object.keys(s).length),-1===n.indexOf(u)&&n.push(u);let h=u.inboundLayers.length;for(let e=0;e<h;e++)o(u.inputTensors[e],t,n,u.inboundLayers[e],u.nodeIndices[e],u.tensorIndices[e]);for(t.push(u);n.indexOf(u)>=0;)n.splice(n.indexOf(u),1);i.push(u)},l=[],u=[];for(const e of this.outputs)o(e,l,u);for(const e of i.slice().reverse()){n[e.id]=e,e.id in t||(t[e.id]=0);let s=t[e.id];s=Math.max(s,null==r[e.outboundLayer.id]?0:r[e.outboundLayer.id]),r[e.outboundLayer.id]=s,a[e.outboundLayer.id]=e.outboundLayer,t[e.id]=s;for(let r=0;r<e.inboundLayers.length;r++){const a=e.inboundLayers[r],i=e.nodeIndices[r],o=a.inboundNodes[i],l=null==t[o.id]?0:t[o.id];t[o.id]=Math.max(s+1,l),n[o.id]=o}}const h={};for(const e in t){const r=t[e];r in h||(h[r]=[]),h[r].push(n[e])}const p={};for(const e in r){const t=r[e];t in p||(p[t]=[]),p[t].push(a[e])}let d=Object.keys(p).map(e=>parseInt(e,10)).sort(hv);for(const e of(this.layers=[],d)){const t=p[e];for(const e of(t.sort((e,t)=>{let n=s[e.id],r=s[t.id];return n<r?-1:+(n>r)}),t))e instanceof fv&&this.internalContainerRefs.push(e),this.layers.push(e)}this.layersByDepth=p,d=Object.keys(h).map(e=>parseInt(e,10)).sort(hv);const c=this.inputs.slice(),f=[];for(const e of d)for(const t of h[e]){const e=t.outboundLayer;if(null!=e){for(const n of t.inputTensors)if(-1===c.indexOf(n))throw new hi(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${e.name}". The following previous layers were accessed without issue: ${f}`);for(const e of t.outputTensors)c.push(e);f.push(e.name)}}this.nodesByDepth=h;const m=this.layers.map(e=>e.name);for(const e of m){const t=m.filter(t=>t===e).length;if(1!==t)throw new hi(`The name "${e}" is used ${t} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(m))}this.outboundNodes=[],this.inboundNodes=[],new dQ({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(e=>null),outputMasks:this.outputs.map(e=>null),inputShapes:this.inputs.map(e=>e.shape),outputShapes:this.outputs.map(e=>e.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let e={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(let t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(let t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(t=>t.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new ho("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(let t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){let n={},r=0,a=(e=>{let t=Object.keys(e);if(0===t.length)return!1;let n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(e);for(let t of(a&&this.parseWeights(e),this.layers))for(let[e,s]of t.weights.entries()){let t=a?`${s.name.split("/").slice(0,-1).join("/")+"/"}${e}`:s.originalName;if(null!=n[t])throw new ho(`Duplicate weight name: ${t}`);n[t]=s,r++}let s=[];for(let r in e){let a=r;if(null==n[r]){let e=r.split("/");a=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[a])s.push([n[a],e[r]]);else if(t)throw new ho(`Provided weight data has no target variable: ${r}`);delete n[a]}if(t){let e=[];for(let t in n)e.push(t);if(e.length>0)throw new ho(`${e.length} of ${r} weights are not set: ${e}`)}dX(s)}parseWeights(e){for(let t in Object.keys(e)){let n=t.split("/"),r=["vars","layer_checkpoint_dependencies"],a=n.map(e=>e.startsWith("_")?e.slice(1):e).filter(e=>!r.includes(e)).join("/");a!==t&&(e[a]=e[t],delete e[t])}}updatedConfig(){let e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${fw}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){let n=function e(t,n){if(null==t)return null;if("string"==typeof t)return hg(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){let r=[],a=t.length;for(let s=0;s<a;++s){let a=t[s];fx(n,s,a)?r.push(a):r.push(e(a,n))}return r}{let n={};for(let r of Object.keys(t)){let a=t[r],s=hg(r);("name"===r||"className"===r)&&"string"==typeof a?n[s]=a:n[s]=e(a,r)}return n}}(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return st(()=>{e=hm(e);let n=new d4;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return d8(this.outputs,n,t)})}computeMask(e,t){return st(()=>{let n;return e=hm(e),n=null==t?hp(null,e.length):hm(t),this.runInternalGraph(e,n)[1]})}computeOutputShape(e){let t=dW(e);if(t.length!==this.inputLayers.length)throw new ho(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);let n={};for(let e=0;e<t.length;e++){let r=this.inputLayers[e],a=t[e];n[r.name+"_0_0"]=a}let r=Object.keys(this.nodesByDepth).map(e=>parseInt(e,10)).sort(hv);if(r.length>1)for(let e of r)for(let t of this.nodesByDepth[e]){let e=t.outboundLayer;if(-1!==this.inputLayers.map(e=>e.id).indexOf(e.id))continue;let r=[];for(let e=0;e<t.inboundLayers.length;e++){let a=t.inboundLayers[e],s=t.nodeIndices[e],i=t.tensorIndices[e],o=n[`${a.name}_${s}_${i}`];r.push(o)}let a=dW(e.computeOutputShape(hf(r))),s=e.inboundNodes.indexOf(t);for(let t=0;t<a.length;t++)n[`${e.name}_${s}_${t}`]=a[t]}let a=[],s=[];for(let e=0;e<this.outputLayers.length;e++){let t=this.outputLayers[e],n=this.outputLayersNodeIndices[e],r=this.outputLayersTensorIndices[e],a=`${t.name}_${n}_${r}`;s.push(a)}for(let e=0;e<s.length;e++){let t=s[e];hd(t in n),a.push(n[t])}return hf(a)}runInternalGraph(e,t){null==t&&(t=hp(null,e.length));let n={};for(let r=0;r<this.inputs.length;++r){let a=this.inputs[r],s=e[r],i=t[r];n[a.id]=[s,i]}for(let e of Object.keys(this.nodesByDepth).map(e=>parseInt(e,10)).sort(hv))for(let t of this.nodesByDepth[e]){let e=t.outboundLayer,r=t.inputTensors,a=t.outputTensors,s=[];for(let e of r)e.id in n&&s.push(n[e.id]);if(s.length===r.length){let r,i,o,l,u={};if(null!=t.callArgs&&(u=t.callArgs),1===s.length){let[t,n]=s[0];null==u.mask&&(u.mask=n),o=hm(e.call(t,u)),l=hm(e.computeMask(t,n)),r=[t],i=[n]}else r=s.map(e=>e[0]),i=s.map(e=>e[1]),null==u.mask&&(u.mask=i),o=hm(e.call(r,u)),l=hm(e.computeMask(r,i));if(e.activityRegularizer)throw new hl("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<a.length;++e){let t=a[e],r=o[e],s=l[e];n[t.id]=[r,s]}}}let r=[],a=[],s=[];for(let e of this.outputs){hd(e.id in n,`Could not compute output ${e.name} : ${e.id}`);let[t,i]=n[e.id];s.push(t.shape),r.push(t),a.push(i)}return[r,a,s]}buildNodeConversionMap(e){let t,n={};for(let e of this.layers){t=+(e instanceof fv);for(let r=0;r<e.inboundNodes.length;r++){let a=fv.nodeKey(e,r);this.containerNodes.has(a)&&(n[a]=t,t+=1)}}return n}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new ho("Provide either a layer name or layer index");if("number"==typeof e)return this.findLayer(e);for(let t of this.layers)if(t.name===e)return t;throw new ho(`No such layer: ${e}`)}findLayer(e){if(!(this.layers.length<=e))return this.layers[e];throw new ho(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`)}calculateLosses(){return st(()=>{let e=[];for(let t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){let r=fv.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e})}getConfig(){let e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(let e of this.layers){let r=e.getClassName(),a=e.getConfig(),s=[];for(let n=0;n<e.inboundNodes.length;n++){let r=e.inboundNodes[n],a=fv.nodeKey(e,n),i={};if(this.containerNodes.has(a)){if(r.callArgs)try{JSON.stringify(r.callArgs),i=r.callArgs}catch(t){console.warn(`Layer ${e.name} was passed non-serializable keyword arguments: ${r.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),i={}}if(r.inboundLayers.length>0){let e=[];for(let n=0;n<r.inboundLayers.length;n++){let a=r.inboundLayers[n],s=r.nodeIndices[n],o=r.tensorIndices[n],l=t[fv.nodeKey(a,s)];null==l&&(l=0),e.push([a.name,l,o,i])}s.push(e)}}}let i={};i.name=e.name,i.className=r,i.config=a,i.inboundNodes=s,n.push(i)}e.layers=n;let r=[];for(let e=0;e<this.inputLayers.length;e++){let n=this.inputLayers[e],a=this.inputLayersNodeIndices[e],s=fv.nodeKey(n,a);if(!this.containerNodes.has(s))continue;let i=t[s];null==i&&(i=0);let o=this.inputLayersTensorIndices[e];r.push([n.name,i,o])}e.inputLayers=r;let a=[];for(let e=0;e<this.outputLayers.length;e++){let n=this.outputLayers[e],r=this.outputLayersNodeIndices[e],s=fv.nodeKey(n,r);if(!this.containerNodes.has(s))continue;let i=t[s];null==i&&(i=0);let o=this.outputLayersTensorIndices[e];a.push([n.name,i,o])}return e.outputLayers=a,e}static fromConfig(e,t,n={},r=!1){let a={},s={};function i(e,t){e.name in s?s[e.name].push(t):s[e.name]=[t]}let o=t.name,l=t.layers;for(let e of l)!function(e){let n=e.name,s=c6(e,null!=t.customObjects?t.customObjects:{});s.setFastWeightInitDuringBuild(r),a[n]=s,e.inboundNodes.forEach(e=>{if(!(e instanceof Array))throw new ho(`Corrupted configuration, expected array for nodeData: ${e}`);i(s,e)})}(e);for(;!function(e){if(null==e)throw new ho(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}(s);)for(let e of l){let t=a[e.name];if(t.name in s){let e=s[t.name];for(let n of(delete s[t.name],e))!function(e,t){let n,r=[];for(let s of t){let o=s[0],l=s[1],u=s[2];if(n=null==s[3]?{}:s[3],!(o in a))return void i(e,t);let h=a[o];if(h.inboundNodes.length<=l)return void i(e,t);let p=h.inboundNodes[l];r.push(p.outputTensors[u])}r.length>0&&e.apply(hf(r),n)}(t,n)}}let u=[],h=[];for(let e of t.inputLayers){let t=e[0],n=e[1],r=e[2];hd(t in a);let s=a[t].inboundNodes[n].outputTensors;u.push(s[r])}for(let e of t.outputLayers){let t=e[0],n=e[1],r=e[2];hd(t in a);let s=a[t].inboundNodes[n].outputTensors;h.push(s[r])}return new e({inputs:u,outputs:h,name:o})}get stateful(){if(this._stateful)throw new ho("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let e of this.layers)if(e.stateful)return!0;return!1}resetStates(){st(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}var ha=ha;function fk(e,t){var n="classWeight";let r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map(e=>null);if(1===r)if(Array.isArray(e)&&1===e.length)return e;else if("object"==typeof e&&t[0]in e)return[e[t[0]]];else return[e];if(Array.isArray(e)){if(e.length!==r)throw Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"==typeof e&&Object.keys(e).length>0&&"object"==typeof e[Object.keys(e)[0]]){let n=[];return t.forEach(t=>{t in e?n.push(e[t]):n.push(null)}),n}throw Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}async function fN(e,t,n,r){if(null!=t||null!=r)throw Error("Support sampleWeight is not implemented yet");if(null==n)return null;{let t=st(()=>{if(1===e.shape.length)return sj(e);if(2===e.shape.length)if(e.shape[1]>1)return l1(e,1);else if(1===e.shape[1])return iy(e,[e.shape[0]]);else throw Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`);throw Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),r=Array.from(await t.data());sn(t);let a=[];return r.forEach(e=>{if(null==n[e])throw Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);a.push(n[e])}),hZ(a,"float32")}}function fI(e,t){let n,r;n=t.xs,r=t.ys,ha.assert(null!=n&&null!=r,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let a=fS("input",e.inputNames,n),s=fS("output",e.outputNames,r),i=a[0].shape[0];ha.assert(a.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),ha.assert(s.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${s.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let t=0;t<a.length;t++)ha.assert(a[t].shape[0]===i,()=>`Batch size mismatch: input ${e.inputNames[t]} has ${a[t].shape[0]}; expected  ${i} based on input ${e.inputNames[0]}.`);for(let t=0;t<s.length;t++)ha.assert(s[t].shape[0]===i,()=>`Batch size mismatch: output ${e.outputNames[t]} has ${s[t].shape[0]}; expected  ${i} based on input ${e.inputNames[0]}.`);return{xs:a,ys:s}}function fS(e,t,n){if(n instanceof aA)return[n];if(Array.isArray(n))return ha.assert(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{let r=[];for(let a of t){if(null==n[a])throw new ho(`The feature data generated by the dataset lacks the required ${e} key '${a}'.`);r.push(n[a])}return r}}async function fC(e,t,n){let r=null!=n.batchesPerEpoch;if(ha.assert(null!=e.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),ha.assert(null!=n,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),ha.assert(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),ha.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),ha.assert(null==n.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{var a,s;let i,o,l,u,h=null!=n.validationData;if(h)if(fT(n.validationData))ha.assert(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{let e=function(e){if(3===e.length)throw new hl("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);o=e.xs,l=e.ys}let p=e.makeTrainFunction(),d=e.getDedupedMetricsNames();u=h?d.slice().concat(d.map(e=>"val_"+e)):d.slice();let c=cM(n.callbacks,n.yieldEvery),f=null==n.verbose?1:n.verbose,{callbackList:m,history:g}=cz(c,f,n.epochs,null,null,(a=t,s=n,i=null,null!=s.batchesPerEpoch?i=s.batchesPerEpoch:Number.isFinite(a.size)&&(i=a.size),i),null,h,u);m.setModel(e),e.history=g,await m.onTrainBegin(),e.stopTraining_=!1;let y=null==n.initialEpoch?0:n.initialEpoch,x=await t.iterator();for(;y<n.epochs;){let a={};await m.onEpochBegin(y);let s=0,i=0;for(r||(x=await t.iterator());!r||s<n.batchesPerEpoch;){let t=await x.next();if(r&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${s} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=t.value){let{xs:r,ys:a}=fI(e,t.value),o={};o.batch=i,o.size=r[0].shape[0],await m.onBatchBegin(i,o);let l=[];if(null!=n.classWeight){let t=fk(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)l.push(await fN(a[e],null,t[e]))}let u=r.concat(a).concat(l),h=p(u);sn(u);for(let e=0;e<d.length;++e){let t=d[e],n=h[e];o[t]=n,sr(n)}await m.onBatchEnd(i,o),cA(o),i++,s++}if(r?s>=n.batchesPerEpoch:t.done){if(h){let t;t=fT(n.validationData)?hm(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):hm(e.evaluate(o,l,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)a[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await m.onEpochEnd(y,a),y++,e.stopTraining_)break}return await m.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function fT(e){return"function"==typeof e.iterator}async function f$(e,t,n){let r=null!=(n=n||{}).batches,a=e.testFunction,s=[];if(n.verbose>0)throw new hl("Verbose mode is not implemented yet.");ha.assert(!r||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);let i="function"==typeof t.next?t:await t.iterator(),o=0,l=0;for(;!r||l<n.batches;){let t=await i.next();if(s=st(()=>{if(t.value){let{xs:n,ys:r}=fI(e,t.value),i=n.concat(r),u=st(()=>a(i));if(sn(i),0===l)for(let e=0;e<u.length;++e)s.push(sQ(0));let h=i[0].shape[0];for(let e=0;e<u.length;++e){let t=u[e],n=s[e];s[e]=st(()=>sG(s[e],sK(h,t))),l>0&&sn(n)}sn(u),o+=h,++l}return s}),t.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let e=0;e<s.length;++e){let t=s[e];s[e]=sq(s[e],o),sn(t)}return hf(s)}var ha=ha;function fE(e){ha.assert(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function fA(e,t,n){return null==e?[null]:Array.isArray(e)?e.map(e=>di(e,t,n-t)):di(e,t,n-t)}function fR(e,t){return st(()=>null==e?null:Array.isArray(e)?e.map(e=>fR(e,t)):dm(e,"int32"===t.dtype?t:sU(t,"int32")))}function fF(e,t){let n=[],r=0,a=null;for(;r<e;)(a=r+t)>=e&&(a=e),n.push([r,a]),r=a;return n}function f_(e){let t=[];e instanceof aA&&(e=[e]);for(let n=0;n<e.length;++n){let r=e[n];if(1===r.rank)t.push(ds(r,1));else if(0===r.rank)throw Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");else t.push(r)}return t}function fD(e,t){if(null==e)return;let n=[];if(t instanceof aA)n.push(t.id);else if(Array.isArray(t))t.forEach(e=>n.push(e.id));else if(null!=t)for(let e in t){let r=t[e];n.push(r.id)}let r=[];if(e instanceof aA)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach(e=>{-1===n.indexOf(e.id)&&r.push(e)});else if(null!=e)for(let t in e){let a=e[t];-1===n.indexOf(a.id)&&r.push(a)}r.forEach(e=>{e.isDisposed||e.dispose()})}function fO(e){return Array.isArray(e)}function fM(e){return!(e instanceof aA)&&!fO(e)}function fL(e,t,n,r=!0,a=""){let s;if(null==t||0===t.length){if(null!=e){let t=!1;if(fO(e)&&e.length>0)t=!0;else if(fM(e)){for(let n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new ho(`Error when checking model ${a} expected no data, but got ${e}`)}return[]}if(null==e)return t.map(e=>null);if(fM(e))for(let n of(s=[],t)){if(null==e[n])throw new ho(`No data provided for "${n}". Need data for each key in: ${t}`);s.push(e[n])}else if(fO(e)){if(e.length!==t.length)throw new ho(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);s=e}else{if(t.length>1)throw new ho(`The model ${a} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);s=[e]}if(s=f_(s),null!=n)for(let e=0;e<t.length;++e){if(null==n[e])continue;let i=s[e];if(i.shape.length!==n[e].length)throw new ho(`Error when checking ${a}: expected ${t[e]} to have ${n[e].length} dimension(s). but got array with shape ${i.shape}`);for(let t=0;t<n[e].length;++t){if(0===t&&!r)continue;let s=i.shape[t],o=n[e][t];if(null!=o&&o>=0&&s!==o)throw new ho(`${a} expected a batch of elements where each example has shape [${n[e].slice(1,n[e].length)}] (i.e.,tensor shape [*,${n[e].slice(1,n[e].length)}]) but the ${a} received an input with ${i.shape[0]} examples, each with shape [${i.shape.slice(1,i.shape.length)}] (tensor shape [${i.shape}])`)}}return s}function fz(e,t,n,r=!0,a=""){let s;if(Array.isArray(e)){if(e.length!==t.length)throw new ho(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);s=e}else{if(t.length>1)throw new ho(`The model expects ${t.length} ${a} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);s=[e]}if(null!=n)for(let e=0;e<t.length;++e){if(null==n[e])continue;let i=s[e];if(i.shape.length!==n[e].length)throw new ho(`Error when checking ${a}: expected ${t[e]} to have ${n[e].length} dimension(s), but got array with shape ${JSON.stringify(i.shape)}`);for(let s=0;s<n[e].length;++s){if(0===s&&!r)continue;let o=i.shape[s],l=n[e][s];if(null!=l&&l!==o)throw new ho(`Error when checking ${a}: expected ${t[e]} to have shape ${JSON.stringify(n[e])} but got array with shape ${JSON.stringify(i.shape)}.`)}}}class fP extends fv{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new ho("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function(e,t,n,r=console.log){var a;let s,i=function(e){let t=!0,n=[],r=[];for(let t in e.nodesByDepth)n.push(e.nodesByDepth[t]);for(let e of n){if(e.length>1||1===e.length&&e[0].inboundLayers.length>1){t=!1;break}r.push(...e)}if(t)for(let n of e.layers){let e=!1;for(let a of n.inboundNodes)if(-1!==r.indexOf(a))if(e){t=!1;break}else e=!0;if(!t)break}return t}(e),o=["Layer (type)","Input Shape","Output shape","Param #"];if(i?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(e=>Math.floor(t*e))),!i)for(let t in o.push("Receives inputs"),s=[],e.nodesByDepth)s.push(...e.nodesByDepth[t]);r("_".repeat(t)),fy(o,n,r),r("=".repeat(t));let l=e.layers;for(let e=0;e<l.length;++e)i?function(e,t,n){let r,a;try{a=e.inboundNodes.map(e=>JSON.stringify(e.inputShapes)).join(",")}catch(e){a="multiple"}try{r=JSON.stringify(e.outputShape)}catch(e){r="multiple"}let s=e.name,i=e.getClassName();fy([`${s} (${i})`,a,r,e.countParams().toString()],t,n)}(l[e],n,r):function(e,t,n,r){let a,s;try{s=e.inboundNodes.map(e=>JSON.stringify(e.inputShapes)).join(",")}catch(e){s="multiple"}try{a=JSON.stringify(e.outputShape)}catch(e){a="multiple"}let i=[];for(let t of e.inboundNodes)if(null==n||!(n.length>0)||-1!==n.indexOf(t))for(let e=0;e<t.inboundLayers.length;++e){let n=t.inboundLayers[e].name,r=t.nodeIndices[e],a=t.tensorIndices[e];i.push(`${n}[${r}][${a}]`)}let o=e.name,l=e.getClassName(),u=0===i.length?"":i[0];fy([`${o} (${l})`,s,a,e.countParams().toString(),u],t,r);for(let e=1;e<i.length;++e)fy(["","","","",i[e]],t,r)}(l[e],n,s,r),r((e===l.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let u=null!=(a=e).collectedTrainableWeights?dV(a.collectedTrainableWeights):dV(a.trainableWeights),h=dV(e.nonTrainableWeights);r(`Total params: ${u+h}`),r(`Trainable params: ${u}`),r(`Non-trainable params: ${h}`),r("_".repeat(t))}(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function(e){let t={Adagrad:()=>fm.adagrad(.01),Adadelta:()=>fm.adadelta(1,.95,dr()),Adam:()=>fm.adam(.001,.9,.999,dr()),Adamax:()=>fm.adamax(.002,.9,.999,dr(),0),RMSProp:()=>fm.rmsprop(.001,.9,0,dr()),SGD:()=>fm.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new ho(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof s6))throw new ho("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new ho(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(e=>fi(e))}else{let n=fi(e.loss);this.outputs.forEach(e=>{t.push(n)})}else{for(let t in e.loss=e.loss,e.loss)if(-1===this.outputNames.indexOf(t))throw new ho(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(let n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(fi(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let e=0;e<this.outputs.length;++e){let t=this.internalOutputShapes[e],n=this.outputNames[e];this.feedOutputNames.push(n),this.feedOutputShapes.push(t),this.feedLossFns.push(this.lossFunctions[e])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],hW("loss",()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;let t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}});let r=function(e,t){let n;if(null==e||Array.isArray(e)&&0===e.length)return t.map(e=>[]);if("string"==typeof e||"function"==typeof e)n=[e];else if(Array.isArray(e)||"object"==typeof e)n=e;else throw TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);if(Array.isArray(n))return t.map(e=>n);{let e=[];for(let r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),a=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};hW("metric",()=>{for(let e=0;e<this.outputs.length;++e){if(-1===n.indexOf(e))(t=>{let n,r,s;for(let i of t){let t;if("string"==typeof i&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(i)){let t,a=this.internalOutputShapes[e];1===a[a.length-1]||this.lossFunctions[e]===fr?-1!==["accuracy","acc"].indexOf(i)?r=fo:-1!==["crossentropy","ce"].indexOf(i)&&(r=fp):this.lossFunctions[e]===fn?-1!==["accuracy","acc"].indexOf(i)?r=fd:-1!==["crossentropy","ce"].indexOf(i)&&(r=fn):-1!==["accuracy","acc"].indexOf(i)?r=fl:-1!==["crossentropy","ce"].indexOf(i)&&(r=ft),-1!==["accuracy","acc"].indexOf(i)?t="acc":-1!==["crossentropy","ce"].indexOf(i)&&(t="ce"),s=r,n=""+t}else s=function(e){if("string"==typeof e&&e in fc)return fc[e];if("string"!=typeof e&&null!=e)return e;throw new ho(`Unknown metric ${e}`)}(i),n=""+ff(i);hW(n,()=>{t=s}),a(e,n,t)}})(r[e])}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){let r=null==n.batchSize?32:n.batchSize;fE(r);let a=this.standardizeUserDataXY(e,t,!0,r);try{let e=a[0].concat(a[1]);this.makeTestFunction();let t=this.testFunction,s=this.testLoop(t,e,r,n.verbose,n.steps);return hf(s)}finally{fD(a[0],e),fD(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),f$(this,e,t)}checkNumSamples(e,t,n,r="steps"){let a;if(null!=n){if(a=null,null!=t)throw new ho(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(null!=e)a=Array.isArray(e)?e[0].shape[0]:e.shape[0];else throw new ho(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return a}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new ho("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),r=n?t:[t],a=this.retrieveSymbolicTensors(r),s=new d4;if(e instanceof aA&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new ho(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)s.add(this.inputs[t],e[t])}else for(let t of this.inputs){let n=e[t.name];if(null==n)throw new ho(`No value is provided for the model's input ${t.name}`);s.add(t,n)}let i=d8(a,s);return n?i:i[0]}retrieveSymbolicTensors(e){let t=hp(null,e.length),n=e.length;for(let r of this.layers){let a=Array.isArray(r.output)?r.output:[r.output],s=a.map(e=>e.name);for(let r=0;r<e.length;++r){let i=s.indexOf(e[r]);if(-1!==i&&(t[r]=a[i],n--),0===n)break}if(0===n)break}if(n>0){let n=[];throw t.forEach((t,r)=>{null==t&&n.push(e[r])}),new ho(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e,t=32,n=!1){return st(()=>{let r=this.checkNumSamples(e);if(n)throw new hl("Verbose predictLoop() is not implemented yet.");let a=fF(r,t),s=this.outputs.map(e=>[]);for(let t=0;t<a.length;++t)st(()=>{let n=fA(e,a[t][0],a[t][1]),r=[];if(Array.isArray(n))for(let e=0;e<n.length;++e)r.push({key:this.inputs[e],value:n[e]});else r.push({key:this.inputs[0],value:n});let s=new d4(r);return d8(this.outputs,s)}).forEach((e,t)=>s[t].push(e));return hf(s.map(e=>lq(e,0)))})}predict(e,t={}){let n=f_(e);fz(n,this.inputNames,this.feedInputShapes,!1);try{let e=null==t.batchSize?32:t.batchSize;return fE(e),this.predictLoop(n,e)}finally{fD(n,e)}}predictOnBatch(e){fz(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(null==this.optimizer_)throw new hi("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let a=[];for(let e=0;e<this.feedOutputShapes.length;++e){let t=this.feedOutputShapes[e];this.feedLossFns[e]===fn?a.push(t.slice(0,t.length-1).concat([1])):a.push(t)}e=fL(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=fL(t,this.feedOutputNames,a,!1,"target");var s=e,i=t;let o=hk(s.map(e=>e.shape[0]));o.sort();let l=hk(i.map(e=>e.shape[0]));if(l.sort(),o.length>1)throw new ho(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(s.map(e=>e.shape))}`);if(l.length>1)throw new ho(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(i.map(e=>e.shape))}`);if(o.length>0&&l.length>0&&!ha.arraysEqual(o,l))throw new ho(`Input Tensors should have the same number of samples as target Tensors. Found ${o[0]} input sample(s) and ${l[0]} target sample(s).`);if(!function(e,t,n){let r=[c7,fr,ft];for(let a=0;a<e.length;++a){let s=e[a],i=t[a],o=n[a];if(null!=i){if(i===ft&&1===s.shape[s.shape.length-1])throw new ho(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){let e=s.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){let r=e[n],a=t[n];if(null!=a&&r!==a)throw new ho(`A target Tensor with shape ${s.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=r&&r>0&&e[0].shape[0]%r!=0)throw new ho(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r,a=!0,s){let[i,o]=this.standardizeUserDataXY(e,t,a,s);if(null!=n)throw Error("sample weight is not supported yet.");let l=null;if(null!=r){let e=fk(r,this.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(await fN(o[t],null,e[t]))}return[i,o,l]}testLoop(e,t,n,r=0,a){return st(()=>{let s=this.checkNumSamples(t,n,a,"steps"),i=[];if(r>0)throw new hl("Verbose mode is not implemented yet.");if(null!=a)throw new hl("steps mode in testLoop() is not implemented yet");{let r=fF(s,n),a=hZ(dn(0,s));for(let n=0;n<r.length;++n){let s=r[n][0],o=r[n][1],l=e(fR(t,di(a,s,o-s)));if(0===n)for(let e=0;e<l.length;++e)i.push(sQ(0));for(let e=0;e<l.length;++e){let t=l[e];i[e]=sG(i[e],sK(o-s,t))}}for(let e=0;e<i.length;++e)i[e]=sq(i[e],s)}return i})}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let r=e[n],a=r;if(hc(e,r)>1){let t=hc(e.slice(0,n),r);a+=`_${t}`}t.push(a)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),s=[],i=()=>{let e,i=[];for(let e=0;e<this.inputs.length;++e)i.push({key:this.inputs[e],value:n[e]});let o=new d4(i),l=d8(this.outputs,o,{training:!0});for(let n=0;n<this.lossFunctions.length;++n){let s=(0,this.lossFunctions[n])(r[n],l[n]);null!=a[n]&&(s=sK(s,a[n]));let i=uA(s);t.push(i),e=0===n?s:sG(e,s)}for(let e=0;e<this.metricsTensors.length;++e){let n;if(this.outputs.length>1&&e<this.outputs.length)n=t[e];else{let t=this.metricsTensors[e][0],a=this.metricsTensors[e][1];n=uA(t(r[a],l[a]))}sr(n),s.push(n)}return e=uA(e),this.calculateLosses().forEach(t=>{e=sG(e,t)}),e},o=this.collectedTrainableWeights.map(e=>e.read());return[this.optimizer_.minimize(i,!0,o)].concat(s)}}makeTestFunction(){this.testFunction=e=>st(()=>{let t,n=[],r=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let e=0;e<this.inputs.length;++e)s.push({key:this.inputs[e],value:r[e]});let i=new d4(s),o=d8(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){let r=uA((0,this.lossFunctions[e])(a[e],o[e]));t=0===e?r:sG(t,r),n.push(t)}for(let e=0;e<this.metricsTensors.length;++e){let t=this.metricsTensors[e][0],r=this.metricsTensors[e][1],s=uA(t(a[r],o[r]));n.push(s)}return n})}async fit(e,t,n={}){let r,a,s,i,o,l,u,h,p;if(this.isTraining)throw Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;try{let d,c,f,m=null==n.batchSize?32:n.batchSize;fE(m);let g=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,!1,m);r=g[0],a=g[1],p=g[2];let y=!1;if(null!=n.validationData&&n.validationData.length>0){if(y=!0,2===n.validationData.length)o=n.validationData[0],l=n.validationData[1];else if(3===n.validationData.length)throw new hl("validationData including sample weights is not supported yet.");else throw new ho(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let e=await this.standardizeUserData(o,l,null,null,!0,m);u=e[0],h=e[1],d=u.concat(h)}else if(null!=n.validationSplit&&n.validationSplit>0&&n.validationSplit<1){y=!0;let e=Math.floor(r[0].shape[0]*(1-n.validationSplit)),t=r[0].shape[0];u=fA(r,e,t),s=r,r=fA(r,0,e),h=fA(a,e,t),i=a,a=fA(a,0,e),d=u.concat(h)}else null!=n.validationSteps&&(y=!0);let x=r.concat(a).concat(p);this.checkTrainableWeightsConsistency();let b=this.makeTrainFunction(),w=this.getDedupedMetricsNames();y?(this.makeTestFunction(),c=this.testFunction,f=w.slice().concat(w.map(e=>"val_"+e))):(c=null,d=[],f=w.slice());let v=cM(n.callbacks,n.yieldEvery);return await this.fitLoop(b,x,w,m,n.epochs,n.verbose,v,c,d,n.shuffle,f,n.initialEpoch,null,null)}finally{this.isTraining=!1,fD(r,e),fD(a,t),fD(s,e),fD(i,t),fD(u,o),fD(h,l),null!=p&&sn(p)}}async fitLoop(e,t,n,r,a,s,i,o,l,u,h,p,d,c){let f;null==r&&(r=32),null==a&&(a=1),null==u&&(u=!0),null==p&&(p=0);let m=!1;if(null!=o&&null!=l&&(m=!0),null!=c&&(m=!0,null==d))throw new ho("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let g=this.checkNumSamples(t,r,d,"steps_per_epoch");null!=g&&(f=dn(0,g)),null==s&&(s=1);let{callbackList:y,history:x}=cz(i,s,a,p,g,d,r,m,h);y.setModel(this),this.history=x,await y.onTrainBegin(),this.stopTraining_=!1;for(let s=p;s<a;++s){await y.onEpochBegin(s);let a={};if(null!=d)throw new hl("stepsPerEpoch mode is not implemented yet.");{if("batch"===u)throw new hl("batch shuffling is not implemneted yet");u&&ha.shuffle(f);let s=hZ(f),i=fF(g,r);for(let u=0;u<i.length;++u){let h={};if(await y.onBatchBegin(u,h),st(()=>{let p=i[u][0],d=i[u][1],c=di(s,p,d-p);h.batch=u,h.size=d-p;let f=e(fR(t,c));for(let e=0;e<n.length;++e){let t=n[e],r=f[e];h[t]=r,sr(r)}if(u===i.length-1&&m){let e=this.testLoop(o,l,r);for(let t=0;t<n.length;++t){let r=n[t],s=e[t];sr(s),a["val_"+r]=s}}}),await y.onBatchEnd(u,h),cA(h),this.stopTraining_)break}s.dispose()}if(await y.onEpochEnd(s,a),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return fC(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),r=n[0],a=n[1],s=this.makeTrainFunction()(r.concat(a)),i=[];for(let e of s){let t=await e.data();i.push(t[0])}return sn(s),fD(n[0],e),fD(n[1],t),hf(i)}getNamedWeights(e){let t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,a=this.getWeights(n);for(let e=0;e<r.length;++e)(!n||r[e].trainable)&&t.push({name:r[e].originalName,tensor:a[e]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){let t=se().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-se().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=hg(this.loss);else if(Array.isArray(this.loss)){for(let e of this.loss)if("string"!=typeof e)throw Error("Serialization of non-string loss is not supported.");e=this.loss.map(e=>hg(e))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let r of t)if("string"==typeof n[r])e[r]=hg(n[r]);else throw Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[hg(ff(this.metrics))];{if(Array.isArray(this.metrics))return this.metrics.map(e=>hg(ff(e)));let e={};for(let t in this.metrics)e[t]=hg(ff(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){let t,n;if(null!=e.weighted_metrics)throw Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw Error("Loading sample_weight_mode is not supported yet.");let r=c6(fb(e.optimizer_config));if("string"==typeof e.loss)t=hy(e.loss);else if(Array.isArray(e.loss))t=e.loss.map(e=>hy(e));else if(null!=e.loss)for(let n in t={},e.loss)t[n]=hy(e.loss[n]);if(Array.isArray(e.metrics))n=e.metrics.map(e=>hy(e));else if(null!=e.metrics)for(let t in n={},e.metrics)n[t]=hy(e.metrics[t]);this.compile({loss:t,metrics:n,optimizer:r})}async save(e,t){if("string"==typeof e){let t=c5.getSaveHandlers(e);if(0===t.length)throw new ho(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new ho(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new ho("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await c5.encodeWeights(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${fw}`,convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){r.trainingConfig=this.getTrainingConfig();let{data:e,specs:t}=await c5.encodeWeights(await this.optimizer.getWeights(),"optimizer");n.specs.push(...t),n.data=c5.concatenateArrayBuffers([n.data,e])}return null!=this.userDefinedMetadata&&(fg(this.userDefinedMetadata,this.name,!0),r.userDefinedMetadata=this.userDefinedMetadata),r.weightData=n.data,r.weightSpecs=n.specs,e.save(r)}setUserDefinedMetadata(e){fg(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}fP.className="Model",hT.registerClass(fP);class fB extends fP{}fB.className="Functional",hT.registerClass(fB);var c5=c5,hT=hT,ha=ha;async function fW(e,t){"modelTopology"in e||(e={modelTopology:e});let n=e.modelTopology;null!=n.model_config&&(n=n.model_config);let r=c6(fb(n),t);if(null!=e.weightsManifest){let t=await c5.loadWeights(e.weightsManifest,e.pathPrefix,r.weights.map(e=>e.originalName)),n={};for(let e of r.weights)n[e.originalName]=t[e.originalName];r.loadWeights(n),sn(t)}return r}class fU extends fP{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:hA("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(e=>e<0))throw new ho(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){let t,n=e instanceof fU||e instanceof fP;if(n){if(1!==(t=e).outputs.length)throw new ho("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==t.inputs.length)throw new ho("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new ho("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let t=d3({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(n)this.outputs=t.outputs,this.inputs=t.inputs;else{if(1!==e.inboundNodes.length)throw new ho(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new ho("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=function e(t,n,r){if((null==n||null!=r&&r>0)&&(n=t.sourceLayer,r=t.nodeIndex),0===n.inboundNodes.length)return[t];{let t=n.inboundNodes[r];if(0===t.inboundLayers.length)return t.inputTensors;{let n=[];for(let r=0;r<t.inboundLayers.length;r++)for(let a of e(t.inputTensors[r],t.inboundLayers[r],t.nodeIndices[r]))-1===n.indexOf(a)&&n.push(a);return n}}}(this.outputs[0])}this.inboundNodes=[],new dQ({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:hp(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(e=>e.shape),outputShapes:this.outputs[0].shape})}else{let t=e.apply(this.outputs[0]);if(Array.isArray(t))throw TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(dj(e),0===this.inputs.length||0===this.outputs.length)throw TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new fP({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new hi("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new hi("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new hi("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new hi("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,n={},r=!1){let a,s={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new ho("Legacy serialization format not supported yet.");a=t}else ha.assert(null!=t.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),a=t.layers,delete t.layers,s=t;let i=new e(s);if(!(i instanceof fU))throw new hl(`Sequential.fromConfig called on non-Sequential input: ${i}`);for(let e of a){let t=c6(e,void 0,r);r&&t.setFastWeightInitDuringBuild(!0),i.add(t)}return i}set stopTraining(e){if(null==this.model)throw new ho("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new ho("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let e=[];for(let t of this.layers){let n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}function fj(e){return d3(e)}fU.className="Sequential",hT.registerClass(fU);var hT=hT,hT=hT;class fV extends hT.Serializable{getConfig(){return{}}}class fG extends fV{apply(e,t=1){return function(e,t=1){if(1!==t)throw new hl(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return oZ(e)}(e,t)}}fG.className="elu",hT.registerClass(fG);class fH extends fV{apply(e){return uV(e)}}fH.className="selu",hT.registerClass(fH);class fq extends fV{apply(e){return o0(e)}}fq.className="relu",hT.registerClass(fq);class fK extends fV{apply(e){return st(()=>uR(6,o0(e)))}}fK.className="relu6",hT.registerClass(fK);class fX extends fV{apply(e){return e}}fX.className="linear",hT.registerClass(fX);class fY extends fV{apply(e){return o2(e)}}fY.className="sigmoid",hT.registerClass(fY);class fZ extends fV{apply(e){return st(()=>ut(sG(.5,sK(.2,e)),0,1))}}fZ.className="hardSigmoid",hT.registerClass(fZ);class fJ extends fV{apply(e){return uk(e)}}fJ.className="softplus",hT.registerClass(fJ);class fQ extends fV{apply(e){return st(()=>sq(e,sG(ia(e),1)))}}fQ.className="softsign",hT.registerClass(fQ);class f0 extends fV{apply(e){return uJ(e)}}f0.className="tanh",hT.registerClass(f0);class f1 extends fV{apply(e,t=-1){return uq(e,t)}}f1.className="softmax",hT.registerClass(f1);class f2 extends fV{apply(e,t=-1){return uI(e,t)}}f2.className="logSoftmax",hT.registerClass(f2);class f3 extends fV{apply(e){return st(()=>st(()=>{let t=sK(.5,sG(1,uu(sq(e,Math.sqrt(2)))));return sK(e,t)}))}}f3.className="gelu",hT.registerClass(f3);class f4 extends fV{apply(e){return st(()=>sK(.5,sK(e,sG(1,uJ(sK(sX(sq(2,Math.PI)),sG(e,sK(.044715,ie(e,3)))))))))}}f4.className="gelu_new",hT.registerClass(f4);class f5 extends fV{apply(e){return st(()=>sK(e,uJ(uk(e))))}}f5.className="mish",hT.registerClass(f5);class f6 extends fV{apply(e,t=1){return st(()=>sK(o2(sK(e,t)),e))}}function f8(e){return e.getClassName()}function f7(e,t={}){return hw(e,hT.SerializationMap.getMap().classNameMap,t,"activation")}function f9(e){if(null==e){let e={};return e.className="linear",e.config={},f7(e)}if("string"==typeof e){let t={};return t.className=e,t.config={},f7(t)}return e instanceof fV?e:f7(e)}f6.className="swish",hT.registerClass(f6);var hT=hT;function me(e){if(null!=e&&"object"!=typeof e)throw Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}class mt extends hT.Serializable{}class mn extends mt{constructor(e){super(),me(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return st(()=>{let t=oy([1]);return this.hasL1&&(t=sG(t,ix(sK(this.l1,ia(e))))),this.hasL2&&(t=sG(t,ix(sK(this.l2,sK(e,e))))),iy(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}mn.className="L1L2",hT.registerClass(mn);let mr={l1l2:"L1L2"};function ma(e,t={}){return hw(e,hT.SerializationMap.getMap().classNameMap,t,"regularizer")}function ms(e){return null==e?null:"string"==typeof e?ma({className:e in mr?mr[e]:e,config:{}}):e instanceof mt?e:ma(e)}class mi extends d1{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){let n=o0(e=dU(e));return null!=this.maxValue&&(n=ut(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue};return Object.assign(e,super.getConfig()),e}}mi.className="ReLU",hT.registerClass(mi);class mo extends d1{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){return oJ(dU(e),this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha};return Object.assign(e,super.getConfig()),e}}mo.className="LeakyReLU",hT.registerClass(mo);class ml extends d1{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=dP(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=ms(e.alphaRegularizer),this.alphaConstraint=co(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if("number"==typeof e.sharedAxes)this.sharedAxes=[e.sharedAxes];else throw new ho(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){let t=(e=dj(e)).slice(1);if(null!=this.sharedAxes)for(let e of this.sharedAxes)t[e-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(null!=this.sharedAxes)for(let t=1;t<e.length;++t)n[t]=e[t];this.inputSpec=[new dY({ndim:e.length,axes:n})],this.built=!0}call(e,t){return oQ(e=dU(e),this.alpha.read())}getConfig(){let e={alphaInitializer:hb(this.alphaInitializer),alphaRegularizer:hb(this.alphaRegularizer),alphaConstraint:hb(this.alphaConstraint),sharedAxes:this.sharedAxes};return Object.assign(e,super.getConfig()),e}}ml.className="PReLU",hT.registerClass(ml);class mu extends d1{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new hl(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){return oZ(dU(e))}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha};return Object.assign(e,super.getConfig()),e}}mu.className="ELU",hT.registerClass(mu);class mh extends d1{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){let n=dU(e);return sK(n,sU(ou(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta};return Object.assign(e,super.getConfig()),e}}mh.className="ThresholdedReLU",hT.registerClass(mh);class mp extends d1{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=new f1().apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){return st(()=>{let n=dU(e),r=t.mask;if(null!=r){let e=sK(it(ox(n.shape),sU(r,n.dtype)),sQ(-1e9));n=sG(n,e)}if(this.axis instanceof Array)if(this.axis.length>1)return on(it(n,uS(n,this.axis,!0)));else return this.softmax(n,this.axis[0]);return this.softmax(n,this.axis)})}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis};return Object.assign(e,super.getConfig()),e}}mp.className="Softmax",hT.registerClass(mp);let md=a4({conv3dTranspose_:function(e,t,n,r,a){return iX(n,a1(e,"x","conv3dTranspose"),a1(t,"filter","conv3dTranspose"),r,a)}});var p8=hY;let mc=a4({conv3d_:function(e,t,n,r,a="NDHWC",s=[1,1,1]){let i=a1(e,"x","conv3d"),o=a1(t,"filter","conv3d"),l=i,u=!1;4===i.rank&&(u=!0,l=iy(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),te(5===l.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),te(5===o.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),te(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),te(iA(n,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),te("NDHWC"===a,()=>`Error in conv3d: got dataFormat of ${a} but only NDHWC is currently supported.`),te(iR(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),te(iR(n),()=>"Error in conv3D: Strides should be larger than 0.");let h={x:l,filter:o},p=aH.runKernel(nu,h,{strides:n,pad:r,dataFormat:a,dilations:s});return u?iy(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}});var hT=hT;function mf(e,t,n){if("number"==typeof e)return hp(e,t);if(e.length!==t)throw new ho(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){let a=e[r];if(a!==parseInt(a.toString(),10))throw new ho(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`)}return e}function mm(e,t,n,r,a=1){return null==e?e:Math.floor((("same"===n?e:e-(t+(t-1)*(a-1))+1)+r-1)/r)}function mg(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+dt([n-t,0]);else if("same"===r)e*=t;else throw new ho(`Unsupport padding mode: ${r}.`);return e}function my(e,t){return st(()=>(hL(t),"channelsFirst"===t)?i9(e,[0,2,3,1]):e)}function mx(e,t){return st(()=>(hL(t),"channelsFirst"===t)?i9(e,[0,2,3,4,1]):e)}function mb(e,t,n,r=[1,1],a="valid",s,i,o=null){return st(()=>{if(null==s&&(s=da()),hL(s),3!==e.rank&&4!==e.rank)throw new ho(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new ho(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=my(e,s);if("causal"===a)throw new hl("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=p8.conv2d({x:l,filter:t,strides:r,pad:"same"===a?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===s&&(l=i9(l,[0,3,1,2])),l})}class mw extends d1{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",mw.verifyArgs(t),this.rank=e,hS(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new hl(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=mf(t.kernelSize,e,"kernelSize"),this.strides=mf(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,hz(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,hL(this.dataFormat),this.activation=f9(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=dP(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=co(t.biasConstraint),this.biasRegularizer=ms(t.biasRegularizer),this.activityRegularizer=ms(t.activityRegularizer),this.dilationRate=mf(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new ho(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new ho(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new ho(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(hd("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!hI(e.kernelSize,"number",1,3))throw new ho(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){let e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:f8(this.activation),useBias:this.useBias,biasInitializer:hb(this.biasInitializer),biasRegularizer:hb(this.biasRegularizer),activityRegularizer:hb(this.activityRegularizer),biasConstraint:hb(this.biasConstraint)};return Object.assign(e,super.getConfig()),e}}class mv extends mw{constructor(e,t){super(e,t),this.kernel=null,mv.verifyArgs(t),this.filters=t.filters,hS(this.filters,"filters"),this.kernelInitializer=dP(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=co(t.kernelConstraint),this.kernelRegularizer=ms(t.kernelRegularizer)}build(e){e=dj(e);let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new ho(`The channel dimension of the input should be defined. Found ${e[t]}`);let n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return st(()=>{let t;e=dU(e);let n=null==this.bias?null:this.bias.read(),r=hC(this.activation.getClassName());if(null!=r&&2===this.rank)t=mb(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=function(e,t,n,r=1,a="valid",s,i=1){return st(()=>{if(null==s&&(s=da()),hL(s),3!==e.shape.length)throw new ho(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new ho(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new ho(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if("channelsFirst"===s&&(e=i9(e,[0,2,1])),"causal"===a)throw new hl("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=un(e,t,r,"same"===a?"same":"valid","NWC",i);return null!=n&&(o=dy(o,n)),o})}(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=mb(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(3===this.rank)t=function(e,t,n,r=[1,1,1],a="valid",s,i){return st(()=>{if(null==s&&(s=da()),hL(s),4!==e.rank&&5!==e.rank)throw new ho(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new ho(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=mx(e,s);if("causal"===a)throw new hl("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=mc(o,t,r,"same"===a?"same":"valid","NDHWC",i),null!=n&&(o=dy(o,n)),"channelsFirst"===s&&(o=i9(o,[0,4,1,2,3])),o})}(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new hl("convolutions greater than 3D are not implemented yet.");null!=this.activation&&(t=this.activation.apply(t))}return t})}computeOutputShape(e){e=dj(e);let t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let e=0;e<n.length;++e){let r=mm(n[e],this.kernelSize[e],this.padding,this.strides[e],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[e]);t.push(r)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t)).push(this.filters):(r.push(this.filters),r=r.concat(t)),r}getConfig(){let e={filters:this.filters,kernelInitializer:hb(this.kernelInitializer),kernelRegularizer:hb(this.kernelRegularizer),kernelConstraint:hb(this.kernelConstraint)};return Object.assign(e,super.getConfig()),e}static verifyArgs(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new ho(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class mk extends mv{constructor(e){super(2,e),mk.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!hI(e.kernelSize,"number",1,2))throw new ho(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}mk.className="Conv2D",hT.registerClass(mk);class mN extends mv{constructor(e){super(3,e),mN.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!(Array.isArray(e.kernelSize)&&(1===e.kernelSize.length||3===e.kernelSize.length)))throw new ho(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}mN.className="Conv3D",hT.registerClass(mN);class mI extends mk{constructor(e){if(super(e),this.inputSpec=[new dY({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new ho(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=dj(e)).length)throw new ho("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new ho("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new dY({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return st(()=>{let t,n,r=dU(e);if(4!==r.shape.length)throw new ho(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);let a=r.shape,s=a[0];"channelsFirst"===this.dataFormat?(t=2,n=3):(t=1,n=2);let i=a[t],o=a[n],l=this.kernelSize[0],u=this.kernelSize[1],h=this.strides[0],p=this.strides[1],d=[s,mg(i,h,l,this.padding),mg(o,p,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(r=i9(r,[0,2,3,1]));let c=ur(r,this.kernel.read(),d,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(c=i9(c,[0,3,1,2])),null!=this.bias&&(c=dy(c,this.bias.read(),this.dataFormat)),null!=this.activation&&(c=this.activation.apply(c)),c})}computeOutputShape(e){let t,n,r,a=(e=dj(e)).slice();"channelsFirst"===this.dataFormat?(t=1,n=2,r=3):(t=3,n=1,r=2);let s=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return a[t]=this.filters,a[n]=mg(a[n],o,s,this.padding),a[r]=mg(a[r],l,i,this.padding),a}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}}mI.className="Conv2DTranspose",hT.registerClass(mI);class mS extends mN{constructor(e){if(super(e),this.inputSpec=[new dY({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new ho(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=dj(e)).length)throw new ho("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new ho("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new dY({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return st(()=>{let t,n,r,a=dU(e);if(5!==a.shape.length)throw new ho(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${a.shape.length}`);let s=a.shape,i=s[0];"channelsFirst"===this.dataFormat?(r=2,t=3,n=4):(r=1,t=2,n=3);let o=s[r],l=s[t],u=s[n],h=this.kernelSize[0],p=this.kernelSize[1],d=this.kernelSize[2],c=this.strides[0],f=this.strides[1],m=this.strides[2],g=[i,mg(o,c,h,this.padding),mg(l,f,p,this.padding),mg(u,m,d,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(a=i9(a,[0,2,3,4,1]));let y=md(a,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(y=i9(y,[0,4,1,2,3])),null!==this.bias&&(y=dy(y,this.bias.read(),this.dataFormat)),null!==this.activation&&(y=this.activation.apply(y)),y})}computeOutputShape(e){let t,n,r,a,s=(e=dj(e)).slice();"channelsFirst"===this.dataFormat?(t=1,n=2,r=3,a=4):(t=4,n=1,r=2,a=3);let i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],h=this.strides[1],p=this.strides[2];return s[t]=this.filters,s[n]=mg(s[n],u,i,this.padding),s[r]=mg(s[r],h,o,this.padding),s[a]=mg(s[a],p,l,this.padding),s}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}}mS.className="Conv3DTranspose",hT.registerClass(mS);class mC extends mv{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new ho("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new ho("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new ho(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=dP(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=ms(t.depthwiseRegularizer),this.depthwiseConstraint=co(t.depthwiseConstraint),this.pointwiseInitializer=dP(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=ms(t.pointwiseRegularizer),this.pointwiseConstraint=co(t.pointwiseConstraint)}build(e){if((e=dj(e)).length<this.rank+2)throw new ho(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new ho(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),a=[];for(let e=0;e<this.rank;++e)a.push(1);a.push(n*this.depthMultiplier,this.filters),this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,!0,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.inputSpec=[new dY({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return st(()=>{let t;if(e=dU(e),1===this.rank)throw new hl("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=i9(e,[0,2,3,1])),t=uG(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=dy(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=i9(t,[0,3,1,2])),t})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=hb(this.depthwiseInitializer),e.pointwiseInitializer=hb(this.pointwiseInitializer),e.depthwiseRegularizer=hb(this.depthwiseRegularizer),e.pointwiseRegularizer=hb(this.pointwiseRegularizer),e.depthwiseConstraint=hb(this.depthwiseConstraint),e.pointwiseConstraint=hb(this.pointwiseConstraint),e}}mC.className="SeparableConv";class mT extends mC{constructor(e){super(2,e)}}mT.className="SeparableConv2D",hT.registerClass(mT);class m$ extends mv{constructor(e){super(1,e),m$.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){let e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!hI(e.kernelSize,"number",1,1))throw new ho(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}m$.className="Conv1D",hT.registerClass(m$);class mE extends d1{constructor(e){super(e),"number"==typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return st(()=>{if(e=dU(e),"channelsLast"===this.dataFormat){let t=du(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return du(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{let t=du(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return du(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat};return Object.assign(e,super.getConfig()),e}}mE.className="Cropping2D",hT.registerClass(mE);class mA extends d1{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,hL(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,hN(hF,"InterpolationFormat",this.interpolation)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){let t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{let t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return st(()=>{let t=dU(e),n=t.shape;if("channelsFirst"===this.dataFormat){t=i9(t,[0,2,3,1]);let e=this.size[0]*n[2],r=this.size[1]*n[3];return i9("nearest"===this.interpolation?pW.resizeNearestNeighbor(t,[e,r]):pW.resizeBilinear(t,[e,r]),[0,3,1,2])}{let e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?pW.resizeNearestNeighbor(t,[e,r]):pW.resizeBilinear(t,[e,r])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation};return Object.assign(e,super.getConfig()),e}}mA.className="UpSampling2D",hT.registerClass(mA);var hT=hT;class mR extends mw{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=dP(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=co(e.depthwiseConstraint),this.depthwiseRegularizer=ms(e.depthwiseRegularizer)}build(e){if((e=dj(e)).length<4)throw new ho(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new ho(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return st(()=>{let t=function(e,t,n=[1,1],r="valid",a,s){return st(()=>{null==a&&(a=da()),hL(a);let s=my(e,a);if(4!==e.rank)throw new ho(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new ho(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return s=us(s,t,n,"same"===r?"same":"valid","NHWC",null),"channelsFirst"===a&&(s=i9(s,[0,3,1,2])),s})}(e=dU(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,0);return this.useBias&&(t=dy(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t})}computeOutputShape(e){e=dj(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=mm(t,this.kernelSize[0],this.padding,this.strides[0]),s=mm(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,a,s]:[e[0],a,s,r]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=hb(this.depthwiseInitializer),e.depthwiseRegularizer=hb(this.depthwiseRegularizer),e.depthwiseConstraint=hb(this.depthwiseRegularizer),e}}mR.className="DepthwiseConv2D",hT.registerClass(mR);var hT=hT,ha=ha,hT=hT,ha=ha;function mF(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new ho("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function a(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=a(t),constants:n=a(n)}}function m_(e,t,n,r=!1,a,s,i=!1,o=!1){return st(()=>{let l,u,h,p=t.shape.length;if(p<3)throw new ho(`Input should be at least 3D, but is ${p}D.`);let d=[1,0].concat(dn(2,p));if(t=i9(t,d),null!=s)throw new hl("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=a&&((a=sU(sU(a,"bool"),"float32")).rank===p-1&&(a=lX(a,-1)),a=i9(a,d)),r&&(t=lB(t,0),null!=a&&(a=lB(a,0)));let c=[],f=n,m=t.shape[0],g=ov(t);null!=a&&(u=ov(a));for(let t=0;t<m;++t){let n=g[t],r=st(()=>e(n,f));if(null==a)l=r[0],f=r[1];else{let e=st(()=>{let e=u[t],n=it(uM(e),e);return{output:sG(sK(r[0],e),sK(f[0],n)),newStates:f.map((t,a)=>sG(sK(r[1][a],e),sK(t,n)))}});l=e.output,f=e.newStates}o&&c.push(l)}return o&&(h=os(c,1)),[l,h,f]})}class mD extends d1{constructor(e){let t;if(super(e),null==e.cell)throw new ho("cell property is missing for the constructor of RNN.");if(null==(t=Array.isArray(e.cell)?new mU({cells:e.cell}):e.cell).stateSize)throw new ho("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new dY({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?dn(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(e=>null):this.states_}setStates(e){this.states_=e}computeOutputShape(e){let t;dB(e)&&(e=e[0]);let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);let r=n[0];if(t=this.returnSequences?[e[0],e[1],r]:[e[0],r],!this.returnState)return t;{let r=[];for(let t of n)r.push([e[0],t]);return[t].concat(r)}}computeMask(e,t){return st(()=>{Array.isArray(t)&&(t=t[0]);let e=this.returnSequences?t:null;return this.returnState?[e].concat(this.states.map(e=>null)):e})}get states(){if(null!=this.states_)return this.states_;{let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}}set states(e){this.states_=e}build(e){let t;if(null!=this.numConstants)throw new hl("Constants support is not implemented in RNN yet.");dB(e)&&(e=e[0]);let n=this.stateful?e[0]:null,r=e.slice(2);this.inputSpec[0]=new dY({shape:[n,null,...r]});let a=[e[0]].concat(e.slice(2));if(this.cell.build(a),t=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!ha.arraysEqual(this.stateSpec.map(e=>e.shape[e.shape.length-1]),t))throw new ho(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=t.map(e=>new dY({shape:[null,e]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){st(()=>{if(!this.stateful)throw new hs("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape[0];if(null==n)throw new ho("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(e=>oy([n,e])):this.states_=[oy([n,this.cell.stateSize])];else if(null==e)sn(this.states_),null!=this.keptStates&&(sn(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(e=>oy([n,e])):this.states_[0]=oy([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new ho(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):sn(this.states_);for(let t=0;t<this.states_.length;++t){let r=e[t],a=[n,Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize];if(!ha.arraysEqual(r.shape,a))throw new ho(`State ${t} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map(e=>sr(e.clone()))})}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});let a=mF(e,n,r,this.numConstants);e=a.inputs,n=a.initialState,r=a.constants;let s=[],i=[];if(null!=n){for(let e of(t.initialState=n,s=s.concat(n),this.stateSpec=[],n))this.stateSpec.push(new dY({shape:e.shape}));i=i.concat(this.stateSpec)}if(null!=r&&(t.constants=r,s=s.concat(r),this.numConstants=r.length),!(s[0]instanceof dZ))return super.apply(e,t);{let n=[e].concat(s),r=this.inputSpec.concat(i),a=this.inputSpec;this.inputSpec=r;let o=super.apply(n,t);return this.inputSpec=a,o}}call(e,t){return st(()=>{let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;e=dU(e),null==a&&(a=this.stateful?this.states_:this.getInitialState(e));let s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==s)throw new ho(`RNN Layer has ${s} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let i={training:r},o=m_((e,t)=>{let n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]},e,a,this.goBackwards,n,null,this.unroll,this.returnSequences),l=o[0],u=o[1],h=o[2];this.stateful&&this.resetStates(h,r);let p=this.returnSequences?u:l;return this.returnState?[p].concat(h):p})}getInitialState(e){return st(()=>{let t=oy(e.shape);return(t=ds(t=ix(t,[1,2])),Array.isArray(this.cell.stateSize))?this.cell.stateSize.map(e=>e>1?dd(t,[1,e]):t):this.cell.stateSize>1?[dd(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){let e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);let n=this.cell.getConfig();return this.getClassName()===mD.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t,n={}){let r=c6(t.cell,n);return new e(Object.assign(t,{cell:r}))}}mD.className="RNN",hT.registerClass(mD);class mO extends d1{}class mM extends mO{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,hS(this.units,"units"),this.activation=f9(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=dP(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=dP(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=dP(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ms(e.kernelRegularizer),this.recurrentRegularizer=ms(e.recurrentRegularizer),this.biasRegularizer=ms(e.biasRegularizer),this.kernelConstraint=co(e.kernelConstraint),this.recurrentConstraint=co(e.recurrentConstraint),this.biasConstraint=co(e.biasConstraint),this.dropout=de([1,dt([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=de([1,dt([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=dj(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return st(()=>{let n;if(2!==e.length)throw new ho(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let r=e[1];e=e[0];let a=null!=t.training&&t.training;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=mj({ones:()=>uM(e),rate:this.dropout,training:a,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=mj({ones:()=>uM(r),rate:this.recurrentDropout,training:a,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,i=this.recurrentDropoutMask;n=null!=s?df(sK(e,s),this.kernel.read()):df(e,this.kernel.read()),null!=this.bias&&(n=dy(n,this.bias.read())),null!=i&&(r=sK(r,i));let o=sG(n,df(r,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:f8(this.activation),useBias:this.useBias,kernelInitializer:hb(this.kernelInitializer),recurrentInitializer:hb(this.recurrentInitializer),biasInitializer:hb(this.biasInitializer),kernelRegularizer:hb(this.kernelRegularizer),recurrentRegularizer:hb(this.recurrentRegularizer),biasRegularizer:hb(this.biasRegularizer),activityRegularizer:hb(this.activityRegularizer),kernelConstraint:hb(this.kernelConstraint),recurrentConstraint:hb(this.recurrentConstraint),biasConstraint:hb(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}mM.className="SimpleRNNCell",hT.registerClass(mM);class mL extends mD{constructor(e){e.cell=new mM(e),super(e)}call(e,t){return st(()=>{null!=this.cell.dropoutMask&&(sn(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(sn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})})}static fromConfig(e,t){return new e(t)}}mL.className="SimpleRNN",hT.registerClass(mL);class mz extends mO{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new ho("GRUCell does not support reset_after parameter set to true.");this.units=e.units,hS(this.units,"units"),this.activation=f9(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=f9(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=dP(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=dP(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=dP(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ms(e.kernelRegularizer),this.recurrentRegularizer=ms(e.recurrentRegularizer),this.biasRegularizer=ms(e.biasRegularizer),this.kernelConstraint=co(e.kernelConstraint),this.recurrentConstraint=co(e.recurrentConstraint),this.biasConstraint=co(e.biasConstraint),this.dropout=de([1,dt([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=de([1,dt([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){let t=(e=dj(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return st(()=>{let n,r;if(2!==e.length)throw new ho(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let a=null!=t.training&&t.training,s=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=mj({ones:()=>uM(e),rate:this.dropout,training:a,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=mj({ones:()=>uM(s),rate:this.recurrentDropout,training:a,count:3,dropoutFunc:this.dropoutFunc}));let i=this.dropoutMask,o=this.recurrentDropoutMask;0<this.dropout&&this.dropout<1&&(e=sK(e,i[0]));let l=df(e,this.kernel.read());this.useBias&&(l=dy(l,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=sK(s,o[0]));let u=this.recurrentKernel.read(),[h,p]=iV(u,[2*this.units,this.units],u.rank-1),d=df(s,h),[c,f,m]=iV(l,3,l.rank-1),[g,y]=iV(d,2,d.rank-1);n=this.recurrentActivation.apply(sG(c,g));let x=df(sK(this.recurrentActivation.apply(sG(f,y)),s),p);r=this.activation.apply(sG(m,x));let b=sG(sK(n,s),sK(sG(1,ig(n)),r));return[b,b]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:f8(this.activation),recurrentActivation:f8(this.recurrentActivation),useBias:this.useBias,kernelInitializer:hb(this.kernelInitializer),recurrentInitializer:hb(this.recurrentInitializer),biasInitializer:hb(this.biasInitializer),kernelRegularizer:hb(this.kernelRegularizer),recurrentRegularizer:hb(this.recurrentRegularizer),biasRegularizer:hb(this.biasRegularizer),activityRegularizer:hb(this.activityRegularizer),kernelConstraint:hb(this.kernelConstraint),recurrentConstraint:hb(this.recurrentConstraint),biasConstraint:hb(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}mz.className="GRUCell",hT.registerClass(mz);class mP extends mD{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new mz(e),super(e)}call(e,t){return st(()=>{null!=this.cell.dropoutMask&&(sn(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(sn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})})}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}mP.className="GRU",hT.registerClass(mP);class mB extends mO{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,hS(this.units,"units"),this.activation=f9(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=f9(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=dP(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=dP(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=dP(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=ms(e.kernelRegularizer),this.recurrentRegularizer=ms(e.recurrentRegularizer),this.biasRegularizer=ms(e.biasRegularizer),this.kernelConstraint=co(e.kernelConstraint),this.recurrentConstraint=co(e.recurrentConstraint),this.biasConstraint=co(e.biasConstraint),this.dropout=de([1,dt([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=de([1,dt([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;let n,r=(e=dj(e))[e.length-1];if(this.kernel=this.addWeight("kernel",[r,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){let e=this.biasInitializer,r=this.units;n=new((t=class extends dv{apply(t,n){let a=e.apply([r]),s=new dN().apply([r]),i=e.apply([2*r]);return dp(dp(a,s),i)}}).className="CustomInit",t)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return st(()=>{let n,r,a=null!=t.training&&t.training;if(3!==e.length)throw new ho(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let s=e[1],i=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=mj({ones:()=>uM(e),rate:this.dropout,training:a,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=mj({ones:()=>uM(s),rate:this.recurrentDropout,training:a,count:4,dropoutFunc:this.dropoutFunc}));let o=this.dropoutMask,l=this.recurrentDropoutMask;0<this.dropout&&this.dropout<1&&(e=sK(e,o[0]));let u=df(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=sK(s,l[0])),u=sG(u,df(s,this.recurrentKernel.read())),this.useBias&&(u=dy(u,this.bias.read()));let[h,p,d,c]=iV(u,4,u.rank-1);n=this.recurrentActivation.apply(h),r=sG(sK(this.recurrentActivation.apply(p),i),sK(n,this.activation.apply(d)));let f=sK(this.recurrentActivation.apply(c),this.activation.apply(r));return[f,f,r]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:f8(this.activation),recurrentActivation:f8(this.recurrentActivation),useBias:this.useBias,kernelInitializer:hb(this.kernelInitializer),recurrentInitializer:hb(this.recurrentInitializer),biasInitializer:hb(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:hb(this.kernelRegularizer),recurrentRegularizer:hb(this.recurrentRegularizer),biasRegularizer:hb(this.biasRegularizer),activityRegularizer:hb(this.activityRegularizer),kernelConstraint:hb(this.kernelConstraint),recurrentConstraint:hb(this.recurrentConstraint),biasConstraint:hb(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}mB.className="LSTMCell",hT.registerClass(mB);class mW extends mD{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new mB(e),super(e)}call(e,t){return st(()=>{null!=this.cell.dropoutMask&&(sn(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(sn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})})}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}mW.className="LSTM",hT.registerClass(mW);class mU extends mO{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return st(()=>{let n,r=e.slice(1),a=[];for(let e of this.cells.slice().reverse())Array.isArray(e.stateSize)?a.push(r.splice(0,e.stateSize.length)):a.push(r.splice(0,1));a.reverse();let s=[];for(let i=0;i<this.cells.length;++i){let o=this.cells[i];r=a[i],n=0===i?[e[0]].concat(r):[n[0]].concat(r),n=o.call(n,t),s.push(n.slice(1))}for(let e of(r=[],s.slice().reverse()))r.push(...e);return[n[0]].concat(r)})}build(e){let t;dB(e)&&(e=e[0]),this.cells.forEach((n,r)=>{hW(`RNNCell_${r}`,()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){let e=super.getConfig(),t=this.cells.map(e=>({className:e.getClassName(),config:e.getConfig()}));return Object.assign(Object.assign({},e),{cells:t})}static fromConfig(e,t,n={}){let r=[];for(let e of t.cells)r.push(c6(e,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return dK(e)}setWeights(e){let t=[];for(let n of this.cells){let r=n.weights.length,a=e.splice(r);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],a[e]])}dX(t)}}function mj(e){let{ones:t,rate:n,training:r=!1,count:a=1,dropoutFunc:s}=e,i=()=>{var e;return null!=s?s(t(),n):(e=t(),st(()=>p7(e,n,void 0,void 0)))},o=()=>dx(i,t,r);return!a||a<=1?sr(o().clone()):Array(a).fill(void 0).map(o).map(e=>sr(e.clone()))}mU.className="StackedRNNCells",hT.registerClass(mU);var mV=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&0>t.indexOf(r)&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols)for(var a=0,r=Object.getOwnPropertySymbols(e);a<r.length;a++)0>t.indexOf(r[a])&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]]);return n};class mG extends mD{constructor(e){if(e.unroll)throw new hl("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new hl("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new dY({ndim:5})]}call(e,t){return st(()=>{if(null!=this.cell.dropoutMask&&(sn(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(sn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new ho("ConvRNN2D cell does not support constants");let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...[,,].fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return st(()=>{let{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),a=oy([r[0],...r.slice(2)]);return Array.isArray(t)?Array(t.length).fill(a):[a]})}resetStates(e,t=!1){st(()=>{if(!this.stateful)throw new hs("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)];if(null==n[0])throw new ho("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>oy(a)):this.states_=[oy(a)];else if(null==e)sn(this.states_),null!=this.keptStates&&(sn(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>oy(a)):this.states_[0]=oy(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new ho(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):sn(this.states_);for(let t=0;t<this.states_.length;++t){let n=e[t];if(!ha.arraysEqual(n.shape,a))throw new ho(`State ${t} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map(e=>sr(e.clone()))})}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:r,padding:a,strides:s,dilationRate:i}=this.cell,o="channelsFirst"===t,l=e[o?3:2],u=e[o?4:3],h=mm(l,r[0],a,s[0],i[0]),p=mm(u,r[1],a,s[1],i[1]);return[...e.slice(0,2),...o?[n,h,p]:[h,p,n]]}}mG.className="ConvRNN2D";class mH extends mB{constructor(e){const{filters:t,kernelSize:n,strides:r,padding:a,dataFormat:s,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,hS(this.filters,"filters"),this.kernelSize=mf(n,2,"kernelSize"),this.kernelSize.forEach(e=>hS(e,"kernelSize")),this.strides=mf(r||1,2,"strides"),this.strides.forEach(e=>hS(e,"strides")),this.padding=a||"valid",hz(this.padding),this.dataFormat=s||"channelsLast",hL(this.dataFormat),this.dilationRate=mf(i||1,2,"dilationRate"),this.dilationRate.forEach(e=>hS(e,"dilationRate"))}build(e){var t;e=dj(e);let n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new ho(`The channel dimension of the input should be defined. Found ${e[n]}`);let r=e[n],a=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let s=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",s,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){let n=this.biasInitializer,r=this.filters;e=new((t=class extends dv{apply(e,t){return dh([n.apply([r]),ox([r]),n.apply([2*r])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return st(()=>{if(3!==e.length)throw new ho(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,r=e[0],a=e[1],s=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=mj({ones:()=>uM(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let i=this.dropoutMask,o=(e,t,n)=>t&&t[n]?sK(t[n],e):e,l=o(r,i,0),u=o(r,i,1),h=o(r,i,2),p=o(r,i,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=mj({ones:()=>uM(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let d=this.recurrentDropoutMask,c=o(a,d,0),f=o(a,d,1),m=o(a,d,2),g=o(a,d,3),[y,x,b,w]=iV(this.kernel.read(),4,3),[v,k,N,I]=this.useBias?iV(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,y,v,this.padding),u=this.inputConv(u,x,k,this.padding),h=this.inputConv(h,b,N,this.padding),p=this.inputConv(p,w,I,this.padding);let[S,C,T,$]=iV(this.recurrentKernel.read(),4,3);c=this.recurrentConv(c,S),f=this.recurrentConv(f,C),m=this.recurrentConv(m,T),g=this.recurrentConv(g,$);let E=this.recurrentActivation.apply(sG(l,c)),A=this.recurrentActivation.apply(sG(u,f)),R=sG(sK(A,s),sK(E,this.activation.apply(sG(h,m)))),F=sK(this.recurrentActivation.apply(sG(p,g)),this.activation.apply(R));return[F,F,R]})}getConfig(){let e=super.getConfig(),{units:t}=e,n=mV(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,t,n,r){let a=iq(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?dy(a,n,this.dataFormat):a}recurrentConv(e,t){return iq(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}mH.className="ConvLSTM2DCell",hT.registerClass(mH);class mq extends mG{constructor(e){super(Object.assign(Object.assign({},e),{cell:new mH(e)}))}static fromConfig(e,t){return new e(t)}}mq.className="ConvLSTM2D",hT.registerClass(mq);var hT=hT,ha=ha;class mK extends d1{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;let t=e.shape,n=[];for(let e=0;e<this.noiseShape.length;++e)n.push(null==this.noiseShape[e]?t[e]:this.noiseShape[e]);return n}call(e,t){return st(()=>{this.invokeCallHook(e,t);let n=dU(e);if(0<this.rate&&this.rate<1){let e=null!=t.training&&t.training,r=this.getNoiseShape(n);return dx(()=>{var e,t;return e=this.rate,t=this.seed,st(()=>p7(n,e,r,t))},()=>n,e)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed};return Object.assign(e,super.getConfig()),e}dispose(){return super.dispose()}}mK.className="Dropout",hT.registerClass(mK);class mX extends mK{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}}mX.className="SpatialDropout1D",hT.registerClass(mX);class mY extends d1{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,hS(this.units,"units"),this.activation=f9(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=dP(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=dP(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=co(e.kernelConstraint),this.biasConstraint=co(e.biasConstraint),this.kernelRegularizer=ms(e.kernelRegularizer),this.biasRegularizer=ms(e.biasRegularizer),this.activityRegularizer=ms(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){let t=(e=dj(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){let t=(e=dj(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return st(()=>{let n;this.invokeCallHook(e,t);let r=dU(e),a=hC(this.activation.getClassName());return null!=a?n=df(r,this.kernel.read(),a,this.bias?this.bias.read():null):(n=df(r,this.kernel.read()),null!=this.bias&&(n=dy(n,this.bias.read())),null!=this.activation&&(n=this.activation.apply(n))),n})}getConfig(){let e={units:this.units,activation:f8(this.activation),useBias:this.useBias,kernelInitializer:hb(this.kernelInitializer),biasInitializer:hb(this.biasInitializer),kernelRegularizer:hb(this.kernelRegularizer),biasRegularizer:hb(this.biasRegularizer),activityRegularizer:hb(this.activityRegularizer),kernelConstraint:hb(this.kernelConstraint),biasConstraint:hb(this.biasConstraint)};return Object.assign(e,super.getConfig()),e}}mY.className="Dense",hT.registerClass(mY);class mZ extends d1{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){for(let t of(e=dj(e)).slice(1))if(null==t)throw new ho(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],p9(e,1)]}call(e,t){return st(()=>{this.invokeCallHook(e,t);let n=dU(e);if("channelsFirst"===this.dataFormat&&n.rank>1){let e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=i9(n,e)}var r=n;if(r.rank<=1)throw new ho(`batchFlatten requires a minimum rank of 2. Got rank: ${r.rank}.`);let a=[r.shape[0],p9(r.shape,1)];return iy(r,a)})}getConfig(){let e={};return null!=this.dataFormat&&(e.dataFormat=this.dataFormat),Object.assign(e,super.getConfig()),e}}mZ.className="Flatten",hT.registerClass(mZ);class mJ extends d1{constructor(e){super(e),this.supportsMasking=!0,this.activation=f9(e.activation)}call(e,t){return st(()=>{this.invokeCallHook(e,t);let n=dU(e);return this.activation.apply(n)})}getConfig(){let e={activation:f8(this.activation)};return Object.assign(e,super.getConfig()),e}}mJ.className="Activation",hT.registerClass(mJ);class mQ extends d1{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return st(()=>{var t,n;return t=e=dU(e),n=this.n,st(()=>{if(2!==t.shape.length)throw new ho(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);return dd(ds(t,1),[1,n,1])})})}getConfig(){let e={n:this.n};return Object.assign(e,super.getConfig()),e}}mQ.className="RepeatVector",hT.registerClass(mQ);class m0 extends d1{constructor(e){super(e),this.targetShape=e.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",r=t.slice(),a=1,s=null;for(let e=0;e<r.length;++e){let t=r[e];if(this.isUnknown(t))if(null===s)s=e;else throw new ho("Can only specifiy one unknown dimension.");else a*=t}let i=p9(e);if(null!==s){if(0===a||i%a!=0)throw new ho(n);r[s]=i/a}else if(i!==a)throw new ho(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return st(()=>{this.invokeCallHook(e,t);let n=dU(e),r=n.shape;return iy(n,r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape)))})}getConfig(){let e={targetShape:this.targetShape};return Object.assign(e,super.getConfig()),e}}m0.className="Reshape",hT.registerClass(m0);class m1 extends d1{constructor(e){if(super(e),null==e.dims)throw Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=dn(1,e.dims.length+1);if(!ha.arraysEqual(e.dims.slice().sort(),t))throw Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new dY({ndim:this.dims.length+1})]}computeOutputShape(e){let t=(e=dj(e)).slice();return this.dims.forEach((n,r)=>{t[r+1]=e[n]}),t}call(e,t){return i9(dU(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims};return Object.assign(e,super.getConfig()),e}}m1.className="Permute",hT.registerClass(m1);class m2 extends d1{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e?this.maskValue=null==e.maskValue?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){return l0(uD(dU(e),this.maskValue),-1)}call(e,t){return st(()=>{this.invokeCallHook(e,t);let n=dU(e),r=l0(uD(n,this.maskValue),-1,!0);return sK(n,sU(r,n.dtype))})}}m2.className="Masking",hT.registerClass(m2);var hT=hT;class m3 extends d1{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(hm(e.inputLength))}this.inputDim=e.inputDim,hS(this.inputDim,"inputDim"),this.outputDim=e.outputDim,hS(this.outputDim,"outputDim"),this.embeddingsInitializer=dP(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=ms(e.embeddingsRegularizer),this.activityRegularizer=ms(e.activityRegularizer),this.embeddingsConstraint=co(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return st(()=>this.maskZero?uD(e=dU(e),sZ(e)):null)}computeOutputShape(e){if(e=dj(e),null==this.inputLength)return[...e,this.outputDim];let t=hm(this.inputLength);if(t.length!==e.length-1)throw new ho(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){let a=t[r],s=e[r+1];if(null!=a&&null!=s&&a!==s)throw new ho(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==a&&(t[n]=s),n++}}return[e[0],...t,this.outputDim]}call(e,t){return st(()=>{this.invokeCallHook(e,t);let n=dU(e);"int32"!==n.dtype&&(n=sU(n,"int32"));let r=dm(this.embeddings.read(),iy(n,[n.size]));return iy(r,dj(this.computeOutputShape(n.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:hb(this.embeddingsInitializer),embeddingsRegularizer:hb(this.embeddingsRegularizer),activityRegularizer:hb(this.activityRegularizer),embeddingsConstraint:hb(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength};return Object.assign(e,super.getConfig()),e}}m3.className="Embedding",hT.registerClass(m3);var ha=ha,hT=hT;class m4 extends d1{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new hl}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;let n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){let a=e[e.length-t.length+r],s=t[r];if(null==a||null==s||a<0||s<0)n.push(null);else if(1===a)n.push(s);else if(1===s)n.push(a);else{if(a!==s)throw new ho("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(a)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[dj(e)]),e.length<2)throw new ho(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let n of e)null!=n&&null!==n[0]&&t.push(n[0]);if((t=hk(t)).length>1)throw new ho(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let t=1;t<e.length;++t){let r=null==e[t]?null:e[t].slice(1);n=this.computeElementwiseOpOutputShape(n,r)}let r=e.map(e=>e.length);-1===e.indexOf(null)&&1===hk(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return st(()=>{if(!this.reshapeRequired)return this.mergeFunction(e);{let t=[],n=e.map(e=>e.rank);if(-1===n.indexOf(null)){let r=dt(n);for(let n of e){let e=n.rank;for(let t=0;t<r-e;++t)n=ds(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(let r of e){let e=r.rank;if(null==e){let e=r.shape,a=e[0],s=e.slice(1).concat([a]),i=iy(r,[a].concat(p9(e.slice(1))));i=iy(i=i9(i,[1,0]),s),t.push(i),n=!0}else if(e>1){let a=dn(1,e).concat([0]);t.push(i9(r,a)),n=!0}else t.push(r)}let r=this.mergeFunction(t),a=r.rank;if(n)if(null==a){let e=r.shape,t=e.length,n=e[t-1],a=[n].concat(e.slice(0,e.length-1));r=iy(i9(iy(r,[-1,n]),[1,0]),a)}else a>1&&(r=i9(r,[a-1].concat(dn(0,a-1))));return r}}})}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let n=1;n<e.length;++n){let r=null==e[n]?null:e[n].slice(1);t=this.computeElementwiseOpOutputShape(t,r)}let n=[];for(let t of e)null!=t&&null!==t[0]&&n.push(t[0]);return 1===(n=hk(n)).length?n.concat(t):[null].concat(t)}computeMask(e,t){return st(()=>{if(null==t)return null;if(!Array.isArray(t))throw new ho("`mask` should be an Array");if(!Array.isArray(e))throw new ho("`inputs` should be an Array");if(t.length!==e.length)throw new ho(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(e=>null==e))return null;let n=(t=t.map(e=>null==e?e:lX(e,0)))[0];for(let e=1;e<t.length-1;++e)n=iB(n,t[e]);return n})}}class m5 extends m4{constructor(e){super(e)}mergeFunction(e){return st(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=sG(t,e[n]);return t})}}m5.className="Add",hT.registerClass(m5);class m6 extends m4{constructor(e){super(e)}mergeFunction(e){return st(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=sK(t,e[n]);return t})}}m6.className="Multiply",hT.registerClass(m6);class m8 extends m4{constructor(e){super(e)}mergeFunction(e){return st(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=sG(t,e[n]);return sK(1/e.length,t)})}}m8.className="Average",hT.registerClass(m8);class m7 extends m4{constructor(e){super(e)}mergeFunction(e){return st(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=il(t,e[n]);return t})}}m7.className="Maximum",hT.registerClass(m7);class m9 extends m4{constructor(e){super(e)}mergeFunction(e){return st(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=uR(t,e[n]);return t})}}m9.className="Minimum",hT.registerClass(m9);class ge extends m4{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||1===e.length)throw new ho("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(let n of e)if(null!=n){t=!1;break}if(t)return;let n=[];for(let t=0;t<e.length;++t){let r=e[t].slice();r.splice(this.axis,1);let a=!1;for(let e of n)if(ha.arraysEqual(e,r)){a=!0;break}a||n.push(r)}if(n.length>1)throw new ho("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return st(()=>dh(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new ho("A `Concatenate` layer should be called on a list of inputs.");let t=e[0].slice(),n=this.axis<0?t.length+this.axis:this.axis;for(let r of e.slice(1)){if(null==t[n]||null==r[n]){t[n]=null;break}t[n]+=r[n]}return t}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new ho("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new ho("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new ho(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return st(()=>{let n=!0;if(t.forEach(e=>{if(null!=e){n=!1;return}}),n)return null;let r=[];for(let n=0;n<e.length;++n)null==t[n]?r.push(sU(uM(e[n]),"bool")):t[n].rank<e[n].rank?r.push(lX(t[n],-1)):r.push(t[n]);return lQ(lq(r,this.axis),-1,!1)})}getConfig(){let e={axis:this.axis};return Object.assign(e,super.getConfig()),e}}function gt(e,t){for(;e<0;)e+=t;return e}ge.className="Concatenate",hT.registerClass(ge);class gn extends m4{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){ha.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new hl("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new ho(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){let t;if(2!==e.length)throw new ho(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let n=e[0],r=e[1];t=Array.isArray(this.axes)?this.axes.map((t,n)=>gt(t,e[n].shape.length)):[gt(this.axes,n.shape.length),gt(this.axes,r.shape.length)],this.normalize&&(n=c8(n,t[0]),r=c8(r,t[1]));var a=n,s=r,i=t;if(a.shape.length>3||s.shape.length>3)throw new hl("batchDot is not implemented for tensors of 4D or higher rank yet");if(ha.assert(a.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${a.shape.length}`),ha.assert(a.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${s.shape.length}`),"number"==typeof i&&(i=[i,i]),"complex64"===a.dtype||"complex64"===s.dtype)throw new hl("batchDot is not implemented for complex64-type Tensors yet.");let o=a.shape.length,l=s.shape.length;null==i&&(i=[o-1,l-2]);let u=i;return st(()=>{let e,t;if(o>l){e=o-l;let t=[];for(let n=0;n<e;++n)t.push(1);s=iy(s,s.shape.concat(t))}else if(l>o){e=l-o;let t=[];for(let n=0;n<e;++n)t.push(1);a=iy(a,a.shape.concat(t))}else e=0;if(2===a.shape.length&&2===s.shape.length)t=u[0]===u[1]?ix(sK(a,s),u[0]):ix(sK(i9(a,[1,0]),s),u[1]);else{let e=u[0]!==a.shape.length-1,n=u[1]===s.shape.length-1;t=iM(a,s,e,n)}if(e>0){let n;n=o>l?o+l-3:o-1;let r=[];for(let t=n;t<n+e;++t)r.push(t);t=uX(t,r)}return 1===t.shape.length&&(t=lX(t,1)),t})}interpretAxes(e,t){return Array.isArray(this.axes)?this.axes:[gt(this.axes,e.length),gt(this.axes,t.length)]}computeOutputShape(e){ha.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new hl("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);let a=t.concat(n);return 1===a.length&&a.push(1),a}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize};return Object.assign(e,super.getConfig()),e}}gn.className="Dot",hT.registerClass(gn);var hT=hT;class gr extends d1{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return st(()=>{this.invokeCallHook(e,t);let n=dU(e);return dx(()=>sG(dc(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}}gr.className="GaussianNoise",hT.registerClass(gr);class ga extends d1{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return st(()=>{this.invokeCallHook(e,t);let n=dU(e);return this.rate>0&&this.rate<1?dx(()=>{let e=Math.sqrt(this.rate/(1-this.rate));return sK(n,dc(n.shape,1,e))},()=>n,t.training||!1):n})}}ga.className="GaussianDropout",hT.registerClass(ga);class gs extends d1{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||dU(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return st(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return dx(()=>{let t=dU(e),r=iz(pY(n),this.rate);r=sU(r,"float32");let a=((1-this.rate)*(1+3.09091329228798*this.rate))**-.5,s=-(-1.7580993408473766*a)*this.rate,i=sG(sK(t,r),sK(sG(r,-1),-1.7580993408473766));return sG(sK(i,a),s)},()=>dU(e),t.training||!1)}return e})}}gs.className="AlphaDropout",hT.registerClass(gs);let gi=a4({batchNorm4d_:function(e,t,n,r,a,s){let i,o,l=a1(e,"x","batchNorm"),u=a1(t,"mean","batchNorm"),h=a1(n,"variance","batchNorm");return null!=a&&(i=a1(a,"scale","batchNorm")),null!=r&&(o=a1(r,"offset","batchNorm")),te(4===l.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${l.rank}.`),te(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${u.rank}.`),te(4===h.rank||1===h.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${h.rank}.`),null!=i&&te(4===i.rank||1===i.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${i.rank}.`),null!=o&&te(4===o.rank||1===o.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${o.rank}.`),l9(l,u,h,o,i,s)}}),go=a4({batchNorm3d_:function(e,t,n,r,a,s){let i,o,l=a1(e,"x","batchNorm"),u=a1(t,"mean","batchNorm"),h=a1(n,"variance","batchNorm");return null!=a&&(i=a1(a,"scale","batchNorm")),null!=r&&(o=a1(r,"offset","batchNorm")),te(3===l.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${l.rank}.`),te(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${u.rank}.`),te(3===h.rank||1===h.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${h.rank}.`),null!=i&&te(3===i.rank||1===i.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${i.rank}.`),null!=o&&te(3===o.rank||1===o.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${o.rank}.`),l9(l,u,h,o,i,s)}}),gl=a4({batchNorm2d_:function(e,t,n,r,a,s){let i,o,l=a1(e,"x","batchNorm"),u=a1(t,"mean","batchNorm"),h=a1(n,"variance","batchNorm");return null!=a&&(i=a1(a,"scale","batchNorm")),null!=r&&(o=a1(r,"offset","batchNorm")),te(2===l.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${l.rank}.`),te(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${u.rank}.`),te(2===h.rank||1===h.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${h.rank}.`),null!=i&&te(2===i.rank||1===i.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${i.rank}.`),null!=o&&te(2===o.rank||1===o.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${o.rank}.`),l9(l,u,h,o,i,s)}}),gu=a4({moments_:function(e,t=null,n=!1){let r=tf(t,(e=a1(e,"x","moments")).shape),a=uA(e,r,n),s=a.shape;n||(s=i1(a.shape,r));let i=uA(sY(it(sU(e,"float32"),iy(a,s))),r,n);return{mean:a,variance:i}}});var hT=hT,ha=ha;function gh(e,t,n,r,a,s=.001){let i;if(2===e.rank)i=gl(e,t,n,r,a,s);else if(3===e.rank)i=go(e,t,n,r,a,s);else if(4===e.rank)i=gi(e,t,n,r,a,s);else throw new hl(`batchNormalization is not implemented for array of rank ${e.rank} yet`);return i}class gp extends d1{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=dP(e.betaInitializer||"zeros"),this.gammaInitializer=dP(e.gammaInitializer||"ones"),this.movingMeanInitializer=dP(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=dP(e.movingVarianceInitializer||"ones"),this.betaConstraint=co(e.betaConstraint),this.gammaConstraint=co(e.gammaConstraint),this.betaRegularizer=ms(e.betaRegularizer),this.gammaRegularizer=ms(e.gammaRegularizer)}build(e){e=dj(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new ho(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new dY({ndim:e.length,axes:{[t]:n}})];let r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return st(()=>{let n=null!=t.training&&t.training,r=dU(e),a=r.shape,s=a.length,i=dn(0,s),o=this.axis>=0?this.axis:this.axis+s;i.splice(o,1);let l=hp(1,s);l[o]=a[o];let u=i.slice();u.sort();let h=!ha.arraysEqual(u,dn(0,s).slice(0,s-1)),p=()=>h?gh(r,iy(this.movingMean.read(),l),iy(this.movingVariance.read(),l),this.center?iy(this.beta.read(),l):null,this.scale?iy(this.gamma.read(),l):null,this.epsilon):gh(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon);if(!n)return p();let[d,c,f]=function(e,t,n,r,a=.001){return ha.arraysEqual(r.slice().sort(),dn(0,e.rank-1))?function(e,t,n,r,a=.001){return st(()=>{let s=gu(e,r),i=s.mean,o=s.variance;return[gh(e,i,o,n,t,a),i,o]})}(e,t,n,r,a):function(e,t,n,r,a=.001){return st(()=>{let s=gu(e,r),i=s.mean,o=s.variance,l=[];for(let t of dn(0,e.rank))-1!==r.indexOf(t)?l.push(1):l.push(e.shape[t]);let u=iy(i,l),h=iy(o,l),p=null==t?null:iy(t,l);return[gh(e,u,h,null==n?null:iy(n,l),p,a),i,o]})}(e,t,n,r,a)}(r,this.gamma.read(),this.beta.read(),i,this.epsilon),m=(e,t,n)=>{st(()=>{let r=e.read(),a=sK(it(r,t),1-n);e.write(it(r,a))})};return m(this.movingMean,c,this.momentum),m(this.movingVariance,f,this.momentum),d})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:hb(this.betaInitializer),gammaInitializer:hb(this.gammaInitializer),movingMeanInitializer:hb(this.movingMeanInitializer),movingVarianceInitializer:hb(this.movingVarianceInitializer),betaRegularizer:hb(this.betaRegularizer),gammaRegularizer:hb(this.gammaRegularizer),betaConstraint:hb(this.betaConstraint),gammaConstraint:hb(this.gammaConstraint)};return Object.assign(e,super.getConfig()),e}}gp.className="BatchNormalization",hT.registerClass(gp);class gd extends d1{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const e of this.axis)if(!Number.isInteger(e))throw Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=dP(e.betaInitializer||"zeros"),this.gammaInitializer=dP(e.gammaInitializer||"ones"),this.betaRegularizer=ms(e.betaRegularizer),this.gammaRegularizer=ms(e.gammaRegularizer),this.supportsMasking=!0}build(e){let t=(e=dj(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let e=0;e<this.axis.length;++e)this.axis[e]<0&&(this.axis[e]+=t);for(let e of this.axis)if(e<0||e>=t)throw Error(`Invalid axis: ${e}`);if(this.axis.length!==hk(this.axis).length)throw Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(t=>e[t]);this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,!0):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,!0):this.beta=null,this.built=!0}call(e,t){let n=dU(e),r=n.shape,a=r.length;return st(()=>{let{mean:e,variance:t}=gu(n,this.axis,!0),s=hp(1,a);for(let e of this.axis)s[e]=r[e];let i=e=>null!=e&&e.shape.length!==a?iy(e,s):e,o=this.scale?i(this.gamma.read()):null,l=this.center?i(this.beta.read()):null,u=[],h=[];for(let e=0;e<a;++e)-1!==this.axis.indexOf(e)?(u.push(r[e]),h.push(1)):(u.push(1),h.push(r[e]));return e=oa(e,u),t=oa(t,u),null!=o&&(o=oa(o,h)),null!=l&&(l=oa(l,h)),gh(n,e,t,l,o,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:hb(this.betaInitializer),gammaInitializer:hb(this.gammaInitializer),betaRegularizer:hb(this.betaRegularizer),gammaRegularizer:hb(this.gammaRegularizer)};return Object.assign(e,super.getConfig()),e}}gd.className="LayerNormalization",hT.registerClass(gd);var hT=hT;class gc extends d1{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?da():e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{let t,n;if(e.padding=e.padding,2!==e.padding.length)throw new ho(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);if("number"==typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new ho(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new ho(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new dY({ndim:4})]}computeOutputShape(e){let t,n;return(e=dj(e),"channelsFirst"===this.dataFormat)?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return st(()=>{var t,n,r;return t=dU(e),n=this.padding,r=this.dataFormat,st(()=>{if(4!==t.rank)throw new ho(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new ho("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==r&&(r=da()),"channelsLast"!==r&&"channelsFirst"!==r)throw new ho(`Unknown data format: ${r}. Supported data formats are 'channelsLast' and 'channelsFirst.`);return lV(t,"channelsFirst"===r?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]])})})}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat};return Object.assign(e,super.getConfig()),e}}gc.className="ZeroPadding2D",hT.registerClass(gc);let gf=a4({avgPool3d_:function(e,t,n,r,a,s="NDHWC"){let i=a1(e,"x","avgPool3d","float32"),o=i,l=!1;4===i.rank&&(l=!0,o=iy(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),te(5===o.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),te("NDHWC"===s,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),te("number"==typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),i_("avgPool3d",r,a);let u={x:o},h=aH.runKernel(t3,u,{filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s});return(h=sU(h,o.dtype),l)?iy(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),gm=a4({maxPool3d_:function(e,t=[1,1,1],n,r,a,s="NDHWC"){let i=a1(e,"x","maxPool3d"),o=i,l=!1;4===i.rank&&(l=!0,o=iy(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),te(5===o.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),te("NDHWC"===s,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),i_("maxPool3d",r,a);let u={x:o},h=aH.runKernel(n5,u,{filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s});return l?iy(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});var hT=hT;function gg(e,t,n,r,a,s){return st(()=>{let i;hL(a),hP(s),hz(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==a&&(a=da()),null==s&&(s="max"),e=my(e,a);let o="same"===r?"same":"valid";return i="max"===s?uE(e,t,n,o):l7(e,t,n,o),"channelsFirst"===a&&(i=i9(i,[0,3,1,2])),i})}function gy(e,t,n,r,a,s){return st(()=>{let i;hL(a),hP(s),hz(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==a&&(a=da()),null==s&&(s="max"),e=mx(e,a);let o="same"===r?"same":"valid";return i="max"===s?gm(e,t,n,o):gf(e,t,n,o),"channelsFirst"===a&&(i=i9(i,[0,4,1,2,3])),i})}class gx extends d1{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"==typeof e.poolSize)this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&1===e.poolSize.length&&"number"==typeof e.poolSize[0])this.poolSize=e.poolSize;else throw new ho(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(hS(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"==typeof e.strides)this.strides=[e.strides];else if(Array.isArray(e.strides)&&1===e.strides.length&&"number"==typeof e.strides[0])this.strides=e.strides;else throw new ho(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);hS(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,hz(this.padding),this.inputSpec=[new dY({ndim:3})]}computeOutputShape(e){let t=mm((e=dj(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return st(()=>(this.invokeCallHook(e,t),e=ds(dU(e),2),uX(this.poolingFunction(dU(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast"),[2])))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides};return Object.assign(e,super.getConfig()),e}}class gb extends gx{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return hL(a),hz(r),gg(e,t,n,r,a,"max")}}gb.className="MaxPooling1D",hT.registerClass(gb);class gw extends gx{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return hL(a),hz(r),gg(e,t,n,r,a,"avg")}}gw.className="AveragePooling1D",hT.registerClass(gw);class gv extends d1{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new ho(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];hS(this.poolSize,"poolSize"),hS(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,hL(this.dataFormat),hz(this.padding),this.inputSpec=[new dY({ndim:4})]}computeOutputShape(e){e=dj(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return(t=mm(t,this.poolSize[0],this.padding,this.strides[0]),n=mm(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat)?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return st(()=>(this.invokeCallHook(e,t),this.poolingFunction(dU(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat};return Object.assign(e,super.getConfig()),e}}class gk extends gv{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return hL(a),hz(r),gg(e,t,n,r,a,"max")}}gk.className="MaxPooling2D",hT.registerClass(gk);class gN extends gv{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return hL(a),hz(r),gg(e,t,n,r,a,"avg")}}gN.className="AveragePooling2D",hT.registerClass(gN);class gI extends d1{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new ho(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];hS(this.poolSize,"poolSize"),hS(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,hL(this.dataFormat),hz(this.padding),this.inputSpec=[new dY({ndim:5})]}computeOutputShape(e){e=dj(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return(t=mm(t,this.poolSize[0],this.padding,this.strides[0]),n=mm(n,this.poolSize[1],this.padding,this.strides[1]),r=mm(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat)?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return st(()=>(this.invokeCallHook(e,t),this.poolingFunction(dU(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat};return Object.assign(e,super.getConfig()),e}}class gS extends gI{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return hL(a),hz(r),gy(e,t,n,r,a,"max")}}gS.className="MaxPooling3D",hT.registerClass(gS);class gC extends gI{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return hL(a),hz(r),gy(e,t,n,r,a,"avg")}}gC.className="AveragePooling3D",hT.registerClass(gC);class gT extends d1{constructor(e){super(e),this.inputSpec=[new dY({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new hl}}class g$ extends gT{constructor(e){super(e||{})}call(e,t){return st(()=>uA(dU(e),1))}}g$.className="GlobalAveragePooling1D",hT.registerClass(g$);class gE extends gT{constructor(e){super(e||{})}call(e,t){return st(()=>uh(dU(e),1))}}gE.className="GlobalMaxPooling1D",hT.registerClass(gE);class gA extends d1{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,hL(this.dataFormat),this.inputSpec=[new dY({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new hl}getConfig(){let e={dataFormat:this.dataFormat};return Object.assign(e,super.getConfig()),e}}class gR extends gA{call(e,t){return st(()=>{let t=dU(e);return"channelsLast"===this.dataFormat?uA(t,[1,2]):uA(t,[2,3])})}}gR.className="GlobalAveragePooling2D",hT.registerClass(gR);class gF extends gA{call(e,t){return st(()=>{let t=dU(e);return"channelsLast"===this.dataFormat?uh(t,[1,2]):uh(t,[2,3])})}}gF.className="GlobalMaxPooling2D",hT.registerClass(gF);var hT=hT;class g_ extends d1{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}};return Object.assign(e,super.getConfig()),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let r=c6(t.layer,n);delete t.layer;let a={layer:r};return Object.assign(a,t),new e(a)}}class gD extends g_{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=dj(e)).length<3)throw new ho(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){let t=[(e=dj(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return st(()=>m_((e,n)=>[dU(this.layer.call(e,t)),[]],e=dU(e),[],!1,null,null,!1,!0)[1])}}gD.className="TimeDistributed",hT.registerClass(gD);class gO extends g_{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=c6(n),t.goBackwards=!0!==t.goBackwards;const r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=c6(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,hN(hO,"BidirectionalMergeMode",this.mergeMode),e.weights)throw new hl("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=Math.floor(e.length/2);this.forwardLayer.setWeights(e.slice(0,t)),this.backwardLayer.setWeights(e.slice(t))}computeOutputShape(e){let t,n,r,a=this.forwardLayer.computeOutputShape(e);return(Array.isArray(a)&&Array.isArray(a[0])||(a=[a]),this.returnState&&(r=a.slice(1)),t=a[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState)?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):hf(n)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});let a=mF(e,n,r,this.numConstants);if(e=a.inputs,n=a.initialState,r=a.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);let s=[],i=[];if(null!=n){let e=n.length;if(e%2>0)throw new ho("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,s.push(...n);let r=n.map(e=>new dY({shape:e.shape}));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),i.push(...r)}if(null!=r)throw new hl("Support for constants in Bidirectional layers is not implemented yet.");let o=s[0]instanceof dZ;for(let e of s)if(e instanceof dZ!==o)throw new ho("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(!o)return super.apply(e,t);{let n=[e].concat(s),r=this.inputSpec.concat(i),a=this.inputSpec;this.inputSpec=r;let o=super.apply(n,t);return this.inputSpec=a,o}}call(e,t){return st(()=>{let n,r,a,s,i=t.initialState;if(null==i)n=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{let a=i.slice(0,i.length/2),s=i.slice(i.length/2);n=this.forwardLayer.call(e,Object.assign(t,{initialState:a})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:s}))}return(this.returnState&&(Array.isArray(n)&&(a=n.slice(1).concat(r.slice(1))),n=n[0],r=r[0]),this.returnSequences&&(r=lB(r,1)),"concat"===this.mergeMode?s=dh([n,r]):"sum"===this.mergeMode?s=sG(n,r):"ave"===this.mergeMode?s=sK(.5,sG(n,r)):"mul"===this.mergeMode?s=sK(n,r):null==this.mergeMode&&(s=[n,r]),this.returnState)?null==this.mergeMode?s.concat(a):[s].concat(a):s})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){hW(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),hW(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,!this.returnState)return n;{let e=this.forwardLayer.states.map(e=>null);return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode};return Object.assign(e,super.getConfig()),e}static fromConfig(e,t){let n=c6(t.layer);if(delete t.layer,null!=t.numConstants)throw new hl("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");return t.layer=n,new e(t)}}gO.className="Bidirectional",hT.registerClass(gO);var hT=hT;class gM extends d1{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset};return Object.assign(e,super.getConfig()),e}call(e,t){return st(()=>("float32"!==(e=dU(e)).dtype&&(e=sU(e,"float32")),sG(sK(e,this.scale),this.offset)))}}gM.className="Rescaling",hT.registerClass(gM);var hT=hT;let{resizeBilinear:gL,cropAndResize:gz}=pW;class gP extends d1{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,a,s,i,o){return st(()=>{let l,u=!1,h=[t/s,n/i,(r+t)/s,(a+n)/i],p=[];3===e.rank?(u=!0,l=os([e])):l=e;for(let e=0;e<l.shape[0];e++)p.push(h);let d=gz(l,a8(p,[p.length,4]),pm(0,p.length,1,"int32"),[r,a],"nearest");if(u)return sU(dU(ov(d)),o);return sU(d,o)})}upsize(e,t,n,r){return st(()=>sU(gL(e,[t,n]),r))}call(e,t){return st(()=>{let t=dU(e),n=t.dtype,r=t.shape,a=r[r.length-3],s=r[r.length-2],i=0;a!==this.height&&(i=Math.floor((a-this.height)/2));let o=0;return(s!==this.width&&0===(o=Math.floor((s-this.width)/2))&&(o=1),i>=0&&o>=0)?this.centerCrop(t,i,o,this.height,this.width,a,s,n):this.upsize(e,this.height,this.width,n)})}getConfig(){let e={height:this.height,width:this.width};return Object.assign(e,super.getConfig()),e}computeOutputShape(e){let t=(e=dj(e)).length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}}gP.className="CenterCrop",hT.registerClass(gP);var hT=hT;let gB=a4({denseBincount_:function(e,t,n,r=!1){let a=a1(e,"x","denseBincount"),s=a1(t,"weights","denseBincount");return te("int32"===a.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${a.dtype}`),te(a.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${a.rank}.`),te(n>=0,()=>`size must be non-negative, but got ${n}.`),te(s.size===a.size||0===s.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${a.shape}, weights shape: ${s.shape}.`),aH.runKernel(ng,{x:a,weights:s},{size:n,binaryOutput:r})}});class gW extends d1{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode};return Object.assign(e,super.getConfig()),e}computeOutputShape(e){return null==(e=dj(e))?[this.numTokens]:("oneHot"===this.outputMode&&1!==e[e.length-1]?e.push(this.numTokens):e[e.length-1]=this.numTokens,e)}call(e,t){return st(()=>{let n;if("int32"!==(e=dU(e)).dtype&&(e=sU(e,"int32")),void 0!==t.countWeights){if("count"!==this.outputMode)throw new ho(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);n=dU(t.countWeights)}let r=uh(e),a=up(e),s=ou(this.numTokens,r).bufferSync().get(0),i=iz(a,0).bufferSync().get(0);if(!(s&&i))throw new ho(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function(e,t,n,r){let a,s=dU(e);if("int32"!==s.dtype&&(s=sU(s,"int32")),"int"===t)return s;let i=s.shape;if(0===s.rank&&(s=lX(s,-1)),"oneHot"===t&&1!==s.shape[s.shape.length-1]&&(s=lX(s,-1)),s.rank>2)throw new ho(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${i} which would result in output rank ${s.rank}.`);let o=["multiHot","oneHot"].includes(t),l=s;if(a=void 0!==r&&"count"===t?gB(l,r,n,o):gB(l,[],n,o),"tfIdf"!==t)return a;if(r)return sK(a,r);throw new ho("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,n)})}}gW.className="CategoryEncoding",hT.registerClass(gW);var hT=hT;let gU=new Set(["bilinear","nearest"]);class gj extends d1{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(gU.has(e.interpolation))this.interpolation=e.interpolation;else throw new ho(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){let t=(e=dj(e))[2];return[this.height,this.width,t]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio};return Object.assign(e,super.getConfig()),e}call(e,t){return st(()=>{let t=[this.height,this.width];if("bilinear"===this.interpolation)return pW.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return pW.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw Error(`Interpolation is ${this.interpolation} but only ${[...gU]} are supported`)})}}gj.className="Resizing",hT.registerClass(gj);var hT=hT;class gV{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}gV.className="RandomSeed";class gG extends d1{constructor(e){super(e),this.randomGenerator=new gV(e.seed)}getConfig(){let e={seed:this.randomGenerator.seed};return Object.assign(e,super.getConfig()),e}}gG.className="BaseRandomLayer";let gH=new Set(["bilinear","nearest"]);class gq extends gG{constructor(e){super(e);const{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new ho(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new ho(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new ho(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(n)if(gH.has(n))this.interpolation=n;else throw new ho(`Invalid interpolation parameter: ${n} is not implemented`)}getConfig(){let e={factor:this.factor,interpolation:this.interpolation};return Object.assign(e,super.getConfig()),e}computeOutputShape(e){let t=(e=dj(e))[2];return[this.imgHeight,-1,t]}call(e,t){return st(()=>{let t=dU(e);this.imgHeight=t.shape[t.shape.length-3];let n=t.shape[t.shape.length-2];this.widthFactor=pY([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*n;r=Math.round(r);let a=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return pW.resizeBilinear(e,a);case"nearest":return pW.resizeNearestNeighbor(e,a);default:throw Error(`Interpolation is ${this.interpolation}
          but only ${[...gH]} are supported`)}})}}function gK(e){return new d2(e)}function gX(e){return new mu(e)}function gY(e){return new mi(e)}function gZ(e){return new mo(e)}function gJ(e){return new ml(e)}function gQ(e){return new mp(e)}function g0(e){return new mh(e)}function g1(e){return new m$(e)}function g2(e){return new mk(e)}function g3(e){return new mI(e)}function g4(e){return new mN(e)}function g5(e){return new mS(e)}function g6(e){return new mT(e)}function g8(e){return new mE(e)}function g7(e){return new mA(e)}function g9(e){return new mR(e)}function ye(e){return new mJ(e)}function yt(e){return new mY(e)}function yn(e){return new mK(e)}function yr(e){return new mX(e)}function ya(e){return new mZ(e)}function ys(e){return new mQ(e)}function yi(e){return new m0(e)}function yo(e){return new m1(e)}function yl(e){return new m3(e)}function yu(e){return new m5(e)}function yh(e){return new m8(e)}function yp(e){return new ge(e)}function yd(e){return new m7(e)}function yc(e){return new m9(e)}function yf(e){return new m6(e)}function ym(e){return new gn(e)}function yg(e){return new gp(e)}function yy(e){return new gd(e)}function yx(e){return new gc(e)}function yb(e){return new gw(e)}function yw(e){return yb(e)}function yv(e){return yb(e)}function yk(e){return new gN(e)}function yN(e){return yk(e)}function yI(e){return yk(e)}function yS(e){return new gC(e)}function yC(e){return yS(e)}function yT(e){return yS(e)}function y$(e){return new g$(e)}function yE(e){return new gR(e)}function yA(e){return new gE(e)}function yR(e){return new gF(e)}function yF(e){return new gb(e)}function y_(e){return new gk(e)}function yD(e){return new gS(e)}function yO(e){return new mP(e)}function yM(e){return new mz(e)}function yL(e){return new mW(e)}function yz(e){return new mB(e)}function yP(e){return new mL(e)}function yB(e){return new mM(e)}function yW(e){return new mq(e)}function yU(e){return new mH(e)}function yj(e){return new mD(e)}function yV(e){return new mU(e)}function yG(e){return new gO(e)}function yH(e){return new gD(e)}function yq(e){return new gr(e)}function yK(e){return new ga(e)}function yX(e){return new gs(e)}function yY(e){return new m2(e)}function yZ(e){return new gM(e)}function yJ(e){return new gP(e)}function yQ(e){return new gj(e)}function y0(e){return new gW(e)}function y1(e){return new gq(e)}gq.className="RandomWidth",hT.registerClass(gq),e.s(["activation",()=>ye,"add",()=>yu,"alphaDropout",()=>yX,"average",()=>yh,"averagePooling1d",()=>yb,"averagePooling2d",()=>yk,"averagePooling3d",()=>yS,"avgPool1d",()=>yw,"avgPool2d",()=>yN,"avgPool3d",()=>yC,"avgPooling1d",()=>yv,"avgPooling2d",()=>yI,"avgPooling3d",()=>yT,"batchNormalization",()=>yg,"bidirectional",()=>yG,"categoryEncoding",()=>y0,"centerCrop",()=>yJ,"concatenate",()=>yp,"conv1d",()=>g1,"conv2d",()=>g2,"conv2dTranspose",()=>g3,"conv3d",()=>g4,"conv3dTranspose",()=>g5,"convLstm2d",()=>yW,"convLstm2dCell",()=>yU,"cropping2D",()=>g8,"dense",()=>yt,"depthwiseConv2d",()=>g9,"dot",()=>ym,"dropout",()=>yn,"elu",()=>gX,"embedding",()=>yl,"flatten",()=>ya,"gaussianDropout",()=>yK,"gaussianNoise",()=>yq,"globalAveragePooling1d",()=>y$,"globalAveragePooling2d",()=>yE,"globalMaxPool1d",0,yA,"globalMaxPool2d",0,yR,"globalMaxPooling1d",()=>yA,"globalMaxPooling2d",()=>yR,"gru",()=>yO,"gruCell",()=>yM,"inputLayer",()=>gK,"layerNormalization",()=>yy,"leakyReLU",()=>gZ,"lstm",()=>yL,"lstmCell",()=>yz,"masking",()=>yY,"maxPool1d",0,yF,"maxPool2d",0,y_,"maxPooling1d",()=>yF,"maxPooling2d",()=>y_,"maxPooling3d",()=>yD,"maximum",()=>yd,"minimum",()=>yc,"multiply",()=>yf,"permute",()=>yo,"prelu",()=>gJ,"randomWidth",()=>y1,"reLU",()=>gY,"repeatVector",()=>ys,"rescaling",()=>yZ,"reshape",()=>yi,"resizing",()=>yQ,"rnn",()=>yj,"separableConv2d",()=>g6,"simpleRNN",()=>yP,"simpleRNNCell",()=>yB,"softmax",()=>gQ,"spatialDropout1d",()=>yr,"stackedRNNCells",()=>yV,"thresholdedReLU",()=>g0,"timeDistributed",()=>yH,"upSampling2d",()=>g7,"zeroPadding2d",()=>yx],9488),e.i(9488),e.s(["Layer",()=>d1,"RNN",()=>mD,"RNNCell",()=>mO,"activation",()=>ye,"add",()=>yu,"alphaDropout",()=>yX,"average",()=>yh,"averagePooling1d",()=>yb,"averagePooling2d",()=>yk,"averagePooling3d",()=>yS,"avgPool1d",()=>yw,"avgPool2d",()=>yN,"avgPool3d",()=>yC,"avgPooling1d",()=>yv,"avgPooling2d",()=>yI,"avgPooling3d",()=>yT,"batchNormalization",()=>yg,"bidirectional",()=>yG,"categoryEncoding",()=>y0,"centerCrop",()=>yJ,"concatenate",()=>yp,"conv1d",()=>g1,"conv2d",()=>g2,"conv2dTranspose",()=>g3,"conv3d",()=>g4,"conv3dTranspose",()=>g5,"convLstm2d",()=>yW,"convLstm2dCell",()=>yU,"cropping2D",()=>g8,"dense",()=>yt,"depthwiseConv2d",()=>g9,"dot",()=>ym,"dropout",()=>yn,"elu",()=>gX,"embedding",()=>yl,"flatten",()=>ya,"gaussianDropout",()=>yK,"gaussianNoise",()=>yq,"globalAveragePooling1d",()=>y$,"globalAveragePooling2d",()=>yE,"globalMaxPool1d",0,yA,"globalMaxPool2d",0,yR,"globalMaxPooling1d",()=>yA,"globalMaxPooling2d",()=>yR,"gru",()=>yO,"gruCell",()=>yM,"input",()=>fj,"inputLayer",()=>gK,"layerNormalization",()=>yy,"leakyReLU",()=>gZ,"lstm",()=>yL,"lstmCell",()=>yz,"masking",()=>yY,"maxPool1d",0,yF,"maxPool2d",0,y_,"maxPooling1d",()=>yF,"maxPooling2d",()=>y_,"maxPooling3d",()=>yD,"maximum",()=>yd,"minimum",()=>yc,"multiply",()=>yf,"permute",()=>yo,"prelu",()=>gJ,"randomWidth",()=>y1,"reLU",()=>gY,"repeatVector",()=>ys,"rescaling",()=>yZ,"reshape",()=>yi,"resizing",()=>yQ,"rnn",()=>yj,"separableConv2d",()=>g6,"simpleRNN",()=>yP,"simpleRNNCell",()=>yB,"softmax",()=>gQ,"spatialDropout1d",()=>yr,"stackedRNNCells",()=>yV,"thresholdedReLU",()=>g0,"timeDistributed",()=>yH,"upSampling2d",()=>g7,"zeroPadding2d",()=>yx],58628);var y2=e.i(58628);function y3(e,t){return fo(e,t)}function y4(e,t){return fr(e,t)}function y5(e,t){return fd(e,t)}function y6(e,t){return fl(e,t)}function y8(e,t){return ft(e,t)}function y7(e,t){return fh(e,t)}function y9(e,t){return st(()=>{let n=fu(e,t),r=sG(n,st(()=>sU(ix(iB(op(e,1),op(t,0))),"float32")));return sU(iU(ou(r,0),sq(n,r),0),"float32")})}function xe(e,t){return fa(e,t)}function xt(e,t){return c9(e,t)}function xn(e,t){return fe(e,t)}function xr(e,t){return fe(e,t)}function xa(e,t){return fe(e,t)}function xs(e,t){return c7(e,t)}function xi(e,t){return c7(e,t)}function xo(e,t){return c7(e,t)}function xl(e,t){return st(()=>{let n=e.sub(t).square().sum(),r=e.sub(e.mean()).square().sum();return sQ(1).sub(n.div(r))})}function xu(e){return new mn(e)}function xh(e){return me(e),new mn({l1:null!=e?e.l1:null,l2:0})}function xp(e){return me(e),new mn({l2:null!=e?e.l2:null,l1:0})}e.s(["MAPE",()=>xr,"MSE",()=>xi,"binaryAccuracy",()=>y3,"binaryCrossentropy",()=>y4,"categoricalAccuracy",()=>y6,"categoricalCrossentropy",()=>y8,"cosineProximity",()=>xe,"mape",()=>xa,"meanAbsoluteError",()=>xt,"meanAbsolutePercentageError",()=>xn,"meanSquaredError",()=>xs,"mse",()=>xo,"precision",()=>y7,"r2Score",()=>xl,"recall",()=>y9,"sparseCategoricalAccuracy",()=>y5],48140),e.i(48140),e.s([],55826),e.i(55826),e.s(["modelFromJSON",()=>fW],65616),e.i(65616),e.s(["l1",()=>xh,"l1l2",()=>xu,"l2",()=>xp],73022),e.i(73022);e.s([],77134),tU.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var c5=c5,ha=ha;(y=_||(_={}))[y.DT_INVALID=0]="DT_INVALID",y[y.DT_FLOAT=1]="DT_FLOAT",y[y.DT_DOUBLE=2]="DT_DOUBLE",y[y.DT_INT32=3]="DT_INT32",y[y.DT_UINT8=4]="DT_UINT8",y[y.DT_INT16=5]="DT_INT16",y[y.DT_INT8=6]="DT_INT8",y[y.DT_STRING=7]="DT_STRING",y[y.DT_COMPLEX64=8]="DT_COMPLEX64",y[y.DT_INT64=9]="DT_INT64",y[y.DT_BOOL=10]="DT_BOOL",y[y.DT_QINT8=11]="DT_QINT8",y[y.DT_QUINT8=12]="DT_QUINT8",y[y.DT_QINT32=13]="DT_QINT32",y[y.DT_BFLOAT16=14]="DT_BFLOAT16",y[y.DT_QINT16=15]="DT_QINT16",y[y.DT_QUINT16=16]="DT_QUINT16",y[y.DT_UINT16=17]="DT_UINT16",y[y.DT_COMPLEX128=18]="DT_COMPLEX128",y[y.DT_HALF=19]="DT_HALF",y[y.DT_RESOURCE=20]="DT_RESOURCE",y[y.DT_VARIANT=21]="DT_VARIANT",y[y.DT_UINT32=22]="DT_UINT32",y[y.DT_UINT64=23]="DT_UINT64",y[y.DT_FLOAT_REF=101]="DT_FLOAT_REF",y[y.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",y[y.DT_INT32_REF=103]="DT_INT32_REF",y[y.DT_UINT8_REF=104]="DT_UINT8_REF",y[y.DT_INT16_REF=105]="DT_INT16_REF",y[y.DT_INT8_REF=106]="DT_INT8_REF",y[y.DT_STRING_REF=107]="DT_STRING_REF",y[y.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",y[y.DT_INT64_REF=109]="DT_INT64_REF",y[y.DT_BOOL_REF=110]="DT_BOOL_REF",y[y.DT_QINT8_REF=111]="DT_QINT8_REF",y[y.DT_QUINT8_REF=112]="DT_QUINT8_REF",y[y.DT_QINT32_REF=113]="DT_QINT32_REF",y[y.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",y[y.DT_QINT16_REF=115]="DT_QINT16_REF",y[y.DT_QUINT16_REF=116]="DT_QUINT16_REF",y[y.DT_UINT16_REF=117]="DT_UINT16_REF",y[y.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",y[y.DT_HALF_REF=119]="DT_HALF_REF",y[y.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",y[y.DT_VARIANT_REF=121]="DT_VARIANT_REF",y[y.DT_UINT32_REF=122]="DT_UINT32_REF",y[y.DT_UINT64_REF=123]="DT_UINT64_REF",(b=(x=D||(D={})).CheckpointFormatVersion||(x.CheckpointFormatVersion={}))[b.LEGACY=0]="LEGACY",b[b.V1=1]="V1",b[b.V2=2]="V2";var ha=ha;e.s(["json",0,[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]],12867),e.i(12867),e.s(["json",0,[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]],26221),e.i(26221),e.s(["json",0,[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}]],84455),e.i(84455),e.s(["json",0,[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}]],32915),e.i(32915),e.s(["json",0,[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}]],97280),e.i(97280),e.s(["json",0,[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]],87969),e.i(87969),e.s(["json",0,[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}]],10538),e.i(10538),e.s(["json",0,[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}]],96929),e.i(96929),e.s(["json",0,[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}]],45246),e.i(45246),e.s(["json",0,[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}]],7451),e.i(7451),e.s(["json",0,[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}]],841),e.i(841),e.s(["json",0,[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}]],89764),e.i(89764),e.s(["json",0,[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}]],73280),e.i(73280),e.s(["json",0,[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}]],56002),e.i(56002),e.s(["json",0,[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}]],59423),e.i(59423),e.s(["json",0,[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}]],16150),e.i(16150),e.s(["json",0,[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}]],66656),e.i(66656),e.s(["json",0,[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}]],49369),e.i(49369),e.s(["json",0,[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}]],22926),e.i(22926);var ha=ha,ha=ha;e.s([],47047),e.i(47047),e.i(27575);let xd=a4({addN_:function(e){te(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),te(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);let t=e.map((e,t)=>a1(e,`tensors${t}`,"addN")),n=t[0];return t.forEach(e=>{if(e.dtype!==n.dtype)throw Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(e=>{if(!ti(e.shape,n.shape))throw Error("All tensors passed to tf.addN() must have the same shape")}),aH.runKernel(tq,t)}}),xc=a4({basicLSTMCell_:function(e,t,n,r,a,s){let i=a1(e,"forgetBias","basicLSTMCell"),o=a1(t,"lstmKernel","basicLSTMCell"),l=a1(n,"lstmBias","basicLSTMCell"),u=a1(r,"data","basicLSTMCell"),h=a1(a,"c","basicLSTMCell"),p=sG(iM(lq([u,a1(s,"h","basicLSTMCell")],1),o),l),d=p.shape[0],c=p.shape[1]/4,f=[d,c],m=ob(p,[0,0],f),g=ob(p,[0,c],f),y=ob(p,[0,2*c],f),x=ob(p,[0,3*c],f),b=sG(sK(o2(m),uJ(g)),sK(h,o2(sG(i,y)))),w=sK(uJ(b),o2(x));return[b,w]}}),xf=a4({bitwiseAnd_:function(e,t){let n=a1(e,"x","bitwiseAnd"),r=a1(t,"y","bitwiseAnd");if(!ti(n.shape,r.shape))throw Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if("int32"!==n.dtype||"int32"!==r.dtype)throw Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);return aH.runKernel(t7,{a:n,b:r})}}),xm=a4({broadcastArgs_:function(e,t){let n=a1(e,"s0","broadcastArgs","int32"),r=a1(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==r.rank)throw Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);return aH.runKernel(t9,{s0:n,s1:r})}}),xg=a4({diag_:function(e){let t=a1(e,"x","diag");return aH.runKernel(nv,{x:t})}}),xy=a4({ensureShape_:function(e,t){let n=a1(e,"x","ensureShape","string_or_numeric");if(!ts(n.shape,t))throw Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}});function xx(e,t,n){if(n<=0)throw Error("The number of values should be positive.");return aH.runKernel(nY,{},{start:e,stop:t,num:n})}let xb=a4({searchSorted_:function(e,t,n="left"){let r=a1(e,"sortedSequence","searchSorted"),a=a1(t,"values","searchSorted"),s=r.shape[r.shape.length-1],i=a.shape[a.shape.length-1],o=iy(r,[-1,s]),l=iy(a,[-1,i]);if(o.rank<2)throw Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(tr(l.shape)>=0x80000000)throw Error("values tensor size must less than 2147483648");if(o.shape[1]>=0x80000000)throw Error(`trailing dim_size must less than 2147483648 for int32 output type, was ${o.shape[1]}`);return aH.runKernel(rR,{sortedSequence:o,values:l},{side:n})}});function xw(e,t){return xb(e,t,"left")}e.s(["searchSorted",0,xb],44372);let xv=a4({maxPoolWithArgmax_:function(e,t,n,r,a=!1){let s=a1(e,"x","maxPoolWithArgmax"),i=aH.runKernel(n8,{x:s},{filterSize:t,strides:n,pad:r,includeBatchInIndex:a});return{result:i[0],indexes:i[1]}}});function xk(e,t,{indexing:n="xy"}={}){if("xy"!==n&&"ij"!==n)throw TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===e)return[];let r=a1(e,"x","meshgrid",e instanceof aA?e.dtype:"float32");if(void 0===t)return[r];let a=a1(t,"y","meshgrid",t instanceof aA?t.dtype:"float32"),s=tr(r.shape),i=tr(a.shape);return"xy"===n?(r=iy(r,[1,-1]),a=iy(a,[-1,1]),[iM(ox([i,1],r.dtype),r),iM(a,ox([1,s],a.dtype))]):(r=iy(r,[-1,1]),a=iy(a,[1,-1]),[iM(r,ox([1,i],r.dtype)),iM(ox([s,1],a.dtype),a)])}let xN=a4({multiRNNCell_:function(e,t,n,r){let a=a1(t,"data","multiRNNCell"),s=a2(n,"c","multiRNNCell"),i=a2(r,"h","multiRNNCell"),o=a,l=[];for(let t=0;t<e.length;t++){let n=e[t](o,s[t],i[t]);l.push(n[0]),l.push(n[1]),o=n[1]}let u=[],h=[];for(let e=0;e<l.length;e+=2)u.push(l[e]),h.push(l[e+1]);return[u,h]}}),xI=a4({multinomial_:function(e,t,n,r=!1){let a=a1(e,"logits","multinomial"),s=a.size,i=a.rank;if(s<2)throw Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();let o=1===i?iy(a,[1,-1]):a,l={numSamples:t,seed:n,normalized:r},u=aH.runKernel(rt,{logits:o},l);return 1===i?iy(u,[u.size]):u}}),xS=a4({outerProduct_:function(e,t){let n=a1(e,"v1","outerProduct"),r=a1(t,"v2","outerProduct");return te(1===n.rank&&1===r.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`),iM(iy(n,[-1,1]),iy(r,[1,-1]))}}),xC=a4({pad1d_:function(e,t,n=0){return te(2===t.length,()=>"Invalid number of paddings. Must be length of 2."),lV(e,[t],n)}}),xT=a4({pad2d_:function(e,t,n=0){return te(2===t.length&&2===t[0].length&&2===t[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),lV(e,t,n)}}),x$=a4({pad3d_:function(e,t,n=0){return te(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),lV(e,t,n)}}),xE=a4({pad4d_:function(e,t,n=0){return te(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),lV(e,t,n)}}),xA=a4({raggedGather_:function(e,t,n,r){let a=e.map((e,t)=>a1(e,`tensors${t}`,"raggedGather","int32")),s=a1(t,"paramsDenseValues","raggedGather"),i=a1(n,"indices","raggedGather","int32"),o=aH.runKernel(rc,{paramsNestedSplits:a,paramsDenseValues:s,indices:i},{outputRaggedRank:r});return{outputNestedSplits:o.slice(0,o.length-1),outputDenseValues:o[o.length-1]}}}),xR=a4({raggedRange_:function(e,t,n){let r=a1(e,"starts","raggedRange"),a=a1(t,"limits","raggedRange",r.dtype),s=a1(n,"deltas","raggedRange",r.dtype),i=aH.runKernel(rf,{starts:r,limits:a,deltas:s});return{rtNestedSplits:i[0],rtDenseValues:i[1]}}}),xF=a4({raggedTensorToTensor_:function(e,t,n,r,a){let s=a1(e,"shape","raggedTensorToTensor","int32"),i=a1(t,"values","raggedTensorToTensor"),o=a1(n,"defaultValue","raggedTensorToTensor",i.dtype),l=r.map((e,t)=>a1(e,`tensors${t}`,"raggedTensorToTensor","int32"));return aH.runKernel(rm,{shape:s,values:i,defaultValue:o,rowPartitionTensors:l},{rowPartitionTypes:a})}}),x_=a4({rand_:function(e,t,n){tO(e);let r=tr(e),a=null;if(null==n||"float32"===n)a=new Float32Array(r);else if("int32"===n)a=new Int32Array(r);else if("bool"===n)a=new Uint8Array(r);else throw Error(`Unknown data type ${n}`);for(let e=0;e<r;e++)a[e]=t();return aH.makeTensor(a,e,n)}}),xD=a4({randomGamma_:function(e,t,n=1,r="float32",a){if(tO(e),null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw Error(`Unsupported data type ${r}`);let s=new pK(t,n,r,a),i=sW(e,r);for(let e=0;e<i.values.length;e++)i.values[e]=s.nextValue();return i.toTensor()}}),xO=a4({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw Error(`Unsupported data type ${t}`);return p6(e,0,1,t,n)}}),xM=a4({randomUniformInt_:function(e,t,n,r){return pY(e,t,n,"int32",r)}}),xL=a4({reverse1d_:function(e){let t=a1(e,"x","reverse");return te(1===t.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),lB(t,0)}}),xz=a4({reverse2d_:function(e,t){let n=a1(e,"x","reverse");return te(2===n.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),lB(n,t)}}),xP=a4({reverse3d_:function(e,t){let n=a1(e,"x","reverse");return te(3===n.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),lB(n,t)}}),xB=a4({reverse4d_:function(e,t){let n=a1(e,"x","reverse");return te(4===n.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),lB(n,t)}});async function xW(e,t){let n=a1(e,"x","setdiff1d"),r=a1(t,"y","setdiff1d");te(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),te(1===n.rank,()=>`x should be 1D tensor, but got x (${n.shape}).`),te(1===r.rank,()=>`y should be 1D tensor, but got y (${r.shape}).`);let a=await n.data(),s=new Set(await r.data()),i=0;for(let e=0;e<a.length;e++)!s.has(a[e])&&i++;let o=new aT([i],n.dtype),l=new aT([i],"int32");for(let e=0,t=0;e<a.length;e++)!s.has(a[e])&&(o.values[t]=a[e],l.values[t]=e,t++);return[o.toTensor(),l.toTensor()]}function xU(e,t,n){if(tn(e),null!=t&&3!==t.length)throw Error("tensor3d() requires shape to have three numbers");let r=aQ(e,n);if(3!==r.length&&1!==r.length)throw Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw Error("tensor3d() requires shape to be provided when `values` are a flat array");return a6(e,t,r,n)}function xj(e,t,n){if(tn(e),null!=t&&4!==t.length)throw Error("tensor4d() requires shape to have four numbers");let r=aQ(e,n);if(4!==r.length&&1!==r.length)throw Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw Error("tensor4d() requires shape to be provided when `values` are a flat array");return a6(e,t,r,n)}function xV(e,t,n){if(tn(e),null!=t&&5!==t.length)throw Error("tensor5d() requires shape to have five numbers");let r=aQ(e,n);if(5!==r.length&&1!==r.length)throw Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw Error("tensor5d() requires shape to be provided when `values` are a flat array");return a6(e,t,r,n)}function xG(e,t,n){if(tn(e),null!=t&&6!==t.length)throw Error("tensor6d() requires shape to have six numbers");let r=aQ(e,n);if(6!==r.length&&1!==r.length)throw Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw Error("tensor6d() requires shape to be provided when `values` are a flat array");return a6(e,t=t||r,r,n)}let xH=a4({tensorScatterUpdate_:function(e,t,n){let r=a1(e,"tensor","tensorScatterupdate"),a=a1(t,"indices","tensorScatterupdate","int32"),s=a1(n,"updates","tensorScatterupdate");if(lu(s,a,r.shape),r.dtype!==s.dtype)throw Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${s.dtype}.`);return aH.runKernel(rA,{tensor:r,indices:a,updates:s},{})}});function xq(e,t){return xb(e,t,"right")}function xK(e,t){let n=[];for(let e=0;e<t.length;e++)t[e]&&n.push(e);let r=sW(e,"int32"),a=sW([n.length,e.length],"int32");for(let t=0;t<n.length;t++){let s=r.indexToLoc(n[t]),i=t*e.length;a.values.set(s,i)}return a.toTensor()}async function xX(e){let t=a1(e,"condition","whereAsync","bool"),n=await t.data(),r=xK(t.shape,n);return e!==t&&t.dispose(),r}async function xY(e,t,n){let r=a1(e,"tensor","boolMask"),a=a1(t,"mask","boolMask","bool"),s=null==n?0:n,i=a.rank,o=r.shape;te(i>0,()=>"mask cannot be scalar"),tt(o.slice(s,s+i),a.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let e=s;e<s+i;e++)l*=o[e];let u=iy(r,o.slice(0,s).concat([l],o.slice(s+i))),h=iy(a,[-1]),p=await xX(h),d=uX(p,[1]),c=lY(u,d,s);return e!==r&&r.dispose(),t!==a&&a.dispose(),d.dispose(),u.dispose(),h.dispose(),p.dispose(),c}e.s(["booleanMaskAsync",0,xY],85539),e.i(85539),e.i(33212),e.i(97791);let xZ=a4({movingAverage_:function(e,t,n,r,a=!0){let s=a1(e,"v","movingAverage"),i=a1(t,"x","movingAverage"),o=a1(n,"decay","movingAverage");aP(s,i),te(ti(s.shape,i.shape),()=>"Shape mismatch in v and x");let l=sQ(1),u=it(l,o),h=sK(it(i,s),u);return a&&(te(null!=r,()=>"When using zeroDebias: true, step is required."),h=sq(h,it(l,ie(o,a1(r,"step","movingAverage"))))),sG(s,h)}});e.s(["movingAverage",0,xZ],3003),e.i(3003);let xJ=a4({scatterND_:function(e,t,n){tO(n);let r=a1(e,"indices","scatterND","int32"),a=a1(t,"updates","scatterND");return lu(a,r,n),aH.runKernel(rE,{indices:r,updates:a},{shape:n})}});e.s(["scatterND",0,xJ],8380),e.i(8380),e.i(44372);let xQ=a4({sparseToDense_:function(e,t,n,r=0){tO(n);let a=a1(e,"sparseIndices","sparseToDense","int32"),s=a1(t,"sparseValues","sparseToDense","string_or_numeric"),i=a1(r,"defaultValue","sparseToDense",s.dtype);if("int32"!==a.dtype)throw Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${a.dtype}.`);if(a.rank>2)throw Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${a.shape}.`);let o=a.rank>0?a.shape[0]:1,l=a.rank>1?a.shape[1]:1;if(n.length!==l)throw Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${l}.`);let u=s.size;if(0!==s.rank&&(1!==s.rank||u!==o))throw Error(`sparseValues has incorrect shape ${s.shape}, should be [] or [${o}]`);if(s.dtype!==i.dtype)throw Error("sparseValues.dtype must match defaultValues.dtype");return aH.runKernel(rq,{sparseIndices:a,sparseValues:s,defaultValue:i},{outputShape:n})}});e.s(["sparseToDense",0,xQ],99128),e.i(99128);let x0=a4({gatherND_:function(e,t){let n=a1(t,"indices","gatherND","int32"),r=a1(e,"x","gatherND","string_or_numeric");return aH.runKernel(nz,{params:r,indices:n})}});async function x1(e,t,n=1){let r=a1(e,"predictions","inTopK"),a=a1(t,"targets","inTopK");te(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),te(r.rank-1===a.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${a.rank}`),tt(r.shape.slice(0,r.shape.length-1),a.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=r.shape[r.shape.length-1];te(n>0&&n<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`);let i=await r.data(),o=await a.data(),[l,u]=[i.length/s,s],h=ty("bool",l);for(let e=0;e<l;e++){let t=e*u,r=i.subarray(t,t+u),a=[];for(let e=0;e<r.length;e++)a.push({value:r[e],index:e});a.sort((e,t)=>t.value-e.value),h[e]=0;for(let t=0;t<n;t++)if(a[t].index===o[e]){h[e]=1;break}}return e!==r&&r.dispose(),t!==a&&a.dispose(),a8(h,a.shape,"bool")}e.s(["gatherND",0,x0],74938),e.i(74938),e.i(59371),e.i(52616),e.s(["inTopKAsync",0,x1],52664),e.i(52664),e.s(["OP_SCOPE_SUFFIX",0,a3,"abs",0,ia,"acos",0,lZ,"acosh",0,lJ,"add",0,sG,"addN",0,xd,"all",0,lQ,"any",0,l0,"argMax",0,l1,"argMin",0,l2,"asin",0,l3,"asinh",0,l4,"atan",0,l5,"atan2",0,l6,"atanh",0,l8,"avgPool",0,l7,"avgPool3d",0,gf,"basicLSTMCell",0,xc,"batchNorm",0,l9,"batchNorm2d",0,gl,"batchNorm3d",0,go,"batchNorm4d",0,gi,"batchToSpaceND",0,lG,"bincount",0,pf,"bitwiseAnd",0,xf,"booleanMaskAsync",0,xY,"broadcastArgs",0,xm,"broadcastTo",0,iW,"buffer",()=>sW,"cast",0,sU,"ceil",0,ue,"clipByValue",0,ut,"clone",0,sj,"complex",0,a5,"concat",0,lq,"concat1d",0,p2,"concat2d",0,p3,"concat3d",0,p4,"concat4d",0,p5,"conv1d",0,un,"conv2d",0,iq,"conv2dTranspose",0,ur,"conv3d",0,mc,"conv3dTranspose",0,md,"cos",0,lU,"cosh",0,lj,"cosineWindow",()=>hQ,"cumprod",0,lP,"cumsum",0,i6,"denseBincount",0,gB,"depthToSpace",0,ua,"depthwiseConv2d",0,us,"diag",0,xg,"dilation2d",0,ui,"div",0,sq,"divNoNan",0,uo,"dot",0,ul,"dropout",0,p7,"einsum",0,h7,"elu",0,oZ,"enclosingPowerOfTwo",()=>hJ,"ensureShape",0,xy,"equal",0,op,"erf",0,uu,"euclideanNorm",0,uc,"exp",0,on,"expandDims",0,lX,"expm1",0,uf,"eye",0,hH,"fft",0,um,"fill",()=>s7,"floor",0,ow,"floorDiv",0,sH,"fused",0,hY,"gather",0,lY,"gatherND",0,x0,"greater",0,ou,"greaterEqual",0,iz,"ifft",0,ug,"imag",0,i8,"image",()=>pW,"inTopKAsync",0,x1,"irfft",0,uy,"isFinite",0,ux,"isInf",0,ub,"isNaN",0,uw,"leakyRelu",0,oJ,"less",0,of,"lessEqual",0,iP,"linalg",()=>pU,"linspace",()=>xx,"localResponseNormalization",0,uv,"log",0,oN,"log1p",0,uC,"logSigmoid",0,uN,"logSoftmax",0,uI,"logSumExp",0,uS,"logicalAnd",0,iB,"logicalNot",0,lW,"logicalOr",0,uT,"logicalXor",0,u$,"losses",()=>pj,"lowerBound",()=>xw,"matMul",0,iM,"max",0,uh,"maxPool",0,uE,"maxPool3d",0,gm,"maxPoolWithArgmax",0,xv,"maximum",0,il,"mean",0,uA,"meshgrid",()=>xk,"min",0,up,"minimum",0,uR,"mirrorPad",0,uF,"mod",0,u_,"moments",0,gu,"movingAverage",0,xZ,"mul",0,sK,"multiRNNCell",0,xN,"multinomial",0,xI,"neg",0,ig,"norm",0,ud,"notEqual",0,uD,"oneHot",0,uO,"ones",()=>ox,"onesLike",0,uM,"op",()=>a4,"outerProduct",0,xS,"pad",0,lV,"pad1d",0,xC,"pad2d",0,xT,"pad3d",0,x$,"pad4d",0,xE,"pool",0,uL,"pow",0,ie,"prelu",0,oQ,"print",()=>sV,"prod",0,uz,"raggedGather",0,xA,"raggedRange",0,xR,"raggedTensorToTensor",0,xF,"rand",0,x_,"randomGamma",0,xD,"randomNormal",0,p6,"randomStandardNormal",0,xO,"randomUniform",0,pY,"randomUniformInt",0,xM,"range",()=>pm,"real",0,i7,"reciprocal",0,uP,"relu",0,o0,"relu6",0,o1,"reshape",0,iy,"reverse",0,lB,"reverse1d",0,xL,"reverse2d",0,xz,"reverse3d",0,xP,"reverse4d",0,xB,"rfft",0,uU,"round",0,uj,"rsqrt",0,or,"scalar",()=>sQ,"scatterND",0,xJ,"searchSorted",0,xb,"selu",0,uV,"separableConv2d",0,uG,"setdiff1dAsync",0,xW,"sigmoid",0,o2,"sign",0,uH,"signal",()=>pB,"sin",0,iY,"sinh",0,iZ,"slice",0,ob,"slice1d",0,pJ,"slice2d",0,pQ,"slice3d",0,p0,"slice4d",0,p1,"softmax",0,uq,"softplus",0,uk,"spaceToBatchND",0,iL,"sparse",()=>pV,"sparseToDense",0,xQ,"spectral",()=>pP,"split",0,iV,"sqrt",0,sX,"square",0,sY,"squaredDifference",0,uK,"squeeze",0,uX,"stack",0,os,"step",0,ic,"stridedSlice",0,uY,"string",()=>pG,"sub",0,it,"sum",0,ix,"tan",0,uZ,"tanh",0,uJ,"tensor",()=>a8,"tensor1d",()=>hZ,"tensor2d",()=>h2,"tensor3d",()=>xU,"tensor4d",()=>xj,"tensor5d",()=>xV,"tensor6d",()=>xG,"tensorScatterUpdate",0,xH,"tile",0,oa,"topk",0,uQ,"transpose",0,i9,"truncatedNormal",0,pZ,"unique",0,u0,"unsortedSegmentSum",0,oi,"unstack",0,ov,"upperBound",()=>xq,"variable",()=>dG,"where",0,iU,"whereAsync",0,xX,"zeros",()=>oy,"zerosLike",0,sZ],24047),e.i(24047),e.s(["OP_SCOPE_SUFFIX",0,a3,"abs",0,ia,"acos",0,lZ,"acosh",0,lJ,"add",0,sG,"addN",0,xd,"all",0,lQ,"any",0,l0,"argMax",0,l1,"argMin",0,l2,"asin",0,l3,"asinh",0,l4,"atan",0,l5,"atan2",0,l6,"atanh",0,l8,"avgPool",0,l7,"avgPool3d",0,gf,"basicLSTMCell",0,xc,"batchNorm",0,l9,"batchNorm2d",0,gl,"batchNorm3d",0,go,"batchNorm4d",0,gi,"batchToSpaceND",0,lG,"bincount",0,pf,"bitwiseAnd",0,xf,"booleanMaskAsync",0,xY,"broadcastArgs",0,xm,"broadcastTo",0,iW,"buffer",()=>sW,"cast",0,sU,"ceil",0,ue,"clipByValue",0,ut,"clone",0,sj,"complex",0,a5,"concat",0,lq,"concat1d",0,p2,"concat2d",0,p3,"concat3d",0,p4,"concat4d",0,p5,"conv1d",0,un,"conv2d",0,iq,"conv2dTranspose",0,ur,"conv3d",0,mc,"conv3dTranspose",0,md,"cos",0,lU,"cosh",0,lj,"cosineWindow",()=>hQ,"cumprod",0,lP,"cumsum",0,i6,"denseBincount",0,gB,"depthToSpace",0,ua,"depthwiseConv2d",0,us,"diag",0,xg,"dilation2d",0,ui,"div",0,sq,"divNoNan",0,uo,"dot",0,ul,"dropout",0,p7,"einsum",0,h7,"elu",0,oZ,"enclosingPowerOfTwo",()=>hJ,"ensureShape",0,xy,"equal",0,op,"erf",0,uu,"euclideanNorm",0,uc,"exp",0,on,"expandDims",0,lX,"expm1",0,uf,"eye",0,hH,"fft",0,um,"fill",()=>s7,"floor",0,ow,"floorDiv",0,sH,"fused",()=>hY,"gather",0,lY,"gatherND",0,x0,"greater",0,ou,"greaterEqual",0,iz,"ifft",0,ug,"imag",0,i8,"image",()=>pW,"inTopKAsync",0,x1,"irfft",0,uy,"isFinite",0,ux,"isInf",0,ub,"isNaN",0,uw,"leakyRelu",0,oJ,"less",0,of,"lessEqual",0,iP,"linalg",()=>pU,"linspace",()=>xx,"localResponseNormalization",0,uv,"log",0,oN,"log1p",0,uC,"logSigmoid",0,uN,"logSoftmax",0,uI,"logSumExp",0,uS,"logicalAnd",0,iB,"logicalNot",0,lW,"logicalOr",0,uT,"logicalXor",0,u$,"losses",()=>pj,"lowerBound",()=>xw,"matMul",0,iM,"max",0,uh,"maxPool",0,uE,"maxPool3d",0,gm,"maxPoolWithArgmax",0,xv,"maximum",0,il,"mean",0,uA,"meshgrid",()=>xk,"min",0,up,"minimum",0,uR,"mirrorPad",0,uF,"mod",0,u_,"moments",0,gu,"movingAverage",0,xZ,"mul",0,sK,"multiRNNCell",0,xN,"multinomial",0,xI,"neg",0,ig,"norm",0,ud,"notEqual",0,uD,"oneHot",0,uO,"ones",()=>ox,"onesLike",0,uM,"op",()=>a4,"outerProduct",0,xS,"pad",0,lV,"pad1d",0,xC,"pad2d",0,xT,"pad3d",0,x$,"pad4d",0,xE,"pool",0,uL,"pow",0,ie,"prelu",0,oQ,"print",()=>sV,"prod",0,uz,"raggedGather",0,xA,"raggedRange",0,xR,"raggedTensorToTensor",0,xF,"rand",0,x_,"randomGamma",0,xD,"randomNormal",0,p6,"randomStandardNormal",0,xO,"randomUniform",0,pY,"randomUniformInt",0,xM,"range",()=>pm,"real",0,i7,"reciprocal",0,uP,"relu",0,o0,"relu6",0,o1,"reshape",0,iy,"reverse",0,lB,"reverse1d",0,xL,"reverse2d",0,xz,"reverse3d",0,xP,"reverse4d",0,xB,"rfft",0,uU,"round",0,uj,"rsqrt",0,or,"scalar",()=>sQ,"scatterND",0,xJ,"searchSorted",0,xb,"selu",0,uV,"separableConv2d",0,uG,"setdiff1dAsync",0,xW,"sigmoid",0,o2,"sign",0,uH,"signal",()=>pB,"sin",0,iY,"sinh",0,iZ,"slice",0,ob,"slice1d",0,pJ,"slice2d",0,pQ,"slice3d",0,p0,"slice4d",0,p1,"softmax",0,uq,"softplus",0,uk,"spaceToBatchND",0,iL,"sparse",()=>pV,"sparseToDense",0,xQ,"spectral",()=>pP,"split",0,iV,"sqrt",0,sX,"square",0,sY,"squaredDifference",0,uK,"squeeze",0,uX,"stack",0,os,"step",0,ic,"stridedSlice",0,uY,"string",()=>pG,"sub",0,it,"sum",0,ix,"tan",0,uZ,"tanh",0,uJ,"tensor",()=>a8,"tensor1d",()=>hZ,"tensor2d",()=>h2,"tensor3d",()=>xU,"tensor4d",()=>xj,"tensor5d",()=>xV,"tensor6d",()=>xG,"tensorScatterUpdate",0,xH,"tile",0,oa,"topk",0,uQ,"transpose",0,i9,"truncatedNormal",0,pZ,"unique",0,u0,"unsortedSegmentSum",0,oi,"unstack",0,ov,"upperBound",()=>xq,"variable",()=>dG,"where",0,iU,"whereAsync",0,xX,"zeros",()=>oy,"zerosLike",0,sZ],57021),e.i(57021);var ha=ha,ha=ha,ha=ha,ha=ha,x2=e.i(9e4),x2=x2,ha=ha,ha=ha;function x3(e,t,n=new Map,r=new Set){if(null==e)return null;if("function"==typeof Blob&&e instanceof Blob)return e.slice();if(r.has(e))throw Error("Circular references are not supported.");if(n.has(e))return n.get(e);let a=t(e);if(a.recurse&&null!==a.value)throw Error("A deep map function may not return both a value and recurse=true.");if(!a.recurse)return n.set(e,a.value),a.value;if(x6(e)){let a=Array.isArray(e)?[]:{};for(let s in r.add(e),e){let i=x3(e[s],t,n,r);a[s]=i}return r.delete(e),e.__proto__&&(a.__proto__=e.__proto__),a}throw Error(`Can't recurse into non-iterable type: ${e}`)}function x4(e){return null===e?null:x6(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function x5(e,t){let n=new Map;for(let r of(x3(e,t,n),Array.from(n.keys()))){let e=n.get(r);if(ha.isPromise(e)){let t=await e;n.set(r,t)}}return x3(e,t,n)}function x6(e){let t=!1;if(tU.get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:n}={};t=e instanceof n}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"==typeof e&&!(e instanceof aA)&&!(e instanceof Promise)&&!t)}function x8(e){return e instanceof aA?{value:e.clone(),recurse:!1}:x6(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}class x7{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw RangeError("Can't create ring buffer of capacity < 1.");this.data=Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}class x9 extends x7{constructor(){super(x9.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){let e=2*this.capacity,t=Array(e),n=this.length();for(let e=0;e<n;e++)t[e]=this.get(this.wrap(this.begin+e));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}x9.INITIAL_CAPACITY=32;class be{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)n=e((t=await this.next()).value)}handleErrors(e){return new bu(this,e)}filter(e){return new bo(this,e)}map(e){return new bl(this,e)}mapAsync(e){return new bh(this,e)}serialMapAsync(e){return new bh(this,e).serial()}flatmap(e){return new bd(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(e=>!0===e)}rowMajorBatch(e,t=!0){return new bi(this,e,t)}columnMajorBatch(e,t=!0,n=x4){return this.rowMajorBatch(e,t).map(e=>(function(e,t=x4){return function e(t,n,r=new Set){let a=t[0];if(r.has(a))throw Error("Circular references are not supported.");let s=n(t);if(s.recurse&&null!==s.value)throw Error("A deep zip function may not return both a value and recurse=true.");if(!s.recurse)return s.value;if(x6(a)){let s=Array.isArray(a)?[]:{};for(let i in r.add(a),a){let a=e(t.map(e=>e[i]),n,r);s[i]=a}return r.delete(a),s}throw Error(`Can't recurse into non-iterable type: ${a}`)}(e,t)})(e,n))}concatenate(e,t){return new bc(new bt([this,e]),t)}take(e){return e<0||null==e?this:new bs(this,e)}skip(e){return e<0||null==e?this:new ba(this,e)}prefetch(e){return new bm(this,e)}shuffle(e,t){return new bg(this,e,t)}serial(){return new br(this)}}class bt extends be{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:x3(e,x8),done:!1}}}class bn extends be{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}}class br extends be{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class ba extends be{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;sn(e.value)}return this.upstream.next()}}class bs extends be{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class bi extends be{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done){if(this.enableSmallLastBatch&&e.length>0)return{value:e,done:!1};return{value:null,done:!0}}e.push(t.value)}return{value:e,done:!1}}}class bo extends be{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;sn(e.value)}}}class bl extends be{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=x2.getTensorsInContainer(e.value),n=this.transform(e.value),r=x2.getTensorsInContainer(n);for(let e of t)x2.isTensorInList(e,r)||e.dispose();return{value:n,done:!1}}}class bu extends be{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class bh extends be{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=x2.getTensorsInContainer(e.value),n=await this.transform(e.value),r=x2.getTensorsInContainer(n);for(let e of t)x2.isTensorInList(e,r)||e.dispose();return{value:n,done:!1}}}class bp extends be{constructor(){super(),this.outputQueue=new x9,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class bd extends bp{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=x2.getTensorsInContainer(e.value),n=this.transform(e.value),r=x2.getTensorsInContainer(n);for(let e of(this.outputQueue.pushAll(n),t))x2.isTensorInList(e,r)||e.dispose();return!0}}class bc extends be{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){let e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}(w=O||(O={}))[w.FAIL=0]="FAIL",w[w.SHORTEST=1]="SHORTEST",w[w.LONGEST=2]="LONGEST";class bf extends be{constructor(e,t=O.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0,r=await x5(this.iterators,function(e){return e instanceof be?{value:e.next().then(e=>(t++,e.done&&n++,e.value)),recurse:!1}:{value:null,recurse:!0}});if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case O.FAIL:throw Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case O.SHORTEST:return{value:null,done:!0};case O.LONGEST:}return this.count++,{value:r,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class bm extends be{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new x7(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class bg extends bm{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=pH.alea(n||ha.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}}class by{constructor(){this.size=null}batch(e,t=!0){let n=this;return ha.assert(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`),bx(async()=>(await n.iterator()).columnMajorBatch(e,t,bv),this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e))}concatenate(e){let t=this;return bx(async()=>(await t.iterator()).concatenate(await e.iterator()),this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null)}filter(e){let t=this;return bx(async()=>(await t.iterator()).filter(t=>st(()=>e(t))),this.size===1/0?1/0:null)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return bx(async()=>(await t.iterator()).map(t=>st(()=>e(t))),this.size)}mapAsync(e){let t=this;return bx(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(null==e)throw RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return bx(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){let t=this;return bx(async()=>new bc(new bn(async()=>({value:await t.iterator(),done:!1})).take(e),void 0),null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null)}skip(e){let t=this;return bx(async()=>(await t.iterator()).skip(e),null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null)}shuffle(e,t,n=!0){if(null==e||e<0)if(null==this.size)throw RangeError("`Dataset.shuffle()` requires bufferSize to be specified.");else throw RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let r=this,a=pH.alea(t||ha.now().toString());return bx(async()=>{let t=a.int32();return n&&(t+=a.int32()),(await r.iterator()).shuffle(e,t.toString())},this.size)}take(e){let t=this;return bx(async()=>(await t.iterator()).take(e),null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null)}async toArray(){if(this.size===1/0)throw Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function bx(e,t=null){return new class extends by{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function bb(e){return bx(async()=>new bt(e),e.length)}function bw(e){let t;if(!x6(e))throw Error("The argument to zip() must be an object or array.");if(Array.isArray(e))for(let n=0;n<e.length;n++)t=null==t?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=null==t?e[n].size:Math.min(t,e[n].size);return bx(async()=>(function(e,t=O.FAIL){return new bf(e,t)})(await x5(e,e=>{if(e instanceof by)return{value:e.iterator(),recurse:!1};if(x6(e))return{value:null,recurse:!0};throw Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")}),O.SHORTEST),t)}function bv(e){var t,n;if(null===e)return null;return null==(t=e[0])||null===(n=t)||"object"!=typeof n&&"function"!=typeof n||Array.isArray(t)||"object"==typeof t&&t instanceof aA||ha.isTypedArray(t)?{value:function(e){if(0===e.length)throw Error("Can't make a batch of zero elements.");return e[0]instanceof aA?os(e):a8(e)}(e),recurse:!1}:{value:null,recurse:!0}}by.MAX_BUFFER_SIZE=1e4;var ha=ha;class bk extends by{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split("\n").map(e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e))}}let bN=Symbol("out"),bI=Symbol("field"),bS=Symbol("quote"),bC=Symbol("quoteafterquote"),bT=Symbol("quoteinquote");class b$ extends by{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(this.fullColumnNames||e)this.fullColumnNames&&e&&ha.assert(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+").");else throw Error("Column names must be provided if there is no header line.");this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce((e,t)=>(e[t]=e[t]+1||1,e),{}),n=Object.keys(t).filter(e=>t[e]>1);if(ha.assert(0===n.length,()=>"Duplicate column names found: "+n.toString()),this.columnConfigs){for(let e of Object.keys(this.columnConfigs))if(-1===this.fullColumnNames.indexOf(e))throw Error('The key "'+e+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(!this.hasHeader)return null;{let e=await this.base.iterator(),t=await e.next();if(t.done)throw Error("No data was found for CSV parsing.");let n=t.value;return this.parseRow(n,!1)}}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new bk(e),t||(t={}),this.hasHeader=!1!==t.hasHeader,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(ha.assert(null==t.delimiter,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(e=>this.makeDataElement(e))}makeDataElement(e){let t=this.parseRow(e),n={},r={};for(let a=0;a<this.fullColumnNames.length;a++){let s=this.fullColumnNames[a],i=this.columnConfigs?this.columnConfigs[s]:null;if(!this.configuredColumnsOnly||i){let o=t[a],l=null;if(""===o)if(i&&void 0!==i.default)l=i.default;else if(i&&(i.required||i.isLabel))throw Error(`Required column ${s} is empty in this line: ${e}`);else l=void 0;else{let e=Number(o);if(isNaN(e))l=i&&"bool"===i.dtype?this.getBoolean(o):o;else if(i&&i.dtype)switch(i.dtype){case"float32":default:l=e;break;case"int32":l=Math.floor(e);break;case"bool":l=this.getBoolean(o)}else l=e}i&&i.isLabel?r[s]=l:n[s]=l}}return 0===Object.keys(r).length?n:{xs:n,ys:r}}getBoolean(e){return+("1"===e||"true"===e.toLowerCase())}parseRow(e,t=!0){let n=[],r=0,a=e.length,s=bN;for(let t=0;t<a;t++)switch(s){case bN:switch(e.charAt(t)){case'"':r=t+1,s=bS;break;case this.delimiter:if(r=t+1," "===this.delimiter&&this.delimWhitespace)break;n.push(""),s=bN;break;default:s=bI,r=t}break;case bI:e.charAt(t)===this.delimiter&&(n.push(e.substring(r,t)),s=bN,r=t+1);break;case bS:'"'===e.charAt(t)&&(s=bC);break;case bC:switch(e.charAt(t)){case this.delimiter:n.push(e.substring(r,t-1)),s=bN,r=t+1;break;case'"':s=bS;break;default:s=bT}break;case bT:'"'===e.charAt(t)&&(s=bS)}if(s===bC?n.push(e.substring(r,a-1)):n.push(e.substring(r)),t&&n.length!==this.fullColumnNames.length)throw Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}}var ha=ha;class bE extends be{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;const t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=!1!==e.includeSpectrogram,this.includeWaveform=!0===e.includeWaveform,!this.includeSpectrogram&&!this.includeWaveform)throw Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(!tU.get("IS_BROWSER"))throw Error("microphone API is only supported in browser environment.");let t=new bE(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:null==this.audioTrackConstraints||this.audioTrackConstraints,video:!1})}catch(e){throw Error(`Error thrown while initializing video stream: ${e.message}`)}if(!this.stream)throw Error("Could not obtain audio from microphone.");let e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,this.sampleRateHz){if(this.audioContext.sampleRate!==this.sampleRateHz)throw Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`)}else this.sampleRateHz=this.audioContext.sampleRate;let t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){let e,t;if(this.isClosed)return{value:null,done:!0};let n=await this.getAudioData();if(this.includeSpectrogram){let t=this.flattenQueue(n.freqDataQueue);e=this.getTensorFromAudioDataArray(t,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let e=this.flattenQueue(n.timeDataQueue);t=this.getTensorFromAudioDataArray(e,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let e=[],t=[],n=0;return new Promise(r=>{let a=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(a),r({freqDataQueue:e,timeDataQueue:t}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){!this.isClosed&&(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){let t=e[0].length,n=new Float32Array(e.length*t);return e.forEach((e,r)=>n.set(e,r*t)),n}getTensorFromAudioDataArray(e,t){let n=new Float32Array(ha.sizeFromShape(t));return n.set(e,n.length-e.length),a8(n,t)}}let bA=!1;function bR(e,t=3){let n,r;if(t>4)throw Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw Error("pixels passed to tf.browser.fromPixels() can not be null");let a=!1,i=!1,o=!1,l=!1,u=!1,h=!1;if(e.data instanceof Uint8Array)a=!0;else if("undefined"!=typeof ImageData&&e instanceof ImageData)i=!0;else if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)o=!0;else if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)l=!0;else if(null!=e.getContext)u=!0;else if("undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap)h=!0;else throw Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if(null!=ah(at,aH.backendName))return aH.runKernel(at,{pixels:e},{numChannels:t});let[p,d]=o?[e.videoWidth,e.videoHeight]:[e.width,e.height];if(u)n=e.getContext("2d").getImageData(0,0,p,d).data;else if(i||a)n=e.data;else if(l||o||h){if(null==s)if("undefined"==typeof document)if("undefined"!=typeof OffscreenCanvas&&"undefined"!=typeof OffscreenCanvasRenderingContext2D)s=new OffscreenCanvas(1,1).getContext("2d");else throw Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else s=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});s.canvas.width=p,s.canvas.height=d,s.drawImage(e,0,0,p,d),n=s.getImageData(0,0,p,d).data}if(4===t)r=new Int32Array(n);else{let e=p*d;r=new Int32Array(e*t);for(let a=0;a<e;a++)for(let e=0;e<t;++e)r[a*t+e]=n[4*a+e]}return xU(r,[d,p,t],"int32")}async function bF(e,t=3){var n;let r=null;if(tU.getBool("WRAP_TO_IMAGEBITMAP")&&"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")&&!(e instanceof ImageBitmap)&&null!=(n=e)&&0!==n.width&&0!==n.height&&!(null!=e&&e.data instanceof Uint8Array)){let t;try{t=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(e){t=null}r=null!=t&&t.width===e.width&&t.height===e.height?t:e}else r=e;return bR(r,t)}function b_(e){if(2!==e.rank&&3!==e.rank)throw Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let t=2===e.rank?1:e.shape[2];if(t>4||2===t)throw Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if("float32"!==e.dtype&&"int32"!==e.dtype)throw Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}async function bD(e,t){let n=a1(e,"img","toPixels");if(!(e instanceof aA)){let e=n;n=sU(e,"int32"),e.dispose()}b_(n);let[r,a]=n.shape.slice(0,2),s=2===n.rank?1:n.shape[2],i=await n.data(),o="float32"===n.dtype?255:1,l=new Uint8ClampedArray(a*r*4);for(let e=0;e<r*a;++e){let t=[0,0,0,255];for(let r=0;r<s;r++){let a=i[e*s+r];if("float32"===n.dtype){if(a<0||a>1)throw Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${a}.`)}else if("int32"===n.dtype&&(a<0||a>255))throw Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${a}.`);1===s?(t[0]=a*o,t[1]=a*o,t[2]=a*o):t[r]=a*o}let r=4*e;l[r+0]=Math.round(t[0]),l[r+1]=Math.round(t[1]),l[r+2]=Math.round(t[2]),l[r+3]=Math.round(t[3])}if(null!=t){bA||null!=ah(nS,aH.backendName)&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),bA=!0),t.width=a,t.height=r;let e=t.getContext("2d"),n=new ImageData(l,a,r);e.putImageData(n,0,0)}return n!==e&&n.dispose(),l}function bO(e,t,n){let r=a1(e,"img","draw");if(!(e instanceof aA)){let e=r;r=sU(e,"int32"),e.dispose()}b_(r);var a=null==n?void 0:n.imageOptions;let s=(null==a?void 0:a.alpha)||1;if(s>1||s<0)throw Error(`Alpha value ${s} is suppoed to be in range [0 - 1].`);let i={image:r};aH.runKernel(nS,i,{canvas:t,options:n})}let bM=a4({fromPixels_:bR});e.s(["draw",()=>bO,"fromPixels",0,bM,"fromPixelsAsync",()=>bF,"toPixels",()=>bD],26584);var bL=e.i(26584),bL=bL,ha=ha;class bz extends be{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=hZ([0],"int32"),this.webcamConfig.centerCrop){const e=this.webcamConfig.resizeWidth/this.webcamVideoElement.width,t=this.webcamConfig.resizeHeight/this.webcamVideoElement.height,n=(1-e)/2,r=(1-t)/2;this.cropBox=h2([r,n,t+r,n+e],[1,4])}else this.cropBox=h2([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(!tU.get("IS_BROWSER"))throw Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}let n=new bz(e,t);return await n.start(),n}async start(){this.webcamConfig.facingMode&&ha.assert("user"===this.webcamConfig.facingMode||"environment"===this.webcamConfig.facingMode,()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}})}async next(){let e;if(this.isClosed)return{value:null,done:!0};try{e=bL.fromPixels(this.webcamVideoElement)}catch(e){throw Error(`Error thrown converting video to pixels: ${JSON.stringify(e)}`)}if(!this.resize)return{value:e,done:!1};try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(e){throw Error(`Error thrown cropping the video: ${e.message}`)}finally{e.dispose()}}needToResize(){return!!this.webcamConfig.resizeWidth&&!!this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight)}cropAndResizeFrame(e){return st(()=>{let t,n=lX(sU(e,"float32"),0),r=(t=pW.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear")).shape;return iy(t,r.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(e=>e.stop());try{this.webcamVideoElement.srcObject=null}catch(e){console.log(e),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw Error("Can not convert infinite video stream to array.")}}class bP{}var ha=ha,ha=ha;class bB extends be{split(e){return new bW(this,e)}}class bW extends bB{constructor(e,t){super(),this.upstream=e,this.impl=new bU(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class bU extends bp{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return""!==this.carryover&&(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);for(let e of(t[0]=this.carryover+t[0],t.slice(0,-1)))this.outputQueue.push(e);return this.carryover=t[t.length-1],!0}}class bj extends be{decodeUTF8(){return new bV(this)}}class bV extends bB{constructor(e){super(),this.upstream=e,this.impl=new bG(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class bG extends bp{constructor(e){if(super(),this.upstream=e,tU.get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:e}={};this.decoder=new e("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e,t,n=await this.upstream.next();return!n.done&&(e=n.value,t=tU.get("IS_BROWSER")?this.decoder.decode(e,{stream:!0}):this.decoder.write(aJ.Buffer.from(e.buffer)),this.outputQueue.push(t),!0)}}class bH extends bj{constructor(e,t={}){super(),this.file=e,this.options=t,ha.assert(e instanceof Uint8Array||!!tU.get("IS_BROWSER")&&(e instanceof File||e instanceof Blob),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1048576}summary(){return`FileChunks ${this.file}`}async next(){if(this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size))return{value:null,done:!0};let e=new Promise((e,t)=>{let n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{let r=new FileReader;r.onload=n=>{let a=r.result;if(a instanceof ArrayBuffer&&(a=new Uint8Array(a)),!(a instanceof Uint8Array))return t(TypeError("FileReader returned unknown type."));e(a)},r.onabort=e=>t(Error("Aborted")),r.onerror=e=>t(Error(e.type));let a=this.file.slice(this.offset,n);r.readAsArrayBuffer(a)}this.offset=n});return{value:await e,done:!1}}}async function bq(e,t={},n){let r,a;"string"==typeof e?r=e:(r=e.url,a=bK(e));let s=await (n||ha.fetch)(r,a);if(s.ok)return new bH(new Uint8Array(await s.arrayBuffer()),t);throw Error(s.statusText)}let bK=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function bX(e){return"string"==typeof e&&"file://"===e.slice(0,7)}class bY extends bP{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){return bX(this.input)&&tU.get("IS_NODE")&&(this.input=({}).readFileSync(this.input.slice(7))),new bH(this.input,this.options)}}class bZ extends bP{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return bX(this.url)?new bY(this.url,this.fileOptions).iterator():bq(this.url,this.fileOptions)}}function bJ(e,t={}){return new b$(new bZ(e),t)}function bQ(e){let t=new bn(e);return bx(async()=>t)}function b0(e){return bx(async()=>{let t=await e();return new bn(()=>t.next())})}async function b1(e,t){return bz.create(e,t)}async function b2(e){return bE.create(e)}e.s([],65809),e.i(65809),e.s(["CSVDataset",()=>b$,"Dataset",()=>by,"FileDataSource",()=>bY,"TextLineDataset",()=>bk,"URLDataSource",()=>bZ,"array",()=>bb,"csv",()=>bJ,"func",()=>bQ,"generator",()=>b0,"microphone",()=>b2,"version_data",()=>"4.22.0","webcam",()=>b1,"zip",()=>bw],32149),e.i(32149);var lz=lz;e.s([],49159),e.i(49159),e.s(["nonMaxSuppressionV3Impl",()=>pa,"nonMaxSuppressionV4Impl",()=>ps,"nonMaxSuppressionV5Impl",()=>pi,"whereImpl",()=>xK],8700);var b3=e.i(8700),b3=b3,ha=ha,ha=ha;function b4(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&ha.assert("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the CPU backend.`)})}let b5=b3.whereImpl;class b6 extends e0{nextDataId(){return b6.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new eQ(this,aH)}write(e,t,n){this.firstUse&&(this.firstUse=!1,tU.get("IS_NODE")&&lz.warn("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));let r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&ha.isString(n[0])){let a=n.map(e=>ha.encodeString(e));r=this.write(a,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){let t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){let t=this.data.get(e);t.refCount--}}move(e,t,n,r,a){this.data.set(e,{values:t,dtype:r,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){let{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){let e=this.readSync(n.real.dataId),t=this.readSync(n.imag.dataId);return lz.mergeRealAndImagArrays(e,t)}return ha.convertBackendValuesAndArrayBuffer(this.data.get(e).values,t)}bufferSync(e){let t=this.readSync(e.dataId);if("string"===e.dtype)try{let n=t.map(e=>ha.decodeString(e));return sW(e.shape,e.dtype,n)}catch(e){throw Error("Failed to decode encoded string bytes into utf-8")}return sW(e.shape,e.dtype,t)}makeOutput(e,t,n){return aH.makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;let{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){let t=ha.now();return e(),{kernelMs:ha.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){b4([e],"where");let t=this.readSync(e.dataId);return b5(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}b6.nextDataId=0,e.s([],35836),e.i(35836);var ha=ha;function b8(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}var lz=lz,ha=ha;function b7(e){return(t,n,r,a,s)=>{let i=lz.assertAndGetBroadcastShape(t,n),o=i.length,l=ha.computeStrides(i),u=ha.sizeFromShape(i),h=ha.getTypedArrayFromDType(s,u),p=t.length,d=n.length,c=ha.computeStrides(t),f=ha.computeStrides(n),m=lz.getBroadcastDims(t,i),g=lz.getBroadcastDims(n,i);if(m.length+g.length===0)for(let t=0;t<h.length;++t)h[t]=e(r[t%r.length],a[t%a.length]);else for(let t=0;t<h.length;++t){let n=ha.indexToLoc(t,o,l),s=n.slice(-p);m.forEach(e=>s[e]=0);let i=ha.locToIndex(s,p,c),u=n.slice(-d);g.forEach(e=>u[e]=0);let y=ha.locToIndex(u,d,f);h[t]=e(r[i],a[y])}return[h,i]}}var lz=lz,ha=ha,ha=ha,ha=ha;function b9(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=n.makeTensorInfo(r.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",s),imag:n.makeTensorInfo(a.shape,"float32",i)},o}function we(e,t,n="float32"){if("complex64"===n)return b9({inputs:{real:we(e,t,"float32"),imag:we(e,t,"float32")},backend:e});let r=ha.makeZerosTypedArray(ha.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function wt(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function wn(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.real,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}function wr(e,t,n,r){if("int32"===r)return[t,"int32",Int32Array.from(e)];if("bool"===r){let r=ha.toTypedArray([0],n),[a,s]=b7((e,t)=>+(e!==t))(t,[],e,r,"bool");return[s,"bool",a]}throw Error(`Error in Cast: failed to cast ${n} to ${r}`)}function wa(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if("complex64"===s){if("complex64"===a.dtype)return wt({inputs:{x:a},backend:n});let e=we(n,a.shape,a.dtype),t=wa({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),r=b9({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===a.dtype){let e=wn({inputs:{input:a},backend:n}),t=wa({inputs:{x:e},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(e),t}if(!ha.hasEncodingLoss(a.dtype,s)){let e=wt({inputs:{x:a},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:s}}let[i,o,l]=wr(n.data.get(a.dataId).values,a.shape,a.dtype,s);return n.makeTensorInfo(i,o,l)}function ws(e,t,n,r){return null==n?({inputs:n,backend:a})=>{let{a:s,b:i}=n;b4([s,i],e);let o=a.data.get(s.dataId).values,l=a.data.get(i.dataId).values,u="string"===s.dtype?lz.fromUint8ToStringArray(o):o,h="string"===s.dtype?lz.fromUint8ToStringArray(l):l,p=r||s.dtype,[d,c]=t(s.shape,i.shape,u,h,p);return a.makeTensorInfo(c,p,d)}:({inputs:e,backend:a})=>{let{a:s,b:i}=e;if("complex64"===s.dtype||"complex64"===i.dtype){let e=wa({inputs:{x:s},backend:a,attrs:{dtype:"complex64"}}),t=a.data.get(e.dataId),r=t.complexTensorInfos.real,o=t.complexTensorInfos.imag,l=a.data.get(r.dataId).values,u=a.data.get(o.dataId).values,h=wa({inputs:{x:i},backend:a,attrs:{dtype:"complex64"}}),p=a.data.get(h.dataId),d=p.complexTensorInfos.real,c=p.complexTensorInfos.imag,f=a.data.get(d.dataId).values,m=a.data.get(c.dataId).values,[g,y,x]=n(s.shape,i.shape,l,u,f,m),b=a.makeTensorInfo(x,"float32",g),w=a.makeTensorInfo(x,"float32",y),v=b9({inputs:{real:b,imag:w},backend:a});return a.disposeIntermediateTensorInfo(e),a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(b),a.disposeIntermediateTensorInfo(w),v}{let e=a.data.get(s.dataId).values,n=a.data.get(i.dataId).values,o=r||s.dtype,[l,u]=t(s.shape,i.shape,e,n,o);return a.makeTensorInfo(u,o,l)}}}function wi(e){return(t,n,r,a,s,i)=>{let o=lz.assertAndGetBroadcastShape(t,n),l=ha.sizeFromShape(o),u=o.length,h=ha.computeStrides(o),p=ha.getTypedArrayFromDType("float32",l),d=ha.getTypedArrayFromDType("float32",l),c=lz.getBroadcastDims(t,o),f=lz.getBroadcastDims(n,o),m=lz.mergeRealAndImagArrays(r,a),g=lz.mergeRealAndImagArrays(s,i),y=t.length,x=ha.computeStrides(t),b=n.length,w=ha.computeStrides(n);if(c.length+f.length===0)for(let t=0;t<p.length;t++){let n=t%m.length,r=t%g.length,a=e(m[2*n],m[2*n+1],g[2*r],g[2*r+1]);p[t]=a.real,d[t]=a.imag}else for(let t=0;t<p.length;t++){let n=ha.indexToLoc(t,u,h),r=n.slice(-y);c.forEach(e=>r[e]=0);let a=ha.locToIndex(r,y,x),s=n.slice(-b);f.forEach(e=>s[e]=0);let i=ha.locToIndex(s,b,w),o=e(m[2*a],m[2*a+1],g[2*i],g[2*i+1]);p[t]=o.real,d[t]=o.imag}return[p,d,o]}}let wo=b7((e,t)=>e+t),wl=ws("Add",wo,wi((e,t,n,r)=>({real:e+n,imag:t+r})));var ha=ha;function wu(e,t,n,r,a){let s=ha.sizeFromShape(r),i=ha.makeZerosTypedArray(a,n);for(let n=0;n<e.length;n++){let r=e[n];if(r<0)throw Error("Input x must be non-negative!");r>=a||(s>0?i[r]+=t[n]:i[r]+=1)}return i}function wh(e,t,n,r=!1){let a=e.shape[0],s=e.shape[1],i=sW([a,n],t.dtype);for(let o=0;o<a;o++)for(let a=0;a<s;a++){let s=e.get(o,a);if(s<0)throw Error("Input x must be non-negative!");s>=n||(r?i.set(1,o,s):t.size>0?i.set(i.get(o,s)+t.get(o,a),o,s):i.set(i.get(o,s)+1,o,s))}return i}let wp=b7((e,t)=>e&t),wd=ws(t7,wp);var ha=ha;function wc(e){return(t,n,r)=>{let a=ha.getArrayFromDType(n,t.length);for(let n=0;n<t.length;++n)a[n]=e(t[n],r);return a}}var lz=lz;function wf(e,t,n){return wm(e,wc(t),n)}function wm(e,t,n){return({inputs:r,attrs:a,backend:s})=>{let i,{x:o}=r;b4(o,e);let l=s.data.get(o.dataId).values;if("string"===o.dtype){if(!Array.isArray(l))throw Error("String tensor's value was not an instance of Array");i=lz.fromUint8ToStringArray(l)}else i=l;let u=n||o.dtype,h=t(i,u,a);return s.makeTensorInfo(o.shape,u,h)}}let wg=wc(e=>Math.ceil(e)),wy=wm(nt,wg);var lz=lz,ha=ha;function wx(e,t,n,r){let a=ha.getArrayFromDType(n,ha.sizeFromShape(t));if(r&&"string"!==n){let t=0;e.forEach(e=>{let n=ha.sizeFromShape(e.shape);a.set(e.vals,t),t+=n})}else{let r=0;e.forEach(e=>{let s="string"===n?lz.fromUint8ToStringArray(e.vals):e.vals,i=0;for(let n=0;n<e.shape[0];++n){let o=n*t[1]+r;for(let t=0;t<e.shape[1];++t)a[o+t]=s[i++]}r+=e.shape[1]})}return a}let wb=b7((e,t)=>+(e===t)),ww=ws(nE,wb,null,"bool"),wv=wc(e=>Math.exp(e)),wk=wm("Exp",wv,"float32"),wN=wc(e=>Math.expm1(e)),wI=wm(nR,wN),wS=wc(e=>Math.floor(e)),wC=wm(nD,wS),wT=b7((e,t)=>Math.floor(e/t)),w$=ws(nO,wT,null,"int32");function wE(e,t,n,r,a,s,i,o,l){let u=sW([r,s],n);for(let n=0;n<r;n++){let r=[],h=0;for(let t=0;t<a;t++){let s=e[n*a+t];h+=s*i[t],r.push(s)}if(h<0||h>=l/s)throw Error(`Invalid indices: ${r} does not index into ${o}`);for(let e=0;e<s;e++)u.values[n*s+e]=t.get(...t.indexToLoc(h*s+e))}return u}function wA(e,t,n){let r=sW(n,e.dtype);for(let n=0;n<r.size;++n){let a=r.indexToLoc(n).slice(),s=a[0],i=a[2],o=t.locToIndex([s,i]);a[2]=t.values[o];let l=e.locToIndex(a);0<=l&&l<e.values.length&&(r.values[n]=e.values[l])}return r}let wR=b7((e,t)=>+(e>t)),wF=ws(nP,wR,null,"bool"),w_=b7((e,t)=>+(e>=t)),wD=ws(nB,w_,null,"bool"),wO=b7((e,t)=>+(e<t)),wM=ws(nK,wO,null,"bool"),wL=b7((e,t)=>+(e<=t)),wz=ws(nX,wL,null,"bool");var ha=ha;function wP(e,t,n){let r=(t-e)/(n-1),a=ha.makeZerosTypedArray(n,"float32");a[0]=e;for(let e=1;e<a.length;e++)a[e]=a[e-1]+r;return a}let wB=wc(e=>Math.log(e)),wW=wm("Log",wB);var ha=ha;function wU(e,t,n,r){let a=ha.getTypedArrayFromDType(r,ha.sizeFromShape(n));for(let n=0;n<a.length;++n){let r=n*t,s=e[r];for(let n=0;n<t;++n){let t=e[r+n];(Number.isNaN(t)||t>s)&&(s=t)}a[n]=s}return a}let wj=b7((e,t)=>Math.max(e,t)),wV=ws(n2,wj),wG=b7((e,t)=>Math.min(e,t)),wH=ws(n9,wG),wq=b7((e,t)=>e*t),wK=ws(rn,wq,wi((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n})));var ha=ha;function wX(e,t,n){return wq([],t,ha.createScalarValue(-1,n),e,n)}let wY=b7((e,t)=>+(e!==t)),wZ=ws(rr,wY,null,"bool");var lz=lz,ha=ha,ha=ha;function wJ(e,t,n,r,a){let s=t.length,i=ha.sizeFromShape(t),o=ha.computeStrides(t),l=ha.computeStrides(a),u=ha.getTypedArrayFromDType(n,ha.sizeFromShape(a));for(let t=0;t<i;++t){let n=ha.indexToLoc(t,s,o),a=Array(n.length);for(let e=0;e<a.length;e++)a[e]=n[r[e]];u[ha.locToIndex(a,s,l)]=e[t]}return u}function wQ(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{perm:s}=n;b4(a,"transpose");let i=Array(a.shape.length);for(let e=0;e<i.length;e++)i[e]=a.shape[s[e]];let o=wJ(r.data.get(a.dataId).values,a.shape,a.dtype,s,i);return{dataId:r.write(o,i,a.dtype),shape:i,dtype:a.dtype}}function w0(e,t,n,r){let[a,s]=lz.computeOutAndReduceShapes(e,r),i=aD(t,"int32"),o=ha.makeZerosTypedArray(ha.sizeFromShape(a),i),l=ha.sizeFromShape(s);for(let e=0;e<o.length;++e){let t=e*l,r=1;for(let e=0;e<l;++e)r*=n[t+e];o[e]=r}return{outVals:o,outShape:a,outDtype:i}}var ha=ha;function w1(e,t){let n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function w2(e,t,n,r,a,s,i,o){let l,u,h,p;if(0===e.length)throw Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw Error("Split tensors must not be scalars");let d=t[0][0]-1;if(s.forEach((e,t)=>{if(e<0||e>=d){let n=ha.indexToLoc(t,i.length,ha.computeStrides(i)).join(",");throw Error(`indices[${n}] = ${e} is not in [0, ${d})`)}}),0===r.length)throw Error("params.rank must be nonzero");let{outSplits:c,valueSlices:f,numValues:m}=function(e,t,n,r){let a=[],s=0,i=Array(t.length-1+n.length).fill(null).map(()=>[0]);for(let e=0;e<n.length;++e){let t=n[e],a=e===n.length-1?r:n[e+1].length;if(0===t.length)throw Error("Ragged splits may not be empty");if(t[0]<0)throw Error("Ragged splits must be non-negative");if(t[t.length-1]>a)throw Error("Ragged splits must not point past values");for(let e=1;e<t.length;++e)if(t[e-1]>t[e])throw Error("Ragged splits must be sorted in ascending order")}let o=1;for(let e=0;e<t.length-1;++e){o*=t[e];let n=t[e+1];for(let t=1;t<o+1;++t)i[e].push(t*n)}for(let r=0;r<e.length;++r){let o=e[r],l=e[r]+1;for(let e=0;e<n.length;++e){let r=n[e],a=e+t.length-1;if(a>=0){let e=i[a],t=e[e.length-1]-r[o];for(let e=o;e<l;++e)i[a].push(r[e+1]+t)}o=r[o],l=r[l]}l!==o&&(a.push([o,l]),s+=l-o)}return{outSplits:i,valueSlices:a,numValues:s}}(s,i,e,r[0]),g=function(e){let t=[];for(let n=0;n<e.length;++n){let r=e[n].length,a=ha.getArrayFromDType("int32",r);t.push(a),e[n].forEach((e,t)=>a[t]=e)}return t}(c),y=((l=r.slice())[0]=m,u=ha.getArrayFromDType(a,ha.sizeFromShape(l)),p=0===(h=n.length)?0:h/r[0],!function(e,t,n,r,a,s){let i=w1(t,2)[1],o=w1(s,2)[1],l=0;for(let t of n)for(let n=t[0];n<t[1];++n){for(let t=0;t<r;++t)a[l*o+t]=e[n*i+t];++l}}(n,r,f,p,u,l),[u,l]);return[g,y[0],y[1]]}var ha=ha;function w3(e,t,n,r,a,s,i){if(t.length>1)throw Error("starts must be a scalar or vector");if(a.length>1)throw Error("limits must be a scalar or vector");if(i.length>1)throw Error("deltas must be a scalar or vector");let o=0===t.length,l=0===a.length,u=0===i.length,h=[];o||h.push(t[0]),l||h.push(a[0]),u||h.push(i[0]);for(let e=1;e<h.length;++e)if(h[e]!==h[e-1])throw Error("starts, limits, and deltas must have the same shape");let p=0===h.length?1:h[0],d=ha.getArrayFromDType("int32",p+1);d[0]=0;for(let t=0;t<p;++t){let n,a=o?e[0]:e[t],i=l?r[0]:r[t],h=u?s[0]:s[t];if(0===h)throw Error("Requires delta != 0");if(h>0&&i<a||h<0&&i>a)n=0;else if((n=Math.ceil(Math.abs((i-a)/h)))>0x7fffffff)throw Error("Requires ((limit - start) / delta) <= 2147483647");d[t+1]=d[t]+n}let c=d[p],f=ha.getArrayFromDType(n,c),m=0;for(let t=0;t<p;++t){let n=d[t+1]-d[t],r=o?e[0]:e[t],a=u?s[0]:s[t];for(let e=0;e<n;++e)f[m++]=r,r+=a}return[d,f]}var lz=lz,ha=ha,w4=lz.RowPartitionType;class w5{constructor(e,t,n,r,a,s,i,o,l,u){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=a,this.defaultValue=s,this.defaultValueShape=i,this.rowPartitionValues=o,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=lz.getRowPartitionTypesHelper(u),this.raggedRank=lz.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===w4.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===w4.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){let t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case w4.VALUE_ROWIDS:return w5.getMaxWidthValueRowID(t);case w4.ROW_SPLITS:return w5.getMaxWidthRowSplit(t);default:throw Error(`Cannot handle partition type ${w4[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){let t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){let t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){let t=e.length;if(0===t)return 0;let n=0,r=e[0],a=0;for(let s=1;s<t;++s){let t=e[s];t!==r&&(r=t,a=Math.max(s-n,a),n=s)}return Math.max(t-n,a)}tensorShapeFromTensor(e,t,n=!0){if(0===t.length){if(-1===e[0])return[];throw Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return w8(e,n)}calculateOutputSize(e){let t=this.valuesShape,n=this.defaultValueShape;lz.validateDefaultValueShape(n,t);let r=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=lz.combineRaggedTensorToTensorShapes(this.raggedRank,r,t);a[0]<0&&(a[0]=e);for(let e=1;e<=this.raggedRank;++e)a[e]<0&&(a[e]=this.getMaxWidth(e));return a}calculateFirstParentOutputIndex(e,t,n){let r=Math.min(e,n),a=[],s=0;for(let e=0;e<r;++e,s+=t)a.push(s);for(let t=r;t<e;++t)a.push(-1);return ha.assert(a.length===e,()=>"Final length of result must be equal to firstDimension."),a}calculateOutputIndexRowSplit(e,t,n,r){let a=e.length,s=[];for(let i=0;i<a-1;++i){let a=e[i+1]-e[i],o=Math.min(r,a),l=t[i];-1===l&&(o=0);for(let e=0;e<o;++e)s.push(l),l+=n;for(let e=0;e<a-o;++e)s.push(-1)}if(a>0&&s.length!==e[a-1])throw Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(e,t,n,r){let a=e.length,s=[];if(0===a)return[];let i=0,o=e[0];if(o>=t.length)throw Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let l=t[o];s.push(l);for(let u=1;u<a;++u){let a=e[u];if(a===o)l>=0&&(++i<r?l+=n:l=-1);else{if(i=0,o=a,a>=t.length)throw Error(`Got nextValueRowId=${a} which is not less than ${t.length}`);l=t[a]}s.push(l)}if(s.length!==e.length)throw Error("Invalid row ids.");return s}calculateOutputIndex(e,t,n,r){let a=this.getRowPartitionTensor(e),s=this.getRowPartitionTypeByDimension(e);switch(s){case w4.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,t,n,r);case w4.ROW_SPLITS:if(a.length-1>t.length)throw Error(`Row partition size is greater than output size: ${a.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(a,t,n,r);default:throw Error(`Unsupported partition type: ${w4[s]}`)}}getFirstDimensionSize(){let e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw Error("No row_partition_types given.");let t=this.rowPartitionTypes[0];switch(t){case w4.FIRST_DIM_SIZE:return e[0];case w4.VALUE_ROWIDS:throw Error("Cannot handle VALUE_ROWIDS in first dimension.");case w4.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw Error(`Cannot handle type ${w4[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw Error("Invalid first partition input. Tensor requires at least one element.");let e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=Array(this.raggedRank+1);n[n.length-1]=1;for(let e=n.length-2;e>=0;--e)n[e]=n[e+1]*t[e+1];let r=w8(t,!1),a=ha.getArrayFromDType(this.valuesDType,ha.sizeFromShape(r));if(n[0]*t[0]>0){let s=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e)s=this.calculateOutputIndex(e-1,s,n[e],t[e]);this.setOutput(this.raggedRank,s,a,r)}return[r,a]}setOutput(e,t,n,r){if(0===n.length)return;let a=this.values,s=r.slice();s=s.slice(e+1);let i=ha.sizeFromShape(s),o=t.length,l=this.defaultValue;if(l.length!==i&&1!==l.length){let e=this.defaultValueShape;st(()=>{l=iW(iy(l,e),s).dataSync()})}let u=0,h=0,p=0;for(let e=0;e<=o;++e){let r=e<o?t[e]:-1;if(r===p){++p;continue}if(h<p){let e=a.subarray(u*i);w6(n.subarray(h*i),e,(p-h)*i)}if(e>=o&&(r=Math.floor(n.length/i)),r>p)if(1===this.defaultValue.length)n.subarray(p*i,r*i).fill(this.defaultValue[0]),p=r;else for(;r>p;)w6(n.slice(p*i),l,i),++p;r<0?(u=e+1,h=p):(u=e,p=(h=p)+1)}}}function w6(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function w8(e,t){let n=[];for(let r of e){if(r<0){if(!t)throw Error(`Dimension ${r} must be >= 0`);if(r<-1)throw Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function w7(e,t,n,r,a,s,i,o,l,u){return new w5(e,t,n,r,a,s,i,o,l,u).compute()}var ha=ha;function w9(e,t,n,r){let a=e===t,s=e<t&&n<0,i=t<e&&n>1;if(a||s||i)return ha.makeZerosTypedArray(0,r);let o=Math.abs(Math.ceil((t-e)/n)),l=ha.makeZerosTypedArray(o,r);t<e&&1===n&&(n=-1),l[0]=e;for(let e=1;e<l.length;e++)l[e]=l[e-1]+n;return l}let ve=wc(e=>1/Math.sqrt(e)),vt=wm(r$,ve);function vn(e,t,n,r,a,s,i,o,l,u){let h=e.values,p=t.values;if(0===r)return sW(n,t.dtype);let d=l instanceof aT?l:sW([r/a,a],t.dtype);"string"==typeof l||"number"==typeof l?d.values.fill(l):"boolean"==typeof l&&d.values.fill(+l);for(let e=0;e<s;e++){let s=[],l=0;for(let t=0;t<i;t++){let n=h[e*i+t];s.push(n),l+=n*o[t]}if(l<0||l>=r/a)throw Error(`Invalid indices: ${s} does not index into ${n}`);for(let n=0;n<a;n++)u?d.values[l*a+n]+=p[e*a+n]:d.values[l*a+n]=0===t.rank?p[0]:p[e*a+n]}return d}let vr=wc(e=>1/(1+Math.exp(-e))),va=wf(rL,e=>1/(1+Math.exp(-e)));var lz=lz,vs=oB,ha=ha;function vi(e,t,n,r,a){let s=vs.isSliceContinous(r,t,n),i=ha.sizeFromShape(n),o=ha.computeStrides(r);if(s){let n=vs.computeFlatOffset(t,o);return"string"===a?e.slice(n,n+i):e.subarray(n,n+i)}let l="string"===a?lz.fromUint8ToStringArray(e):e,u=sW(r,a,l),h=sW(n,a);for(let e=0;e<h.size;++e){let n=h.indexToLoc(e),r=n.map((e,n)=>e+t[n]);h.set(u.get(...r),...n)}return"string"===a?lz.fromStringArrayToUint8(h.values):h.values}function vo(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r;b4(a,"slice");let[o,l]=vs.parseSliceParams(a,s,i);vs.assertParamsValid(a,o,l);let u=vi(n.data.get(a.dataId).values,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,u)}var lz=lz,ha=ha;function vl(e,t,n,r,a,s,i){let o=t[0],l=s[0],u=Array(l),h=Array(o),p=t[1];if(0===l){if(0!==o)throw Error(lz.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));return[ha.getArrayFromDType(n,0),[0,p],ha.getArrayFromDType(a,0),u,h]}let d=!0,c=0,f=Array(l).fill(0);for(let t=0;t<o;++t){let n=e[t*p];if(n<0)throw Error(lz.getSparseFillEmptyRowsNegativeIndexErrorMessage(t,n));if(n>=l)throw Error(lz.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(t,n,l));++f[n],d=d&&n>=c,c=n}let m=!0;for(let e=0;e<l;++e){let t=0===f[e];u[e]=t,m=m&&!t,f[e]=Math.max(f[e],1),e>0&&(f[e]+=f[e-1])}if(m&&d){for(let e=0;e<o;++e)h[e]=e;return[e,[o,p],r,u,h]}{let t=f[l-1],s=ha.getArrayFromDType(n,t*p),d=ha.getArrayFromDType(a,t),c=Array(l).fill(0);for(let t=0;t<o;++t){let n=e[t*p],a=c[n],i=(0===n?0:f[n-1])+a;c[n]++;for(let n=0;n<p;++n)s[i*p+n]=e[t*p+n];d[i]=r[t],h[t]=i}for(let e=0;e<l;++e)if(0===c[e]){let t=0===e?0:f[e-1];s[t*p+0]=e;for(let e=1;e<p;++e)s[t*p+e]=0;d[t]=i}return[s,[t,p],d,u,h]}}var lz=lz,ha=ha;function vu(e,t,n,r,a){let s=ha.sizeFromShape(r),i=t[0],o=a.length,l=[],u=1,h=-1;for(let e=0;e<o;++e){let t=a[e];if(-1===t){if(-1!==h)throw Error(lz.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(h,e));h=e,l.push(1)}else{if(t<0)throw Error(lz.getSparseReshapeNegativeOutputDimErrorMessage(e,t));u*=t,l.push(t)}}if(-1!==h){if(u<=0)throw Error(lz.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let e=Math.trunc(s/u);if(u*e!==s)throw Error(lz.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[h]=e}if(ha.sizeFromShape(l)!==s)throw Error(lz.getSparseReshapeInputOutputMismatchErrorMessage(r,l));let p=r.length,d=[];if(p>0){d[p-1]=1;for(let e=p-2;e>=0;--e)d[e]=d[e+1]*r[e+1]}let c=[];if(o>0){c[o-1]=1;for(let e=o-2;e>=0;--e)c[e]=c[e+1]*l[e+1]}let f=ha.getArrayFromDType(n,i*o);for(let t=0;t<i;++t){let n=0;for(let r=0;r<p;++r)n+=e[t*p+r]*d[r];for(let e=0;e<o;++e)f[t*o+e]=Math.trunc(n/c[e]),n%=c[e]}return[f,[i,o],l]}var lz=lz,ha=ha;function vh(e,t,n,r,a,s=!1,i=0){let o=r.length,l=[t[0],e.length/t[0]],u=l[1],h=o>0?a[o-1]+1:0;if(h<0)throw Error(lz.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let p=t.slice();p[0]=h;let d=p.reduce((e,t)=>e*t,1),c=ha.getArrayFromDType(n,d);if(0===o)return h>0&&c.fill(i),[c,p];if(h<=0)throw Error(lz.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let f=0,m=1,g=0,y=a[0];for(;;){let t=0;if(m<o){if(y===(t=a[m])){++m;continue}if(y>=t)throw Error(lz.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(y<0||y>=h)throw Error(lz.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y,h));y>g&&c.fill(i,g*u,y*u);for(let t=f;t<m;++t){let n=r[t];if(n<0||n>=l[0])throw Error(lz.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(t,r[t],l[0]));for(let t=0;t<u;t++)c[y*u+t]+=e[n*u+t]}if(s)for(let e=0;e<u;e++)c[y*u+e]/=m-f;if(f=m,++m,g=y+1,y=t,m>o)break}return g<h&&c.fill(i,g*u,h*u),[c,p]}let vp=wc(e=>Math.sqrt(e)),vd=wf(rP,e=>Math.sqrt(e)),vc=b7((e,t)=>{let n=e-t;return n*n}),vf=ws(rK,vc),vm=wc((e,t)=>{let{pattern:n,replaceGlobal:r,rewrite:a}=t;return e.replace(new RegExp(n,r?"g":""),a)}),vg=wm(rY,vm);function vy(e,t,n,r){let a=sW(e,t.dtype);for(let e=0;e<a.size;e++){let s=a.indexToLoc(e),i=Array(s.length);for(let e=0;e<i.length;e++)i[e]=s[e]*n[e]+r[e];a.set(t.get(...i),...s)}return a}var ha=ha;class vx{constructor(e,t,n,r,a,s){this.separator=ha.encodeString(e),this.nGramWidths=t,this.leftPad=ha.encodeString(n),this.rightPad=ha.encodeString(r),this.padWidth=a,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){return Math.max(0,e+2*this.getPadWidth(t)-t+1)}createNGrams(e,t,n,r,a,s){for(let i=0;i<a;++i){let o,l=this.getPadWidth(s),u=Math.max(0,l-i),h=Math.max(0,l-(a-(i+1))),p=s-(u+h),d=t+(u>0?0:i-l);o=0+u*this.leftPad.length;for(let t=0;t<p;++t)o+=e[d+t].length;o+=h*this.rightPad.length,o+=(u+h+p-1)*this.separator.length,n[r+i]=new Uint8Array(o);let c=n[r+i],f=0,m=e=>e.forEach(e=>c[f++]=e);for(let e=0;e<u;++e)m(this.leftPad),m(this.separator);for(let t=0;t<p-1;++t)m(e[d+t]),m(this.separator);if(p>0){m(e[d+p-1]);for(let e=0;e<h;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<h-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){let n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw Error(`First split value must be 0, got ${e}`);for(let a=1;a<r;++a){let r=t[a]>=e;if(!(r=r&&t[a]<=n))throw Error(`Invalid split value ${t[a]}, must be in [${e}, ${n}]`);e=t[a]}if(e!==n)throw Error(`Last split value must be data size. Expected ${n}, got ${e}`)}let a=r-1,s=ha.getArrayFromDType("int32",r);if(0===n||0===r){let e=Array(n);for(let e=0;e<=a;++e)s[e]=0;return[e,s]}s[0]=0;for(let e=1;e<=a;++e){let n=t[e]-t[e-1],r=0;this.nGramWidths.forEach(e=>{r+=this.getNumNGrams(n,e)}),this.preserveShort&&n>0&&0===r&&(r=1),s[e]=s[e-1]+r}let i=Array(s[a]);for(let n=0;n<a;++n){let r=t[n],a=s[n];if(this.nGramWidths.forEach(s=>{let o=t[n+1]-t[n],l=this.getNumNGrams(o,s);this.createNGrams(e,r,i,a,l,s),a+=l}),this.preserveShort&&a===s[n]){let s=t[n+1]-t[n];if(0===s)continue;let o=s+2*this.padWidth;this.createNGrams(e,r,i,a,1,o)}}return[i,s]}}function vb(e,t,n,r,a,s,i,o){return new vx(n,r,a,s,i,o).compute(e,t)}var ha=ha;function vw(e,t,n){let r=e.length,a=[],s=0,i=0,o=Array(r);for(let l=0;l<r;++l){let r=a.length;!function(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){let a=t[0],s=e.indexOf(a);for(;-1!==s;){let t=e.subarray(0,s);n&&0===t.length||r.push(t),s=(e=e.subarray(s+1)).indexOf(a)}n&&0===e.length||r.push(e);return}let a=0;for(let s=0;s<e.length+1;s++)if(s===e.length||-1!==t.indexOf(e[s])){let t=e.subarray(a,s);n&&0===t.length||r.push(t),a=s+1}}(e[l],t,n,a);let u=a.length-r;o[l]=u,s+=u,i=Math.max(i,u)}let l=ha.getArrayFromDType("int32",2*s),u=Array(s),h=[r,i],p=0;for(let e=0;e<r;++e)for(let t=0;t<o[e];++t)l[2*p]=e,l[2*p+1]=t,u[p]=a[p],++p;return[l,u,h]}var ha=ha;function vv(e,t){let n=ha.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)n[r]=ha.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n}let vk=b7((e,t)=>e-t),vN=ws("Sub",vk,wi((e,t,n,r)=>({real:e-n,imag:t-r})));function vI(e,t){let n=Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];let r=sW(n,e.dtype);for(let t=0;t<r.values.length;++t){let n=r.indexToLoc(t),a=Array(e.rank);for(let t=0;t<a.length;t++)a[t]=n[t]%e.shape[t];let s=e.locToIndex(a);r.values[t]=e.values[s]}return r}var ha=ha;let vS=(e,t)=>{let n=t.value-e.value;return 0===n?e.index-t.index:n};function vC(e,t,n,r,a){let s=t[t.length-1],[i,o]=[e.length/s,s],l=ha.getTypedArrayFromDType(n,i*r),u=ha.getTypedArrayFromDType("int32",i*r);for(let t=0;t<i;t++){let n=t*o,s=e.subarray(n,n+o),i=Array(s.length);s.forEach((e,t)=>i[t]={value:e,index:t}),r<i.length&&(!function e(t,n,r=0,a=t.length-1){for(;a>r;){if(a-r>600){let s=a-r+1,i=n-r+1,o=Math.log(s),l=.5*Math.exp(2*o/3),u=.5*Math.sqrt(o*l*(s-l)/s)*Math.sign(i-s/2),h=Math.max(r,Math.floor(n-i*l/s+u)),p=Math.min(a,Math.floor(n+(s-i)*l/s+u));e(t,n,h,p)}let s=t[n],i=r,o=a;for(ha.swap(t,r,n),vS(t[a],s)>0&&ha.swap(t,r,a);i<o;){for(ha.swap(t,i,o),i++,o--;0>vS(t[i],s);)i+=1;for(;vS(t[o],s)>0;)o-=1}0===vS(t[r],s)?ha.swap(t,r,o):(o+=1,ha.swap(t,o,a)),o<=n&&(r=o+1),n<=o&&(a=o-1)}}(i,r),i=i.slice(0,r)),a&&i.sort(vS);let h=t*r,p=l.subarray(h,h+r),d=u.subarray(h,h+r);for(let e=0;e<r;e++)p[e]=i[e].value,d[e]=i[e].index}let h=t.slice();return h[h.length-1]=r,[sW(h,n,l),sW(h,"int32",u)]}var ha=ha;function vT(e,t,n,r){let a=ha.parseAxisParam(t,n)[0],s=[1,n[0],1];for(let e=0;e<a;e++)s[0]*=n[e];s[1]=n[a];for(let e=a+1;e<n.length;e++)s[2]*=n[e];let i=new Map,o=new Int32Array(n[a]),l=new aT(s,r,e),u=[],h=1===s[0]&&1===s[2];for(let t=0;t<n[a];t++){let n;if(h)n=e[t].toString();else{let e=[];for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)e.push(l.get(n,t,r));n=e.join(",")}let r=i.get(n);if(null!=r)o[t]=r;else{let e=i.size;i.set(n,e),o[t]=e,u.push(t)}}let p=s.slice();p[1]=i.size;let d=new aT(p,r);u.forEach((e,t)=>{for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)d.set(l.get(n,e,r),n,t,r)});let c=n.slice();return c[a]=p[1],{outputValues:d.values,outputShape:c,indices:o}}e.s(["addImpl",0,wo,"bincountImpl",()=>wu,"bincountReduceImpl",()=>wh,"bitwiseAndImpl",0,wp,"castImpl",()=>wr,"ceilImpl",0,wg,"concatImpl",()=>wx,"equalImpl",0,wb,"expImpl",0,wv,"expm1Impl",0,wN,"floorDivImpl",0,wT,"floorImpl",0,wS,"gatherNdImpl",()=>wE,"gatherV2Impl",()=>wA,"greaterEqualImpl",0,w_,"greaterImpl",0,wR,"lessEqualImpl",0,wL,"lessImpl",0,wO,"linSpaceImpl",()=>wP,"logImpl",0,wB,"maxImpl",()=>wU,"maximumImpl",0,wj,"minimumImpl",0,wG,"multiplyImpl",0,wq,"negImpl",()=>wX,"notEqualImpl",0,wY,"prodImpl",()=>w0,"raggedGatherImpl",()=>w2,"raggedRangeImpl",()=>w3,"raggedTensorToTensorImpl",()=>w7,"rangeImpl",()=>w9,"rsqrtImpl",0,ve,"scatterImpl",()=>vn,"sigmoidImpl",0,vr,"simpleAbsImpl",()=>b8,"sliceImpl",()=>vi,"sparseFillEmptyRowsImpl",()=>vl,"sparseReshapeImpl",()=>vu,"sparseSegmentReductionImpl",()=>vh,"sqrtImpl",0,vp,"squaredDifferenceImpl",0,vc,"staticRegexReplaceImpl",0,vm,"stridedSliceImpl",()=>vy,"stringNGramsImpl",()=>vb,"stringSplitImpl",()=>vw,"stringToHashBucketFastImpl",()=>vv,"subImpl",0,vk,"tileImpl",()=>vI,"topKImpl",()=>vC,"transposeImpl",()=>wJ,"uniqueImpl",()=>vT],11583);var v$=e.i(11583);sa("cpu",()=>new b6,1),e.s([],48890);let vE=wf("Elu",e=>e>=0?e:Math.exp(e)-1);var ha=ha;function vA(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r;b4([a],"leakyRelu");let i=ha.sizeFromShape(a.shape),o=n.data.get(a.dataId).values,l=ha.getTypedArrayFromDType("float32",i);for(let e=0;e<o.length;e++)l[e]=o[e]<0?s*o[e]:o[e];return n.makeTensorInfo(a.shape,"float32",l)}let vR=b7((e,t)=>e<0?t*e:e);function vF(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t;b4([r,a],"prelu");let s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,[o,l]=vR(r.shape,a.shape,s,i,"float32");return n.makeTensorInfo(l,"float32",o)}let v_=wf(rb,e=>Math.max(0,e)),vD=wf(rS,e=>Math.min(Math.max(0,e),6));function vO(e,t,n,r,a){if("linear"===n)return wt({inputs:{x:t},backend:e});if("relu"===n)return v_({inputs:{x:t},backend:e});if("elu"===n)return vE({inputs:{x:t},backend:e});if("relu6"===n)return vD({inputs:{x:t},backend:e});if("prelu"===n)return vF({inputs:{x:t,alpha:r},backend:e});else if("leakyrelu"===n)return vA({inputs:{x:t},backend:e,attrs:{alpha:a}});else if("sigmoid"===n)return va({inputs:{x:t},backend:e});throw Error(`Activation ${n} has not been implemented for the CPU backend.`)}var vM=oK,ha=ha,ha=ha;function vL(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=ha.sizeFromShape(a.shape),o=ha.inferFromImplicitShape(s,i),l=ha.sizeFromShape(o);ha.assert(i===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${a.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.incRef(a.dataId);let u=n.data.get(a.dataId);if(null!=u.complexTensorInfos){let e=u.complexTensorInfos.real,t=u.complexTensorInfos.imag;e.shape=o,t.shape=o}return{dataId:a.dataId,shape:o,dtype:a.dtype}}function vz(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s}=t,{transposeA:i,transposeB:o}=r;b4([a,s],"matMul");let l=a.shape.length,u=s.shape.length,h=i?a.shape[l-2]:a.shape[l-1],p=o?s.shape[u-1]:s.shape[u-2],d=i?a.shape[l-1]:a.shape[l-2],c=o?s.shape[u-2]:s.shape[u-1],f=a.shape.slice(0,-2),m=s.shape.slice(0,-2),g=ha.sizeFromShape(f),y=ha.sizeFromShape(m),x=vM.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([d,c]);ha.assert(h===p,()=>`Error in matMul: inner shapes (${h}) and (${p}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`);let b=vL({inputs:{x:a},backend:n,attrs:{shape:i?[g,h,d]:[g,d,h]}}),w=vL({inputs:{x:s},backend:n,attrs:{shape:o?[y,c,p]:[y,p,c]}}),v=i?b.shape[1]:b.shape[2],k=i?b.shape[2]:b.shape[1],N=o?w.shape[1]:w.shape[2],I=Math.max(g,y),S=n.data.get(b.dataId).values,C=n.data.get(w.dataId).values,T=ha.computeStrides(b.shape),$=ha.computeStrides(w.shape),[E,A,R]=i?[T[0],1,T[1]]:[T[0],T[1],1],[F,_,D]=o?[1,$[1],$[0]]:[$[1],1,$[0]],O=k*N,M=sW([I,k,N],b.dtype),L=M.values,z=n.blockSize;for(let e=0;e<I;e++){let t=e%g,n=e%y;for(let r=0;r<k;r+=z){let a=Math.min(r+z,k);for(let s=0;s<N;s+=z){let i=Math.min(s+z,N);for(let o=0;o<v;o+=z){let l=Math.min(o+z,v);for(let u=r;u<a;u++)for(let r=s;r<i;r++){let a=0;for(let e=o;e<l;e++)a+=S[t*E+u*A+e*R]*C[e*F+r*_+n*D];L[e*O+(u*N+r)]+=a}}}}}return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(x,M.dtype,M.values)}let vP=wf(tG,e=>Math.acos(e)),vB=wf(tH,e=>Math.acosh(e));var lz=lz,ha=ha,lz=lz,ha=ha,lz=lz,ha=ha,lz=lz,ha=ha;let vW=wf(tY,e=>Math.asin(e)),vU=wf(tZ,e=>Math.asinh(e)),vj=wf(tJ,e=>Math.atan(e)),vV=ws(t0,b7((e,t)=>Math.atan2(e,t))),vG=wf(tQ,e=>Math.atanh(e));var lz=lz,ha=ha;function vH(e,t,n,r,a,s){let i=a.strideHeight,o=a.strideWidth,l=a.dilationHeight,u=a.dilationWidth,h=a.effectiveFilterHeight,p=a.effectiveFilterWidth,d=a.padInfo.top,c=a.padInfo.left,f="max"===s?-1/0:1/0,m=sW(a.outShape,n),g=m.values,y=a.outShape[1]*a.outShape[2]*a.outShape[3],x=a.outShape[2]*a.outShape[3],b=a.outShape[3];for(let t=0;t<a.batchSize;++t){let n=t*y,m=t*r[0];for(let t=0;t<a.inChannels;++t)for(let y=0;y<a.outHeight;++y){let w=y*i-d,v=Math.max(0,w),k=Math.min(a.inHeight,h+w),N=n+y*x;for(let n=0;n<a.outWidth;++n){let i=n*o-c,h=Math.max(0,i),d=Math.min(a.inWidth,p+i),y=f,x=0,w=0;for(let n=v;n<k;n+=l){let a=m+n*r[1];for(let n=h;n<d;n+=u){let i=e[a+n*r[2]+t];"max"===s&&i>y?y=i:"avg"===s&&(x+=i,w++)}if(isNaN(y))break}g[N+n*b+t]="avg"===s?x/w:y}}}return m}function vq(e,t,n,r,a=!1,s=!1){let i=sW(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,h=r.dilationWidth,p=r.effectiveFilterHeight,d=r.effectiveFilterWidth,c=r.padInfo.top,f=r.padInfo.left,m=sW(t,n,e);for(let e=0;e<r.batchSize;++e)for(let t=0;t<r.inChannels;++t)for(let n=0;n<r.outHeight;++n){let g=n*o-c,y=g;for(;y<0;)y+=u;let x=Math.min(r.inHeight,p+g);for(let o=0;o<r.outWidth;++o){let p=o*l-f,c=p;for(;c<0;)c+=h;let b=Math.min(r.inWidth,d+p),w=-1/0,v=-1;for(let n=y;n<x;n+=u){let i=n-g;for(let o=c;o<b;o+=h){let l=o-p,u=m.get(e,n,o,t);u>w&&(w=u,v=a?s?((e*r.inHeight+n)*r.inWidth+o)*r.inChannels+t:(n*r.inWidth+o)*r.inChannels+t:i*d+l)}}i.set(v,e,n,o,t)}}return i}function vK(e,t,n,r,a,s){let i=a.strideDepth,o=a.strideHeight,l=a.strideWidth,u=a.dilationDepth,h=a.dilationHeight,p=a.dilationWidth,d=a.effectiveFilterDepth,c=a.effectiveFilterHeight,f=a.effectiveFilterWidth,m=a.padInfo.front,g=a.padInfo.top,y=a.padInfo.left,x="max"===s?-1/0:1/0,b=sW(a.outShape,n),w=b.values,v=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],k=a.outShape[2]*a.outShape[3]*a.outShape[4],N=a.outShape[3]*a.outShape[4],I=a.outShape[4];for(let t=0;t<a.batchSize;++t){let n=t*v,b=t*r[0];for(let t=0;t<a.inChannels;++t)for(let v=0;v<a.outDepth;++v){let S=v*i-m,C=S;for(;C<0;)C+=u;let T=Math.min(a.inDepth,d+S),$=n+v*k;for(let n=0;n<a.outHeight;++n){let i=n*o-g,d=i;for(;d<0;)d+=h;let m=Math.min(a.inHeight,c+i),v=$+n*N;for(let n=0;n<a.outWidth;++n){let i=n*l-y,o=i;for(;o<0;)o+=p;let c=Math.min(a.inWidth,f+i),g=v+n*I,k=x,N=0,S=0;for(let n=C;n<T;n+=u){let a=b+n*r[1];for(let n=d;n<m;n+=h){let i=a+n*r[2];for(let n=o;n<c;n+=p){let a=e[i+n*r[3]+t];if("max"===s&&a>k?k=a:"avg"===s&&(N+=a,S++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}w[g+t]="avg"===s?N/Math.max(S,1):k}}}}return b}var lz=lz,ha=ha,lz=lz,lz=lz,ha=ha,lz=lz,lz=lz;let vX=wf(nn,(e,t)=>e>t.clipValueMax?t.clipValueMax:e<t.clipValueMin?t.clipValueMin:e);var ha=ha,lz=lz,ha=ha;function vY(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.imag,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}function vZ(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=ha.parseAxisParam(a,t[0].shape)[0],i=t.map(e=>e.shape);lz.assertParamsConsistent(i,s);let o=lz.computeOutShape(t.map(e=>e.shape),s);if(0===ha.sizeFromShape(o))return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter(e=>ha.sizeFromShape(e.shape)>0);if(1===l.length)return wt({inputs:{x:l[0]},backend:n});if("complex64"===l[0].dtype){let e=l.map(e=>wn({inputs:{input:e},backend:n})),t=l.map(e=>vY({inputs:{input:e},backend:n})),r=vZ({inputs:e,backend:n,attrs:{axis:s}}),a=vZ({inputs:t,backend:n,attrs:{axis:s}}),i=b9({inputs:{real:r,imag:a},backend:n});return e.forEach(e=>n.disposeIntermediateTensorInfo(e)),t.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),i}let u=l.map(e=>{let t=ha.sizeFromShape(e.shape.slice(s));return vL({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})}),h=u.map(e=>({vals:n.data.get(e.dataId).values,shape:e.shape}));o=lz.computeOutShape(u.map(e=>e.shape),1);let p=1===u[0].shape[0],d=wx(h,o,t[0].dtype,p),c=lz.computeOutShape(l.map(e=>e.shape),s),f=n.makeTensorInfo(c,t[0].dtype,d);return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),f}var lz=lz,ha=ha;function vJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:h}=r;b4([a,s],"conv2d");let p=lz.convertConv2DDataFormat(l),d=lz.computeConv2DInfo(a.shape,s.shape,i,u,o,h,!1,p),c=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,y=d.padInfo.left,x=d.padInfo.top,b="channelsLast"===d.dataFormat,w=new aT(d.outShape,a.dtype),v=ha.computeStrides(a.shape),k=ha.computeStrides(s.shape),N=v[0],I=b?v[1]:v[2],S=b?v[2]:1,C=b?1:v[1],T=w.strides[0],$=b?w.strides[1]:w.strides[2],E=b?w.strides[2]:1,A=b?1:w.strides[1],R=n.data.get(a.dataId).values,F=n.data.get(s.dataId).values,_=w.values;for(let e=0;e<d.batchSize;++e){let t=e*N,n=e*T;for(let e=0;e<d.outHeight;++e){let r=n+e*$,a=e*d.strideHeight-x;for(let e=0;e<c;++e){let n=a+e*m;if(n<0||n>=d.inHeight)continue;let s=e*k[0],i=t+n*I;for(let e=0;e<d.outWidth;++e){let t=r+e*E,n=e*d.strideWidth-y;for(let e=0;e<f;++e){let r=n+e*g;if(r<0||r>=d.inWidth)continue;let a=s+e*k[1],o=i+r*S,l=a;for(let e=0;e<d.inChannels;++e){let n=R[o+e*C];for(let e=0;e<d.outChannels;++e)_[t+e*A]+=n*F[l+e];l+=d.outChannels}}}}}}return n.makeTensorInfo(w.shape,w.dtype,_)}var lz=lz,lz=lz,ha=ha,lz=lz,ha=ha,lz=lz,ha=ha,lz=lz,ha=ha;let vQ=wf("Cos",e=>Math.cos(e)),v0=wf(nd,e=>Math.cosh(e));var ha=ha,lz=lz,ha=ha,lz=lz,ha=ha,ha=ha,lz=lz,ha=ha;function v1(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;b4([a,s],"depthwiseConv2DNative");let h=ha.computeStrides(a.shape),p=ha.computeStrides(s.shape),d=l;null==d&&(d=[1,1]),ha.assert(lz.eitherStridesOrDilationsAreOne(i,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);let c=lz.computeConv2DInfo(a.shape,s.shape,i,d,o,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:x}=c,b=x.left,w=x.top,v=c.outChannels/c.inChannels,k=new aT(c.outShape,a.dtype),N=n.data.get(a.dataId).values,I=n.data.get(s.dataId).values,S=k.values;for(let e=0;e<c.batchSize;++e){let t=e*h[0],n=e*k.strides[0];for(let e=0;e<c.outHeight;++e){let r=n+e*k.strides[1],a=e*c.strideHeight-w;for(let e=0;e<f;++e){let n=a+e*g;if(n<0||n>=c.inHeight)continue;let s=e*p[0],i=t+n*h[1];for(let e=0;e<c.outWidth;++e){let t=r+e*k.strides[2],n=e*c.strideWidth-b;for(let e=0;e<m;++e){let r=n+e*y;if(r<0||r>=c.inWidth)continue;let a=s+e*p[1],o=i+r*c.inChannels,l=t,u=a;for(let e=0;e<c.inChannels;++e){let t=N[o+e];for(let e=0;e<v;++e)S[l+e]+=t*I[u+e];l+=v,u+=v}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}var lz=lz,lz=lz,ha=ha,ha=ha,lz=lz,ha=ha,lz=lz,ha=ha,lz=lz,ha=ha,lz=lz,ha=ha,lz=lz,ha=ha;function v2(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{axis:i,keepDims:o}=a;b4(s,"sum");let l=(t="bool"===s.dtype?wa({inputs:{x:s},backend:r,attrs:{dtype:"int32"}}):wt({inputs:{x:s},backend:r})).shape.length,u=ha.parseAxisParam(i,t.shape),h=lz.getAxesPermutation(u,l),p=u,d=t;null!=h&&(d=wQ({inputs:{x:t},backend:r,attrs:{perm:h}}),p=lz.getInnerMostAxes(p.length,l)),lz.assertAxesAreInnerMostDims("sum",p,d.shape.length);let[c,f]=lz.computeOutAndReduceShapes(d.shape,p),m=we(r,c,lz.upcastType(d.dtype,"int32")),g=ha.sizeFromShape(f),y=r.data.get(m.dataId).values,x=r.data.get(d.dataId).values;for(let e=0;e<y.length;++e){let t=e*g,n=0;for(let e=0;e<g;++e)n+=x[t+e];y[e]=n}if(o){let e=lz.expandShapeToKeepDim(m.shape,u),t=m;m=vL({inputs:{x:m},backend:r,attrs:{shape:e}}),r.disposeIntermediateTensorInfo(t)}return r.disposeIntermediateTensorInfo(t),null!=h&&r.disposeIntermediateTensorInfo(d),m}var ha=ha,lz=lz;let v3=lz.ERF_P,v4=lz.ERF_A1,v5=lz.ERF_A2,v6=lz.ERF_A3,v8=lz.ERF_A4,v7=lz.ERF_A5,v9=wf("Erf",e=>{let t=Math.sign(e),n=Math.abs(e),r=1/(1+v3*n);return t*(1-((((v7*r+v8)*r+v6)*r+v5)*r+v4)*r*Math.exp(-n*n))});var ha=ha;function ke(e){let{inputs:t,backend:n,attrs:r}=e,{input:a}=t,{dim:s}=r,i=a.shape.length,o=a.shape.slice(),l=s;return s<0&&(ha.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),vL({inputs:{x:a},backend:n,attrs:{shape:o}})}var ha=ha,lz=lz,ha=ha;let kt=ws(nC,b7((e,t)=>e/t)),kn={kernelName:nC,backendName:"cpu",kernelFunc:kt};function kr(e,t,n){let r=e.shape,a=r[0],s=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[a,s],h=ha.sizeFromShape(u),p=ha.getTypedArrayFromDType("float32",h),d=ha.getTypedArrayFromDType("float32",h);for(let e=0;e<a;e++){let r=vo({inputs:{x:o},backend:n,attrs:{begin:[e,0],size:[1,s]}}),a=vo({inputs:{x:l},backend:n,attrs:{begin:[e,0],size:[1,s]}}),i=b9({inputs:{real:r,imag:a},backend:n}),{real:u,imag:h}=function(e,t,n){var r;let a=ha.sizeFromShape(e.shape),s=n.data.get(e.dataId),i=n.data.get(s.complexTensorInfos.real.dataId).values,o=n.data.get(s.complexTensorInfos.imag.dataId).values;if(((r=a)&r-1)==0){let r=function e(t,n,r,a,s){if(1===r)return{real:t,imag:n};let i=lz.mergeRealAndImagArrays(t,n),o=r/2,l=lz.complexWithEvenIndex(i),u=l.real,h=l.imag,p=[u.length],d=s.makeTensorInfo(p,"float32",u),c=s.makeTensorInfo(p,"float32",h),f=b9({inputs:{real:d,imag:c},backend:s}),m=lz.complexWithOddIndex(i),g=m.real,y=m.imag,x=[g.length],b=s.makeTensorInfo(x,"float32",g),w=s.makeTensorInfo(x,"float32",y),v=b9({inputs:{real:b,imag:w},backend:s}),k=e(u,h,o,a,s),N=k.real,I=k.imag,S=[N.length],C=s.makeTensorInfo(S,"float32",N),T=s.makeTensorInfo(S,"float32",I),$=b9({inputs:{real:C,imag:T},backend:s}),E=e(g,y,o,a,s),A=E.real,R=E.imag,F=[A.length],_=s.makeTensorInfo(F,"float32",A),D=s.makeTensorInfo(F,"float32",R),O=b9({inputs:{real:_,imag:D},backend:s}),M=lz.exponents(r,a),L=[M.real.length],z=s.makeTensorInfo(L,"float32",M.real),P=s.makeTensorInfo(L,"float32",M.imag),B=b9({inputs:{real:z,imag:P},backend:s}),W=wK({inputs:{a:B,b:O},backend:s}),U=wl({inputs:{a:$,b:W},backend:s}),j=vN({inputs:{a:$,b:W},backend:s}),V=wn({inputs:{input:U},backend:s}),G=wn({inputs:{input:j},backend:s}),H=vY({inputs:{input:U},backend:s}),q=vY({inputs:{input:j},backend:s}),K=vZ({inputs:[V,G],backend:s,attrs:{axis:0}}),X=vZ({inputs:[H,q],backend:s,attrs:{axis:0}}),Y=s.data.get(K.dataId).values,Z=s.data.get(X.dataId).values;return s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(c),s.disposeIntermediateTensorInfo(f),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(w),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(C),s.disposeIntermediateTensorInfo(T),s.disposeIntermediateTensorInfo($),s.disposeIntermediateTensorInfo(_),s.disposeIntermediateTensorInfo(D),s.disposeIntermediateTensorInfo(O),s.disposeIntermediateTensorInfo(z),s.disposeIntermediateTensorInfo(P),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(W),s.disposeIntermediateTensorInfo(U),s.disposeIntermediateTensorInfo(j),s.disposeIntermediateTensorInfo(V),s.disposeIntermediateTensorInfo(H),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(K),s.disposeIntermediateTensorInfo(X),{real:Y,imag:Z}}(i,o,a,t,n),s=[e.shape[0],e.shape[1]];if(t){let e=n.makeTensorInfo(s,"float32",r.real),t=n.makeTensorInfo(s,"float32",r.imag),i=n.makeTensorInfo([],"float32",ha.createScalarValue(a,"float32")),o=wt({inputs:{x:i},backend:n}),l=kn.kernelFunc({inputs:{a:e,b:i},backend:n}),u=kn.kernelFunc({inputs:{a:t,b:o},backend:n}),h=n.data.get(l.dataId).values,p=n.data.get(u.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),{real:h,imag:p}}return r}{let e=function(e,t,n){let r=new Float32Array(2*t);for(let a=0;a<t;a++){let s=0,i=0;for(let r=0;r<t;r++){let o=lz.exponent(a*r,t,n),l=lz.getComplexWithIndex(e,r);s+=l.real*o.real-l.imag*o.imag,i+=l.real*o.imag+l.imag*o.real}n&&(s/=t,i/=t),lz.assignToTypedArray(r,s,i,a)}return r}(lz.mergeRealAndImagArrays(i,o),a,t);return lz.splitRealAndImagArrays(e)}}(i,t,n),c=lz.mergeRealAndImagArrays(u,h);for(let t=0;t<s;t++){let n=lz.getComplexWithIndex(c,t);p[e*s+t]=n.real,d[e*s+t]=n.imag}n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i)}let c=n.makeTensorInfo(u,"float32",p),f=n.makeTensorInfo(u,"float32",d),m=b9({inputs:{real:c,imag:f},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(f),m}var ha=ha;function ka(e){var t,n;let{backend:r,attrs:a}=e,{shape:s,value:i,dtype:o}=a,l=o||ha.inferDtype(i),u=ha.getArrayFromDType(l,ha.sizeFromShape(s));return t=u,n=i,t.fill(n),r.makeTensorInfo(s,l,u)}var ha=ha,lz=lz,ha=ha,lz=lz,ha=ha,ha=ha;let ks=wf(nV,e=>+!!Number.isFinite(e),"bool"),ki=wf(nG,e=>+(Math.abs(e)===1/0),"bool"),ko=wf(nH,e=>+!!Number.isNaN(e),"bool"),kl=wf(nZ,e=>Math.log1p(e)),ku=ws(nJ,b7((e,t)=>e&&t),null,"bool"),kh=wf(nQ,e=>+!e,"bool"),kp=ws(n0,b7((e,t)=>e||t),null,"bool");var ha=ha,ha=ha,lz=lz,ha=ha;function kd(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=a.shape,l=o.length,u=ha.parseAxisParam(s,o),h=u,p=lz.getAxesPermutation(h,l),d=n.data.get(a.dataId).values;if(null!=p){let e=Array(l);for(let t=0;t<e.length;t++)e[t]=o[p[t]];d=wJ(d,o,a.dtype,p,e),h=lz.getInnerMostAxes(h.length,l),o=e}b4(a,"max"),lz.assertAxesAreInnerMostDims("max",h,l);let[c,f]=lz.computeOutAndReduceShapes(o,h),m=wU(d,ha.sizeFromShape(f),c,a.dtype),g=n.write(m,c,a.dtype),y=c;return i&&(y=lz.expandShapeToKeepDim(c,u)),{dataId:g,shape:y,dtype:a.dtype}}var lz=lz,ha=ha,lz=lz,ha=ha,lz=lz,lz=lz,lz=lz,ha=ha,lz=lz,ha=ha,lz=lz,ha=ha,ha=ha;let kc=ws("Mod",b7((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}));var ha=ha,lz=lz,ha=ha;function kf(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=a.shape.length,o=s;if(-1===o&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);let l=ha.parseAxisParam([o],a.shape),u=kd({inputs:{x:a},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),h=lz.expandShapeToKeepDim(u.shape,l),p=vL({inputs:{x:u},backend:n,attrs:{shape:h}}),d=vN({inputs:{a:a,b:p},backend:n}),c=wk({inputs:{x:d},backend:n}),f=v2({inputs:{x:c},backend:n,attrs:{axis:l,keepDims:!1}}),m=vL({inputs:{x:f},backend:n,attrs:{shape:h}}),g=kt({inputs:{a:c,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var b3=b3;let km=b3.nonMaxSuppressionV3Impl;var b3=b3;let kg=b3.nonMaxSuppressionV4Impl;var b3=b3;let ky=b3.nonMaxSuppressionV5Impl;var ha=ha;function kx(e){let{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw Error("zerosLike is not supported for string tensors");if("complex64"!==r.dtype)return ka({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}});{let e=wn({inputs:{input:r},backend:n}),t=kx({inputs:{x:e},backend:n}),a=vY({inputs:{input:r},backend:n}),s=kx({inputs:{x:a},backend:n}),i=b9({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}}var ha=ha;function kb(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return ke({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach(e=>{ha.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),ha.assert(i===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=vZ({inputs:t.map(e=>{let t=ke({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t}),backend:n,attrs:{axis:a}});return o.forEach(e=>n.disposeIntermediateTensorInfo(e)),l}var ha=ha;let kw={kernelName:rh,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;b4(a,"pad");let o=s.map((e,t)=>e[0]+a.shape[t]+e[1]),l=s.map(e=>e[0]),u=n.data.get(a.dataId).values,h=ha.sizeFromShape(a.shape),p=a.shape.length,d=ha.computeStrides(a.shape),c=ha.sizeFromShape(o),f=o.length,m=ha.computeStrides(o),g=ha.getTypedArrayFromDType(a.dtype,c);0!==i&&g.fill(i);for(let e=0;e<h;e++){let t=ha.indexToLoc(e,p,d).map((e,t)=>e+l[t]);g[ha.locToIndex(t,f,m)]=u[e]}return{dataId:n.write(g,o,a.dtype),shape:o,dtype:a.dtype}}},kv=ws("Pow",b7((e,t)=>Math.pow(e,t))),kk=wf(rx,e=>1/e);var ha=ha,ha=ha,ha=ha,ha=ha,ha=ha,lz=lz,ha=ha;let kN=wf(rT,e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2==0?t:t+1});var lz=lz,ha=ha,ha=ha,lz=lz;let kI=lz.SELU_SCALEALPHA,kS=lz.SELU_SCALE,kC=wf(r_,e=>e>=0?kS*e:kI*(Math.exp(e)-1)),kT=wf(rM,e=>e<0?-1:+(e>0)),k$=wf("Sin",e=>Math.sin(e)),kE=wf(rO,e=>Math.sinh(e)),kA=Math.log(11920928955078125e-23)+2,kR=wf(rz,e=>{let t=Math.exp(e);return e<kA?t:e>-kA?e:Math.log(1+t)});var lz=lz,ha=ha,lz=lz,ha=ha,lz=lz,ha=ha;let kF=wf(ae,(e,t)=>isNaN(e)?NaN:e>0?1:t.alpha);var vs=oB,ha=ha;let k_=wf("Tan",e=>Math.tan(e)),kD=wf(r1,e=>Math.tanh(e));var lz=lz,ha=ha;function kO(e,t,n){switch(n){case"reflect":var r,a,s,i,o=e,l=t;let u=o;if(u<0)if(l<=1)u=0;else{let e=2*l;u<e&&(u=e*Math.trunc(-u/e)+u),u=u<-l?u+e:-u-1}else if(u>l-1)if(l<=1)u=0;else{let e=2*l;(u-=e*Math.trunc(u/e))>=l&&(u=e-u-1)}return ha.clamp(0,u,l-1);case"wrap":let h;return r=e,a=t,(h=r)<0?a<=1?h=0:h+=a*(Math.trunc(-h/(a-1))+1):h>a-1&&(a<=1?h=0:h-=a*Math.trunc(h/(a-1))),ha.clamp(0,h,a-1);case"nearest":return s=e,i=t,ha.clamp(0,s,i-1);default:return e}}function kM(e,t,n,r,a,s,i,o,l,u,h){return 0<=o&&o<t&&0<=l&&l<n?e[i*r+o*a+l*s+u]:h}var ha=ha;for(let e of[{kernelName:ar,backendName:"cpu",kernelFunc:function(e){let t,n,r,{inputs:a,backend:s,attrs:i}=e,{a:o,b:l,bias:u,preluActivationWeights:h}=a,{transposeA:p,transposeB:d,activation:c,leakyreluAlpha:f}=i,m=[];for(let e of(t=vz({inputs:{a:o,b:l},attrs:{transposeA:p,transposeB:d},backend:s}),u&&(n=wl({inputs:{a:t,b:u},backend:s}),m.push(t),t=n),c&&(r=vO(s,t,c,h,f),m.push(t),t=r),m))s.disposeIntermediateTensorInfo(e);return t}},{kernelName:"Abs",backendName:"cpu",kernelFunc:e=>{let{x:t}=e.inputs,n=e.backend;b4(t,"abs");let r=new Float32Array(ha.sizeFromShape(t.shape));return r=b8(n.data.get(t.dataId).values),n.makeOutput(r,t.shape,t.dtype)}},{kernelName:tG,backendName:"cpu",kernelFunc:vP},{kernelName:tH,backendName:"cpu",kernelFunc:vB},{kernelName:"Add",backendName:"cpu",kernelFunc:wl},{kernelName:tq,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e;b4(t,"addN");let r=t.map(e=>n.data.get(e.dataId).values),a=sW(t[0].shape,t[0].dtype),s=a.values;for(let e=0;e<t.length;e++){let t=r[e];for(let e=0;e<s.length;e++)s[e]+=t[e]}return n.makeTensorInfo(a.shape,a.dtype,a.values)}},{kernelName:"All",backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;b4(a,"all");let o=ha.parseAxisParam(s,a.shape),l=o,u=lz.getAxesPermutation(l,a.shape.length),h=a;null!=u&&(h=wQ({inputs:{x:a},backend:n,attrs:{perm:u}}),l=lz.getInnerMostAxes(l.length,a.shape.length)),lz.assertAxesAreInnerMostDims("all",l,h.shape.length);let[p,d]=lz.computeOutAndReduceShapes(h.shape,l),c=ha.sizeFromShape(d),f=ha.makeZerosTypedArray(ha.sizeFromShape(p),h.dtype),m=n.data.get(h.dataId).values;for(let e=0;e<f.length;++e){let t=e*c,n=m[t];for(let e=0;e<c;++e){let r=m[t+e];n=n&&r}f[e]=n}null!=u&&n.disposeIntermediateTensorInfo(h);let g=n.makeTensorInfo(p,h.dtype,f);if(i){let e=vL({inputs:{x:g},backend:n,attrs:{shape:lz.expandShapeToKeepDim(p,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},{kernelName:"Any",backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;b4(a,"any");let o=ha.parseAxisParam(s,a.shape),l=o,u=lz.getAxesPermutation(l,a.shape.length),h=a;null!=u&&(h=wQ({inputs:{x:a},backend:n,attrs:{perm:u}}),l=lz.getInnerMostAxes(l.length,a.shape.length)),lz.assertAxesAreInnerMostDims("any",l,h.shape.length);let[p,d]=lz.computeOutAndReduceShapes(h.shape,l),c=ha.sizeFromShape(d),f=ha.makeZerosTypedArray(ha.sizeFromShape(p),h.dtype),m=n.data.get(h.dataId).values;for(let e=0;e<f.length;++e){let t=e*c,n=m[t];for(let e=0;e<c;++e){let r=m[t+e];n=n||r}f[e]=n}null!=u&&n.disposeIntermediateTensorInfo(h);let g=n.makeTensorInfo(p,h.dtype,f);if(i){let e=vL({inputs:{x:g},backend:n,attrs:{shape:lz.expandShapeToKeepDim(p,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},{kernelName:tK,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;b4(a,"argMax");let i=ha.parseAxisParam(s,a.shape),o=lz.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(u.push(l=wQ({inputs:{x:a},backend:n,attrs:{perm:o}})),i=lz.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],lz.assertAxesAreInnerMostDims("argMax",i,l.shape.length);let[h,p]=lz.computeOutAndReduceShapes(l.shape,i),d=ha.sizeFromShape(h),c=ha.makeZerosTypedArray(d,"int32"),f=ha.sizeFromShape(p),m=n.data.get(l.dataId).values;for(let e=0;e<c.length;++e){let t=e*f,n=m[t],r=0;for(let e=0;e<f;++e){let a=m[t+e];a>n&&(n=a,r=e)}c[e]=r}return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(h,"int32",c)}},{kernelName:tX,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;b4(a,"argMin");let i=ha.parseAxisParam(s,a.shape),o=lz.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(u.push(l=wQ({inputs:{x:a},backend:n,attrs:{perm:o}})),i=lz.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],lz.assertAxesAreInnerMostDims("argMin",i,l.shape.length);let[h,p]=lz.computeOutAndReduceShapes(l.shape,i),d=ha.sizeFromShape(h),c=ha.makeZerosTypedArray(d,"int32"),f=ha.sizeFromShape(p),m=n.data.get(l.dataId).values;for(let e=0;e<c.length;++e){let t=e*f,n=m[t],r=0;for(let e=0;e<f;++e){let a=m[t+e];a<n&&(n=a,r=e)}c[e]=r}return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(h,"int32",c)}},{kernelName:tY,backendName:"cpu",kernelFunc:vW},{kernelName:tZ,backendName:"cpu",kernelFunc:vU},{kernelName:tJ,backendName:"cpu",kernelFunc:vj},{kernelName:t0,backendName:"cpu",kernelFunc:vV},{kernelName:tQ,backendName:"cpu",kernelFunc:vG},{kernelName:t1,backendName:"cpu",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n;b4(s,"avgPool");let{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=a;ha.assert(lz.eitherStridesOrDilationsAreOne(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);let h=lz.computePool2DInfo(s.shape,i,o,1,l,u);if(1===h.filterWidth&&1===h.filterHeight&&ha.arraysEqual(h.inShape,h.outShape))t=wt({inputs:{x:s},backend:r});else{let e=r.data.get(s.dataId).values,n=ha.computeStrides(s.shape),a=vH(e,s.shape,s.dtype,n,h,"avg");t=r.makeTensorInfo(h.outShape,s.dtype,a.values)}return t}},{kernelName:t3,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;b4(a,"avgPool3d");let h=lz.computePool3DInfo(a.shape,s,i,1,o,l,u),p=vK(n.data.get(a.dataId).values,a.shape,a.dtype,ha.computeStrides(a.shape),h,"avg");return n.makeTensorInfo(p.shape,"float32",p.values)}},{kernelName:t4,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;b4([a,s],"avgPool3DGrad");let h=lz.computePool3DInfo(s.shape,i,o,1,l,u),p=h.strideDepth,d=h.strideHeight,c=h.strideWidth,f=h.filterDepth,m=h.filterHeight,g=h.filterWidth,y=h.dilationDepth,x=h.dilationHeight,b=h.dilationWidth,w=h.effectiveFilterDepth,v=h.effectiveFilterHeight,k=h.effectiveFilterWidth,N=w-1-h.padInfo.front,I=k-1-h.padInfo.left,S=v-1-h.padInfo.top,C=sW(s.shape,"float32"),T=1/(f*m*g),$=n.bufferSync(a);for(let e=0;e<h.batchSize;++e)for(let t=0;t<h.inChannels;++t)for(let n=0;n<h.inDepth;++n)for(let r=0;r<h.inHeight;++r)for(let a=0;a<h.inWidth;++a){let s=n-N,i=r-S,o=a-I,l=0;for(let n=0;n<w;n+=y){let r=(s+n)/p;if(!(r<0)&&!(r>=h.outDepth)&&Math.floor(r)===r)for(let n=0;n<v;n+=x){let a=(i+n)/d;if(!(a<0)&&!(a>=h.outHeight)&&Math.floor(a)===a)for(let n=0;n<k;n+=b){let s=(o+n)/c;s<0||s>=h.outWidth||Math.floor(s)!==s||(l+=$.get(e,r,a,s,t))}}}C.set(l*T,e,n,r,a,t)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}},{kernelName:t2,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t;b4([a,s],"avgPoolGrad");let{filterSize:i,strides:o,pad:l}=r,u=lz.computePool2DInfo(s.shape,i,o,1,l),h=u.strideHeight,p=u.strideWidth,d=u.filterHeight,c=u.filterWidth,f=u.dilationHeight,m=u.dilationWidth,g=u.effectiveFilterHeight,y=u.effectiveFilterWidth,x=y-1-u.padInfo.left,b=g-1-u.padInfo.top,w=sW(s.shape,"float32"),v=1/(d*c),k=n.data.get(a.dataId).values,N=sW(a.shape,"float32",k);for(let e=0;e<u.batchSize;++e)for(let t=0;t<u.inChannels;++t)for(let n=0;n<u.inHeight;++n)for(let r=0;r<u.inWidth;++r){let a=n-b,s=r-x,i=0;for(let n=0;n<g;n+=f){let r=(a+n)/h;if(!(r<0)&&!(r>=u.outHeight)&&Math.floor(r)===r)for(let n=0;n<y;n+=m){let a=(s+n)/p;a<0||a>=u.outWidth||Math.floor(a)!==a||(i+=N.get(e,r,a,t))}}w.set(i*v,e,n,r,t)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}},{kernelName:t5,backendName:"cpu",kernelFunc:vz},{kernelName:nM,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,scale:s,offset:i,mean:o,variance:l}=t;ha.assert(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),ha.assert(null==i||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),ha.assert(null==s||o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),b4([a,o,l,s,i],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);let h=n.data.get(a.dataId).values,p=n.data.get(o.dataId).values,d=n.data.get(l.dataId).values,c=s?n.data.get(s.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(h.length),g=f.length,y=c.length,x=d.length,b=p.length,w=0,v=0,k=0,N=0;for(let e=0;e<h.length;++e)m[e]=f[w++]+(h[e]-p[v++])*c[k++]/Math.sqrt(d[N++]+u),w>=g&&(w=0),v>=b&&(v=0),k>=y&&(k=0),N>=x&&(N=0);return n.makeTensorInfo(a.shape,a.dtype,m)}},{kernelName:t6,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;b4([a],"batchToSpaceND");let o=s.reduce((e,t)=>e*t),l=lz.getReshaped(a.shape,s,o),u=lz.getPermuted(l.length,s.length),h=lz.getReshapedPermuted(a.shape,s,o),p=lz.getSliceBeginCoords(i,s.length),d=lz.getSliceSize(h,i,s.length),c=vL({inputs:{x:a},backend:n,attrs:{shape:l}}),f=wQ({inputs:{x:c},backend:n,attrs:{perm:u}}),m=vL({inputs:{x:f},backend:n,attrs:{shape:h}}),g=vo({inputs:{x:m},backend:n,attrs:{begin:p,size:d}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}},{kernelName:t8,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=wu(n.data.get(a.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,o)}},{kernelName:t7,backendName:"cpu",kernelFunc:wd},{kernelName:t9,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=lz.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},{kernelName:ne,backendName:"cpu",kernelFunc:wa},{kernelName:nt,backendName:"cpu",kernelFunc:wy},{kernelName:nn,backendName:"cpu",kernelFunc:vX},{kernelName:nr,backendName:"cpu",kernelFunc:b9},{kernelName:na,backendName:"cpu",kernelFunc:e=>{let{x:t}=e.inputs,n=e.backend,r=new Float32Array(ha.sizeFromShape(t.shape)),a=n.data.get(t.dataId),s=a.complexTensorInfos.real,i=a.complexTensorInfos.imag,o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values;for(let e=0;e<o.length;e++){let t=o[e],n=l[e];r[e]=Math.hypot(t,n)}return n.makeOutput(r,t.shape,"float32")}},{kernelName:ns,backendName:"cpu",kernelFunc:vZ},{kernelName:ni,backendName:"cpu",kernelFunc:vJ},{kernelName:no,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:h}=r;b4([a,s],"conv2dBackpropFilter");let p=lz.convertConv2DDataFormat(l),d=lz.computeConv2DInfo(a.shape,h,i,1,o,u,!1,p),{strideHeight:c,strideWidth:f,filterHeight:m,filterWidth:g}=d,y="channelsLast"===d.dataFormat,x=new aT(d.filterShape,"float32"),b=d.padInfo.left,w=d.padInfo.top,v=n.data.get(a.dataId).values,k=n.data.get(s.dataId).values,N=new aT(a.shape,a.dtype,v),I=new aT(s.shape,s.dtype,k);for(let e=0;e<m;++e){let t=Math.max(0,Math.ceil((w-e)/c)),n=Math.min(d.outHeight,(d.inHeight+w-e)/c);for(let r=0;r<g;++r){let a=Math.max(0,Math.ceil((b-r)/f)),s=Math.min(d.outWidth,(d.inWidth+b-r)/f);for(let i=0;i<d.inChannels;++i)for(let o=0;o<d.outChannels;++o){let l=0;for(let u=0;u<d.batchSize;++u)for(let h=t;h<n;++h){let t=e+h*c-w;for(let e=a;e<s;++e){let n=r+e*f-b;y?l+=N.get(u,t,n,i)*I.get(u,h,e,o):l+=N.get(u,i,t,n)*I.get(u,o,h,e)}}x.set(l,e,r,i,o)}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}},{kernelName:nl,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:h}=r;b4([a,s],"conv2dBackpropInput");let p=ha.computeStrides(s.shape),d=ha.computeStrides(a.shape),c=lz.convertConv2DDataFormat(u),f=lz.computeConv2DInfo(i,s.shape,o,1,l,h,!1,c),m=new aT(f.inShape,"float32"),g=m.values,y=n.data.get(a.dataId).values,x=n.data.get(s.dataId).values,[b,w,v]=p,{batchSize:k,filterHeight:N,filterWidth:I,inChannels:S,inHeight:C,inWidth:T,outChannels:$,outHeight:E,outWidth:A,strideHeight:R,strideWidth:F}=f;c=f.dataFormat;let _=N-1-f.padInfo.top,D=I-1-f.padInfo.left,O="channelsLast"===c,M=m.strides[0],L=O?m.strides[1]:m.strides[2],z=O?m.strides[2]:1,P=O?1:m.strides[1],B=d[0],W=O?d[1]:d[2],U=O?d[2]:1,j=O?1:d[1];for(let e=0;e<k;++e)for(let t=0;t<S;++t)for(let n=0;n<C;++n){let r=n-_,a=Math.max(0,Math.ceil(r/R)),s=Math.min(E,(N+r)/R);for(let i=0;i<T;++i){let o=i-D,l=Math.max(0,Math.ceil(o/F)),u=Math.min(A,(I+o)/F),h=0;for(let n=a;n<s;++n){let a=n*R-r;for(let r=l;r<u;++r){let s=r*F-o,i=B*e+W*n+U*r,l=b*(N-1-a)+w*(I-1-s)+v*t;for(let e=0;e<$;++e)h+=y[i+j*e]*x[l+e]}}g[M*e+L*n+z*i+P*t]=h}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}},{kernelName:nu,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;b4([a,s],"conv3d");let u=lz.computeConv3DInfo(a.shape,s.shape,i,l,o),{filterDepth:h,filterHeight:p,filterWidth:d,dilationDepth:c,dilationHeight:f,dilationWidth:m,padInfo:g}=u,y=g.front,x=g.left,b=g.top,w=new aT(u.outShape,a.dtype),v=n.data.get(a.dataId).values,k=n.data.get(s.dataId).values,N=w.values,I=ha.computeStrides(a.shape),S=ha.computeStrides(s.shape);for(let e=0;e<u.batchSize;++e){let t=e*I[0],n=e*w.strides[0];for(let e=0;e<u.outDepth;++e){let r=n+e*w.strides[1],a=e*u.strideDepth-y;for(let e=0;e<h;++e){let n=a+e*c;if(n<0||n>=u.inDepth)continue;let s=e*S[0],i=t+n*I[1];for(let e=0;e<u.outHeight;++e){let t=r+e*w.strides[2],n=e*u.strideHeight-b;for(let e=0;e<p;++e){let r=n+e*f;if(r<0||r>=u.inHeight)continue;let a=s+e*S[1],o=i+r*I[2];for(let e=0;e<u.outWidth;++e){let n=t+e*u.outChannels,r=e*u.strideWidth-x;for(let e=0;e<d;++e){let t=r+e*m;if(t<0||t>=u.inWidth)continue;let s=a+e*S[2],i=o+t*u.inChannels,l=s;for(let e=0;e<u.inChannels;++e){let t=v[i+e];for(let e=0;e<u.outChannels;++e)N[n+e]+=t*k[l+e];l+=u.outChannels}}}}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}},{kernelName:nh,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r;b4([a,s],"conv3dBackpropFilterV2");let u=ha.computeStrides(a.shape),h=ha.computeStrides(s.shape),p=lz.computeConv3DInfo(a.shape,l,i,1,o),d=p.strideDepth,c=p.strideHeight,f=p.strideWidth,m=p.filterDepth,g=p.filterHeight,y=p.filterWidth,x=new aT(p.filterShape,"float32"),b=x.values,[w,v,k,N]=x.strides,I=n.data.get(s.dataId).values,[S,C,T,$]=h,E=n.data.get(a.dataId).values,[A,R,F,_]=u,D=p.padInfo.front,O=p.padInfo.left,M=p.padInfo.top;for(let e=0;e<m;++e){let t=Math.max(0,Math.ceil((D-e)/d)),n=Math.min(p.outDepth,(p.inDepth+D-e)/d),r=e*w;for(let a=0;a<g;++a){let s=Math.max(0,Math.ceil((M-a)/c)),i=Math.min(p.outHeight,(p.inHeight+M-a)/c),o=a*v+r;for(let r=0;r<y;++r){let l=Math.max(0,Math.ceil((O-r)/f)),u=Math.min(p.outWidth,(p.inWidth+O-r)/f),h=r*k+o;for(let o=0;o<p.inChannels;++o){let m=o*N+h;for(let h=0;h<p.outChannels;++h){let g=0;for(let m=0;m<p.batchSize;++m){let p=m*A,y=m*S;for(let m=t;m<n;++m){let t=(e+m*d-D)*R+p,n=m*C+y;for(let e=s;e<i;++e){let s=(a+e*c-M)*F+t,i=e*T+n;for(let e=l;e<u;++e){let t=(r+e*f-O)*_+s,n=e*$+i;g+=E[t+o]*I[n+h]}}}}b[m+h]=g}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}},{kernelName:np,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r;b4([a],"conv3dBackpropInputV2");let u=ha.computeStrides(a.shape),h=ha.computeStrides(s.shape),p=lz.computeConv3DInfo(l,s.shape,o,1,i),d=new aT(p.inShape,"float32"),c=d.values,[f,m,g,y]=d.strides,x=n.data.get(a.dataId).values,[b,w,v,k]=u,N=n.data.get(s.dataId).values,[I,S,C,T]=h,{batchSize:$,filterDepth:E,filterHeight:A,filterWidth:R,inChannels:F,inDepth:_,inHeight:D,inWidth:O,outChannels:M,outDepth:L,outHeight:z,outWidth:P,strideDepth:B,strideHeight:W,strideWidth:U}=p,j=E-1-p.padInfo.front,V=A-1-p.padInfo.top,G=R-1-p.padInfo.left;for(let e=0;e<$;++e)for(let t=0;t<F;++t)for(let n=0;n<_;++n){let r=n-j,a=Math.max(0,Math.ceil(r/B)),s=Math.min(L,(E+r)/B);for(let i=0;i<D;++i){let o=i-V,l=Math.max(0,Math.ceil(o/W)),u=Math.min(z,(A+o)/W);for(let h=0;h<O;++h){let p=h-G,d=Math.max(0,Math.ceil(p/U)),$=Math.min(P,(R+p)/U),F=0;for(let n=a;n<s;++n){let a=n*B-r;for(let r=l;r<u;++r){let s=r*W-o;for(let i=d;i<$;++i){let o=i*U-p,l=b*e+w*n+v*r+k*i,u=I*(E-1-a)+S*(A-1-s)+C*(R-1-o)+T*t;for(let e=0;e<M;++e)F+=x[l+e]*N[u+e]}}}c[f*e+m*n+g*i+y*h+t]=F}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}},{kernelName:"Cos",backendName:"cpu",kernelFunc:vQ},{kernelName:nd,backendName:"cpu",kernelFunc:v0},{kernelName:nm,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,[h,p,d,c]=a.shape,f=s.shape[0],[m,g]=o,y=sW([f,m,g,c],"float32"),x=n.data.get(s.dataId).values,b=n.data.get(i.dataId).values,w=n.data.get(a.dataId).values,v=ha.computeStrides(a.shape),k=ha.computeStrides(y.shape);for(let e=0;e<f;e++){let t=4*e,n=x[t],r=x[t+1],a=x[t+2],s=x[t+3],i=b[e];if(i>=h)continue;let o=m>1?(a-n)*(p-1)/(m-1):0,f=g>1?(s-r)*(d-1)/(g-1):0;for(let t=0;t<m;t++){let h=m>1?n*(p-1)+t*o:.5*(n+a)*(p-1);if(h<0||h>p-1){for(let n=0;n<g;n++)for(let r=0;r<c;r++){let a=r+n*k[2]+t*k[1]+e*k[0];y.values[a]=u}continue}if("bilinear"===l){let n=Math.floor(h),a=Math.ceil(h),o=h-n;for(let l=0;l<g;l++){let h=g>1?r*(d-1)+l*f:.5*(r+s)*(d-1);if(h<0||h>d-1){for(let n=0;n<c;n++){let r=n+l*k[2]+t*k[1]+e*k[0];y.values[r]=u}continue}let p=Math.floor(h),m=Math.ceil(h),x=h-p;for(let r=0;r<c;r++){let s=r+p*v[2]+n*v[1]+i*v[0],u=w[s],h=w[s=r+m*v[2]+n*v[1]+i*v[0]],d=w[s=r+p*v[2]+a*v[1]+i*v[0]],c=w[s=r+m*v[2]+a*v[1]+i*v[0]],f=u+(h-u)*x,g=d+(c-d)*x;s=r+l*k[2]+t*k[1]+e*k[0],y.values[s]=f+(g-f)*o}}}else for(let n=0;n<g;++n){let a=g>1?r*(d-1)+n*f:.5*(r+s)*(d-1);if(a<0||a>d-1){for(let r=0;r<c;r++){let a=r+n*k[2]+t*k[1]+e*k[0];y.values[a]=u}continue}let o=Math.round(a),l=Math.round(h);for(let r=0;r<c;r++){let a=r+o*v[2]+l*v[1]+i*v[0],s=r+n*k[2]+t*k[1]+e*k[0];y.values[s]=w[a]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},{kernelName:nc,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;b4(a,"cumprod");let l=lz.getAxesPermutation([s],a.shape.length),u=a;null!=l&&(u=wQ({inputs:{x:a},backend:n,attrs:{perm:l}}));let h=lz.getInnerMostAxes(1,a.shape.length)[0];if(h!==u.shape.length-1)throw Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${h}`);let p=aD(u.dtype,"int32"),d=ha.makeOnesTypedArray(ha.sizeFromShape(u.shape),p),c=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let e=0;e<c.length;e+=f)for(let t=0;t<f;t++){let n=m(e,t);if(0===t)d[n]=i?1:c[n];else{let r=m(e,t-1);d[n]=i?c[r]*d[r]:c[n]*d[r]}}let g=n.makeTensorInfo(u.shape,p,d);if(null!=l){let e=wQ({inputs:{x:g},backend:n,attrs:{perm:lz.getUndoAxesPermutation(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}},{kernelName:nf,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;b4(a,"cumsum");let l=lz.getAxesPermutation([s],a.shape.length),u=a;null!=l&&(u=wQ({inputs:{x:a},backend:n,attrs:{perm:l}}));let h=lz.getInnerMostAxes(1,a.shape.length)[0];if(h!==u.shape.length-1)throw Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${h}`);let p=aD(u.dtype,"int32"),d=ha.makeZerosTypedArray(ha.sizeFromShape(u.shape),p),c=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let e=0;e<c.length;e+=f)for(let t=0;t<f;t++){let n=m(e,t);if(0===t)d[n]=i?0:c[n];else{let r=m(e,t-1);d[n]=i?c[r]+d[r]:c[n]+d[r]}}let g=n.makeTensorInfo(u.shape,p,d);if(null!=l){let e=wQ({inputs:{x:g},backend:n,attrs:{perm:lz.getUndoAxesPermutation(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}},{kernelName:ng,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(1===a.shape.length){let e=wu(n.data.get(a.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,e)}if(2===a.shape.length){let e=wh(n.bufferSync(a),n.bufferSync(s),i,o);return n.makeTensorInfo(e.shape,s.dtype,e.values)}throw Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}},{kernelName:ny,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r;ha.assert("NHWC"===i,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let o=a.shape[0],l=a.shape[1],u=a.shape[2],h=a.shape[3],p=l*s,d=u*s,c=h/(s*s),f=n.data.get(a.dataId).values,m=new Float32Array(o*p*d*c),g=0;for(let e=0;e<o;++e)for(let t=0;t<p;++t){let n=Math.floor(t/s),r=t%s;for(let t=0;t<d;++t){let a=Math.floor(t/s),i=t%s,o=(r*s+i)*c;for(let t=0;t<c;++t){let r=t+o+h*(a+u*(n+l*e));m[g++]=f[r]}}}return n.makeTensorInfo([o,p,d,c],a.dtype,m)}},{kernelName:nx,backendName:"cpu",kernelFunc:v1},{kernelName:nb,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:h}=r;b4([a,s],"depthwiseConv2dNativeBackpropFilter");let p=lz.computeConv2DInfo(a.shape,h,i,o,l,u,!0),{strideHeight:d,strideWidth:c,filterHeight:f,filterWidth:m}=p,g=new aT(p.filterShape,"float32"),y=p.padInfo.left,x=p.padInfo.top,b=p.outChannels/p.inChannels,w=n.data.get(a.dataId).values,v=new aT(a.shape,a.dtype,w),k=n.data.get(s.dataId).values,N=new aT(s.shape,s.dtype,k);for(let e=0;e<f;++e){let t=Math.max(0,Math.ceil((x-e)/d)),n=Math.min(p.outHeight,(p.inHeight+x-e)/d);for(let r=0;r<m;++r){let a=Math.max(0,Math.ceil((y-r)/c)),s=Math.min(p.outWidth,(p.inWidth+y-r)/c);for(let i=0;i<p.outChannels;++i){let o=Math.trunc(i/b),l=i%b,u=0;for(let l=0;l<p.batchSize;++l)for(let h=t;h<n;++h){let t=e+h*d-x;for(let e=a;e<s;++e){let n=r+e*c-y;u+=v.get(l,t,n,o)*N.get(l,h,e,i)}}g.set(u,e,r,o,l)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}},{kernelName:nw,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:h}=r;b4([a,s],"depthwiseConv2DNativeBackpropInput");let p=ha.computeStrides(a.shape),d=ha.computeStrides(s.shape),c=lz.computeConv2DInfo(h,s.shape,i,o,l,u,!0),f=new aT(c.inShape,"float32"),m=f.values,[g,y,x]=f.strides,b=n.data.get(a.dataId).values,[w,v,k]=p,N=n.data.get(s.dataId).values,[I,S,C]=d,{batchSize:T,filterHeight:$,filterWidth:E,inChannels:A,inHeight:R,inWidth:F,outChannels:_,outHeight:D,outWidth:O,strideHeight:M,strideWidth:L}=c,z=$-1-c.padInfo.top,P=E-1-c.padInfo.left,B=_/A;for(let e=0;e<T;++e)for(let t=0;t<A;++t)for(let n=0;n<R;++n){let r=n-z,a=Math.max(0,Math.ceil(r/M)),s=Math.min(D,($+r)/M);for(let i=0;i<F;++i){let o=i-P,l=Math.max(0,Math.ceil(o/L)),u=Math.min(O,(E+o)/L),h=0;for(let n=a;n<s;++n){let a=n*M-r;for(let r=l;r<u;++r){let s=r*L-o,i=w*e+v*n+k*r,l=I*($-1-a)+S*(E-1-s)+C*t;for(let e=0;e<B;++e)h+=b[i+(t*B+e)]*N[l+e]}}m[g*e+y*n+x*i+t]=h}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}},{kernelName:nv,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t,a=ha.sizeFromShape(r.shape),s=n.data.get(r.dataId).values,i=sW([a,a],r.dtype),o=i.values;for(let e=0;e<s.length;e++)o[e*a+e]=s[e];let l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}},{kernelName:nk,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a}=e,{strides:s,pad:i,dilations:o}=n,l=t.data.get(r.dataId).values,u=r.shape.length,h=t.data.get(a.dataId).values,p=a.shape.length,{batchSize:d,inHeight:c,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:x,strideHeight:b,strideWidth:w,filterHeight:v,filterWidth:k,dilationHeight:N,dilationWidth:I,outShape:S}=lz.computeDilation2DInfo(r.shape,a.shape,s,i,"NHWC",o),C=ha.sizeFromShape(S),T=S.length,$=ha.getArrayFromDType(r.dtype,C);for(let e=0;e<d;++e)for(let t=0;t<g;++t){let n=t*b-x.top;for(let s=0;s<y;++s){let i=s*w-x.left;for(let o=0;o<m;++o){let d=Number.MIN_SAFE_INTEGER;for(let t=0;t<v;++t){let s=n+t*N;if(s>=0&&s<c)for(let n=0;n<k;++n){let c=i+n*I;if(c>=0&&c<f){let i=ha.locToIndex([e,s,c,o],u,ha.computeStrides(r.shape)),f=ha.locToIndex([t,n,o],p,ha.computeStrides(a.shape)),m=l[i]+h[f];m>d&&(d=m)}}}$[ha.locToIndex([e,t,s,o],T,ha.computeStrides(S))]=d}}}return{dataId:t.write(ha.toTypedArray($,r.dtype),S,r.dtype),shape:S,dtype:r.dtype}}},{kernelName:nI,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a,dy:s}=e,{strides:i,pad:o,dilations:l}=n,u=ha.toNestedArray(r.shape,t.data.get(r.dataId).values),h=ha.toNestedArray(a.shape,t.data.get(a.dataId).values),{batchSize:p,inHeight:d,inWidth:c,inChannels:f,outHeight:m,outWidth:g,padInfo:y,strideHeight:x,strideWidth:b,filterHeight:w,filterWidth:v,dilationHeight:k,dilationWidth:N,outShape:I}=lz.computeDilation2DInfo(r.shape,a.shape,i,o,"NHWC",l);ha.assert(s.rank===I.length,()=>`Error in ${nI}, dy must have the same rank as output ${I.length}, but got ${s.rank}`);let S=ha.toNestedArray(I,t.data.get(s.dataId).values),C=ha.makeZerosNestedTypedArray(a.shape,a.dtype);for(let e=0;e<p;++e)for(let t=0;t<m;++t){let n=t*x-y.top;for(let r=0;r<g;++r){let a=r*b-y.left;for(let s=0;s<f;++s){let i=Number.MIN_SAFE_INTEGER,o=0,l=0;for(let t=0;t<w;++t){let r=n+t*k;if(r>=0&&r<d)for(let n=0;n<v;++n){let p=a+n*N;if(p>=0&&p<c){let a=u[e][r][p][s]+h[t][n][s];a>i&&(i=a,o=t,l=n)}}}C[o][l][s]+=S[e][t][r][s]}}}return{dataId:t.write(ha.toTypedArray(C,r.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},{kernelName:nN,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a,dy:s}=e,{strides:i,pad:o,dilations:l}=n,u=ha.toNestedArray(r.shape,t.data.get(r.dataId).values),h=ha.toNestedArray(a.shape,t.data.get(a.dataId).values),{batchSize:p,inHeight:d,inWidth:c,inChannels:f,outHeight:m,outWidth:g,padInfo:y,strideHeight:x,strideWidth:b,filterHeight:w,filterWidth:v,dilationHeight:k,dilationWidth:N,outShape:I}=lz.computeDilation2DInfo(r.shape,a.shape,i,o,"NHWC",l);ha.assert(s.rank===I.length,()=>`Error in ${nN}, dy must have the same rank as output ${I.length}, but got ${s.rank}`);let S=ha.toNestedArray(I,t.data.get(s.dataId).values),C=ha.makeZerosNestedTypedArray(r.shape,r.dtype);for(let e=0;e<p;++e)for(let t=0;t<m;++t){let n=t*x-y.top;for(let r=0;r<g;++r){let a=r*b-y.left;for(let s=0;s<f;++s){let i=Number.MIN_SAFE_INTEGER,o=n<0?0:n,l=a<0?0:a;for(let t=0;t<w;++t){let r=n+t*k;if(r>=0&&r<d)for(let n=0;n<v;++n){let p=a+n*N;if(p>=0&&p<c){let a=u[e][r][p][s]+h[t][n][s];a>i&&(i=a,o=r,l=p)}}}C[e][o][l][s]+=S[e][t][r][s]}}}return{dataId:t.write(ha.toTypedArray(C,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},{kernelName:nS,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{canvas:s,options:i}=r,{contextOptions:o,imageOptions:l}=i||{},u=(null==l?void 0:l.alpha)||1,h=(null==o?void 0:o.contextType)||"2d";if("2d"!==h)throw Error(`Context type ${o.contextType} is not supported by the CPU backend.`);let p=s.getContext(h,(null==o?void 0:o.contextAttributes)||{});if(null==p)throw Error(`Could not get the context with ${h} type.`);let[d,c]=a.shape.slice(0,2),f=2===a.shape.length?1:a.shape[2],m=n.data.get(a.dataId).values,g="float32"===a.dtype?255:1,y=new Uint8ClampedArray(c*d*4);for(let e=0;e<d*c;++e){let t=[0,0,0,255*u];for(let n=0;n<f;n++){let r=m[e*f+n];if("float32"===a.dtype){if(r<0||r>1)throw Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${r}.`)}else if("int32"===a.dtype&&(r<0||r>255))throw Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${r}.`);1===f?(t[0]=r*g,t[1]=r*g,t[2]=r*g):t[n]=r*g}let n=4*e;y[n+0]=Math.round(t[0]),y[n+1]=Math.round(t[1]),y[n+2]=Math.round(t[2]),y[n+3]=Math.round(t[3])}s.width=c,s.height=d;let x=new ImageData(y,c,d);return p.putImageData(x,0,0),a}},{kernelName:nT,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,{allDims:s,summedDims:i,idDims:o}=lz.decodeEinsumEquation(a,t.length);lz.checkEinsumDimSizes(s.length,o,t);let{path:l,steps:u}=lz.getEinsumComputePath(i,o),h=u.length,p=null,d=s.length,c=[];for(let e=0;e<h;++e){for(let r of u[e]){let e,{permutationIndices:a,expandDims:s}=lz.getEinsumPermutation(d,o[r]);lz.isIdentityPermutation(a)?e=t[r]:(e=wQ({inputs:{x:t[r]},backend:n,attrs:{perm:a}}),c.push(e));let i=e.shape.slice();for(let e=0;e<s.length;++e)i.splice(s[e],0,1);ha.arraysEqual(e.shape,i)||(e=vL({inputs:{x:e},backend:n,attrs:{shape:i}}),c.push(e)),null===p?p=e:(p=wK({inputs:{a:e,b:p},backend:n}),c.push(p))}e<h-1&&(l[e]>=0&&(p=v2({inputs:{x:p},backend:n,attrs:{axis:l[e]-(s.length-d),keepDims:!1}}),c.push(p)),d--)}for(let e of c)e!==p&&n.disposeIntermediateTensorInfo(e);return p}},{kernelName:"Elu",backendName:"cpu",kernelFunc:vE},{kernelName:n$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{dy:r,y:a}=t;b4([r,a],"eluGrad");let s=new Float32Array(ha.sizeFromShape(a.shape)),i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values;for(let e=0;e<i.length;++e){let t=i[e];t>=0?s[e]=o[e]:s[e]=o[e]*(t+1)}return n.makeTensorInfo(a.shape,"float32",s)}},{kernelName:nE,backendName:"cpu",kernelFunc:ww},{kernelName:"Erf",backendName:"cpu",kernelFunc:v9},{kernelName:"Exp",backendName:"cpu",kernelFunc:wk},{kernelName:nA,backendName:"cpu",kernelFunc:ke},{kernelName:nR,backendName:"cpu",kernelFunc:wI},{kernelName:"FFT",backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:r}=t,a=ha.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=vL({inputs:{x:r},backend:n,attrs:{shape:[a/s,s]}}),o=kr(i,!1,n),l=vL({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}},{kernelName:nF,backendName:"cpu",kernelFunc:ka},{kernelName:n_,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,a=ha.getTypedArrayFromDType(r.dtype,ha.sizeFromShape(r.shape)),[s,i,o,l]=r.shape,u=n.data.get(r.dataId).values;for(let e=0;e<s;e++){let t=e*o*i*l;for(let e=0;e<i;e++){let n=o*l*e;for(let e=0;e<o;e++){let r=e*l;for(let s=0;s<l;s++){let i=Math.round(o-e-1),h=t+n+r+s,p=u[h];i>=0&&i<o&&(p=u[t+n+i*l+s]),a[h]=p}}}}return{dataId:n.write(a,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},{kernelName:nD,backendName:"cpu",kernelFunc:wC},{kernelName:nO,backendName:"cpu",kernelFunc:w$},{kernelName:aa,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:h,dilations:p,dimRoundingMode:d,activation:c,leakyreluAlpha:f}=r,m=vJ({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:h,dilations:p,dimRoundingMode:d}});if(i){let e=m;if("NCHW"===h&&1===i.shape.length&&1!==i.shape[0]){let e=vL({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=wl({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=wl({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(e)}if(c){let e=m;if("NCHW"===h&&"prelu"===c&&1===o.shape.length&&1!==o.shape[0]){let e=vL({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=vO(n,m,c,e,f),n.disposeIntermediateTensorInfo(e)}else m=vO(n,m,c,o,f);n.disposeIntermediateTensorInfo(e)}return m}},{kernelName:as,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:h,dilations:p,dimRoundingMode:d,activation:c,leakyreluAlpha:f}=r,m=v1({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:h,dilations:p,dimRoundingMode:d}});if(i){let e=m;m=wl({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(c){let e=m;m=vO(n,m,c,o,f),n.disposeIntermediateTensorInfo(e)}return m}},{kernelName:nz,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=ha.sizeFromShape(r.shape),i=a.shape,o=i[i.length-1],[l,u,h,p]=lz.prepareAndValidate(r,a);if(0===u)return n.makeTensorInfo(l,r.dtype,[]);let d=wE(n.data.get(a.dataId).values,n.bufferSync(r),r.dtype,u,o,h,p,r.shape,s);return n.makeTensorInfo(l,r.dtype,d.values)}},{kernelName:nL,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r;b4([a,s],"gatherV2");let l=ha.parseAxisParam(i,a.shape)[0],u=n.data.get(s.dataId).values,h=a.shape[l];for(let e=0;e<u.length;++e){let t=u[e];ha.assert(t<=h-1&&t>=0,()=>`GatherV2: the index value ${t} is not in [0, ${h-1}]`)}let p=o;null==o&&(p=0);let d=ha.sizeFromShape(s.shape),c=lz.segment_util.collectGatherOpShapeInfo(a,s,l,p),f=vL({inputs:{x:a},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),m=vL({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,d/c.batchSize]}}),g=[c.batchSize,c.outerSize,d/c.batchSize,c.sliceSize],y=n.bufferSync(m),x=wA(n.bufferSync(f),y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(c.outputShape,x.dtype,x.values)}},{kernelName:nP,backendName:"cpu",kernelFunc:wF},{kernelName:nB,backendName:"cpu",kernelFunc:wD},{kernelName:nW,backendName:"cpu",kernelFunc:wt},{kernelName:nU,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:r}=t,a=ha.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=vL({inputs:{x:r},backend:n,attrs:{shape:[a/s,s]}}),o=kr(i,!0,n),l=vL({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}},{kernelName:nj,backendName:"cpu",kernelFunc:vY},{kernelName:nV,backendName:"cpu",kernelFunc:ks},{kernelName:nG,backendName:"cpu",kernelFunc:ki},{kernelName:nH,backendName:"cpu",kernelFunc:ko},{kernelName:nq,backendName:"cpu",kernelFunc:vA},{kernelName:nK,backendName:"cpu",kernelFunc:wM},{kernelName:nX,backendName:"cpu",kernelFunc:wz},{kernelName:nY,backendName:"cpu",kernelFunc:function(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=wP(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}},{kernelName:"Log",backendName:"cpu",kernelFunc:wW},{kernelName:nZ,backendName:"cpu",kernelFunc:kl},{kernelName:nJ,backendName:"cpu",kernelFunc:ku},{kernelName:nQ,backendName:"cpu",kernelFunc:kh},{kernelName:n0,backendName:"cpu",kernelFunc:kp},{kernelName:"LRN",backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r;b4(a,"LRN");let u=a.shape[3],h=u-1,p=n.data.get(a.dataId).values,d=ha.sizeFromShape(a.shape),c=new Float32Array(d);for(let e=0;e<d;e++){let t=function(e){let t=e%u,n=e-t+Math.max(0,t-s),r=e-t+Math.min(t+s,h),a=0;for(;n<=r;n++){let e=p[n];a+=e*e}return a}(e),n=p[e]*Math.pow(i+o*t,-l);c[e]=n}return n.makeTensorInfo(a.shape,a.dtype,c)}},{kernelName:n1,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:h}=r;b4(i,"LRNGrad");let p=ha.sizeFromShape(i.shape),d=i.shape[3],c=n.data.get(i.dataId).values,f=n.data.get(a.dataId).values,m=n.data.get(s.dataId).values,g=new Float32Array(p);for(let e=0;e<p;e++){let t=e%d,n=e-t+Math.max(0,t-o),r=e-t+Math.min(d,t+o+1),a=0;for(let e=n;e<r;e++)a+=Math.pow(f[e],2);a=u*a+l;for(let t=n;t<r;t++){let n=-2*u*h*f[t]*m[e]/a;e===t&&(n+=Math.pow(a,-h)),n*=c[e],g[t]+=n}}return n.makeTensorInfo(i.shape,a.dtype,g)}},{kernelName:"Max",backendName:"cpu",kernelFunc:kd},{kernelName:n2,backendName:"cpu",kernelFunc:wV},{kernelName:n3,backendName:"cpu",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n;b4(s,"maxPool");let{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=a;ha.assert(lz.eitherStridesOrDilationsAreOne(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);let h=lz.computePool2DInfo(s.shape,i,o,1,l,u);if(1===h.filterWidth&&1===h.filterHeight&&ha.arraysEqual(h.inShape,h.outShape))t=wt({inputs:{x:s},backend:r});else{let e=r.data.get(s.dataId).values,n=ha.computeStrides(s.shape),a=vH(e,s.shape,s.dtype,n,h,"max");t=r.makeTensorInfo(h.outShape,s.dtype,a.values)}return t}},{kernelName:n5,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;b4(a,"maxPool3d");let h=lz.computePool3DInfo(a.shape,s,i,1,o,l,u),p=vK(n.data.get(a.dataId).values,a.shape,a.dtype,ha.computeStrides(a.shape),h,"max");return n.makeTensorInfo(p.shape,"float32",p.values)}},{kernelName:n6,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;b4([a,s],"maxPool3DGrad");let h=lz.computePool3DInfo(s.shape,i,o,1,l,u),p=function(e,t){let n=sW(t.outShape,"int32"),r=t.strideDepth,a=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,h=t.effectiveFilterHeight,p=t.effectiveFilterWidth,d=t.padInfo.front,c=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){let x=y*r-d,b=x;for(;b<0;)b+=i;let w=Math.min(t.inDepth,u+x);for(let r=0;r<t.outHeight;++r){let u=r*a-c,d=u;for(;d<0;)d+=o;let v=Math.min(t.inHeight,h+u);for(let a=0;a<t.outWidth;++a){let c=a*s-f,k=c;for(;k<0;)k+=l;let N=Math.min(t.inWidth,p+c),I=-1/0,S=-1;for(let t=b;t<w;t+=i){let n=t-x;for(let r=d;r<v;r+=o){let a=r-u;for(let s=k;s<N;s+=l){let i=s-c,o=e.get(m,t,r,s,g);o>=I&&(I=o,S=n*h*p+a*h+i)}}}n.set(S,m,y,r,a,g)}}}return n}(n.bufferSync(s),h),d=h.strideDepth,c=h.strideHeight,f=h.strideWidth,m=h.dilationDepth,g=h.dilationHeight,y=h.dilationWidth,x=h.effectiveFilterDepth,b=h.effectiveFilterHeight,w=h.effectiveFilterWidth,v=x-1-h.padInfo.front,k=w-1-h.padInfo.left,N=b-1-h.padInfo.top,I=sW(s.shape,"float32"),S=n.bufferSync(a);for(let e=0;e<h.batchSize;++e)for(let t=0;t<h.inChannels;++t)for(let n=0;n<h.inDepth;++n)for(let r=0;r<h.inHeight;++r)for(let a=0;a<h.inWidth;++a){let s=n-v,i=r-N,o=a-k,l=0;for(let n=0;n<x;n+=m){let r=(s+n)/d;if(!(r<0)&&!(r>=h.outDepth)&&Math.floor(r)===r)for(let a=0;a<b;a+=g){let s=(i+a)/c;if(!(s<0)&&!(s>=h.outHeight)&&Math.floor(s)===s)for(let i=0;i<w;i+=y){let u=(o+i)/f;if(u<0||u>=h.outWidth||Math.floor(u)!==u)continue;let d=+(x*b*w-1-p.get(e,r,s,u,t)===n*b*w+a*w+i);0!==d&&(l+=S.get(e,r,s,u,t)*d)}}}I.set(l,e,n,r,a,t)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}},{kernelName:n4,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t;b4([s,i],"maxPoolGrad");let{filterSize:o,strides:l,pad:u,dimRoundingMode:h}=r,p=lz.computePool2DInfo(s.shape,o,l,1,u,h),d=n.data.get(s.dataId).values,c=sW(p.outShape,s.dtype,vq(d,s.shape,s.dtype,p).values),f=p.strideHeight,m=p.strideWidth,g=p.dilationHeight,y=p.dilationWidth,x=p.effectiveFilterHeight,b=p.effectiveFilterWidth,w=b-1-p.padInfo.left,v=x-1-p.padInfo.top,k=sW(s.shape,"float32"),N=n.data.get(a.dataId).values,I=sW(a.shape,"float32",N);for(let e=0;e<p.batchSize;++e)for(let t=0;t<p.inChannels;++t)for(let n=0;n<p.inHeight;++n)for(let r=0;r<p.inWidth;++r){let a=n-v,s=r-w,i=0;for(let n=0;n<x;n+=g){let r=(a+n)/f;if(!(r<0)&&!(r>=p.outHeight)&&Math.floor(r)===r)for(let a=0;a<b;a+=y){let o=(s+a)/m;if(o<0||o>=p.outWidth||Math.floor(o)!==o)continue;let l=+(x*b-1-c.get(e,r,o,t)===n*b+a);0!==l&&(i+=I.get(e,r,o,t)*l)}}k.set(i,e,n,r,t)}return n.makeTensorInfo(k.shape,k.dtype,k.values)}},{kernelName:n8,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{var r,a;let s,i,o,{x:l}=e,{filterSize:u,strides:h,pad:p,includeBatchInIndex:d}=t;b4(l,"MaxPoolWithArgmax");let c=n.data.get(l.dataId).values,f=lz.computePool2DInfo(l.shape,u,h,[1,1],p),[m,g]=(r=l.shape,a=l.dtype,s=ha.computeStrides(r),i=vH(c,r,a,s,f,"max"),o=vq(c,r,a,f,!0,d),[i.values,o.values]),y=n.write(m,f.outShape,l.dtype),x=n.write(g,f.outShape,l.dtype);return[{dataId:y,shape:f.outShape,dtype:l.dtype},{dataId:x,shape:f.outShape,dtype:"int32"}]}},{kernelName:n7,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=ha.parseAxisParam(s,a.shape),l=lz.computeOutAndReduceShapes(a.shape,o)[1],u=ha.sizeFromShape(l),h=[],p=n.makeTensorInfo([],"float32",new Float32Array([u]));h.push(p);let d=wa({inputs:{x:a},backend:n,attrs:{dtype:"float32"}});h.push(d);let c=kt({inputs:{a:d,b:p},backend:n});h.push(c);let f=v2({inputs:{x:c},backend:n,attrs:{axis:s,keepDims:i}});return h.forEach(e=>n.disposeIntermediateTensorInfo(e)),f}},{kernelName:"Min",backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;b4(a,"min");let o=ha.parseAxisParam(s,a.shape),l=o,u=lz.getAxesPermutation(l,a.shape.length),h=a;null!=u&&(h=wQ({inputs:{x:a},backend:n,attrs:{perm:u}}),l=lz.getInnerMostAxes(l.length,a.shape.length)),lz.assertAxesAreInnerMostDims("min",l,h.shape.length);let[p,d]=lz.computeOutAndReduceShapes(h.shape,l),c=ha.sizeFromShape(d),f=ha.makeZerosTypedArray(ha.sizeFromShape(p),h.dtype),m=n.data.get(h.dataId).values;for(let e=0;e<f.length;++e){let t=e*c,n=m[t];for(let e=0;e<c;++e){let r=m[t+e];(Number.isNaN(r)||r<n)&&(n=r)}f[e]=n}null!=u&&n.disposeIntermediateTensorInfo(h);let g=n.makeTensorInfo(p,h.dtype,f);if(i){let e=vL({inputs:{x:g},backend:n,attrs:{shape:lz.expandShapeToKeepDim(p,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},{kernelName:n9,backendName:"cpu",kernelFunc:wH},{kernelName:re,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,mode:i}=r;b4(a,"mirrorPad");let o=s.map((e,t)=>e[0]+a.shape[t]+e[1]),l=s.map(e=>e[0]),u=s.map((e,t)=>e[0]+a.shape[t]),h=+("reflect"!==i),p=n.data.get(a.dataId).values,d=a.shape.length,c=ha.computeStrides(a.shape),f=ha.sizeFromShape(o),m=o.length,g=ha.computeStrides(o),y=ha.getTypedArrayFromDType(a.dtype,f);for(let e=0;e<f;e++){let t=ha.indexToLoc(e,m,g);for(let e=0;e<m;e++)t[e]<l[e]?t[e]=2*l[e]-t[e]-h:t[e]>=u[e]&&(t[e]=(u[e]-1)*2-t[e]+h);t=t.map((e,t)=>e-l[t]);let n=ha.locToIndex(t,d,c);y[e]=p[n]}return{dataId:n.write(y,o,a.dtype),shape:o,dtype:a.dtype}}},{kernelName:"Mod",backendName:"cpu",kernelFunc:kc},{kernelName:rt,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r;b4(a,"multinomial");let l=o?a:kf({inputs:{logits:a},backend:n,attrs:{dim:-1}}),u=l.shape[0],h=l.shape[1],p=n.data.get(l.dataId).values,d=[u,s],c=ha.makeZerosTypedArray(ha.sizeFromShape(d),"int32");for(let e=0;e<u;++e){let t=e*h,n=new Float32Array(h-1);n[0]=p[t];for(let e=1;e<n.length;++e)n[e]=n[e-1]+p[t+e];let r=pH.alea(i.toString()),a=e*s;for(let e=0;e<s;++e){let t=r();c[a+e]=n.length;for(let r=0;r<n.length;r++)if(t<n[r]){c[a+e]=r;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(d,"int32",c)}},{kernelName:rn,backendName:"cpu",kernelFunc:wK},{kernelName:"Neg",backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t;b4(r,"neg");let[a,s]=wX(n.data.get(r.dataId).values,r.shape,r.dtype);return n.makeTensorInfo(s,r.dtype,a)}},{kernelName:ra,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;b4(a,"NonMaxSuppression");let{selectedIndices:u}=km(n.data.get(a.dataId).values,n.data.get(s.dataId).values,i,o,l);return n.makeTensorInfo([u.length],"int32",new Int32Array(u))}},{kernelName:rs,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;b4(a,"NonMaxSuppressionPadded");let{selectedIndices:h,validOutputs:p}=kg(n.data.get(a.dataId).values,n.data.get(s.dataId).values,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},{kernelName:ri,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;b4(a,"NonMaxSuppressionWithScore");let{selectedIndices:h,selectedScores:p}=ky(n.data.get(a.dataId).values,n.data.get(s.dataId).values,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([p.length],"float32",new Float32Array(p))]}},{kernelName:rr,backendName:"cpu",kernelFunc:wZ},{kernelName:rl,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r;b4(a,"oneHot");let u=ha.sizeFromShape(a.shape),h=new Float32Array(u*i);h.fill(l);let p=n.data.get(a.dataId).values;for(let e=0;e<u;++e)p[e]>=0&&p[e]<i&&(h[e*i+p[e]]=o);return n.makeTensorInfo([...a.shape,i],s,h)}},{kernelName:ro,backendName:"cpu",kernelFunc:function e(t){let{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw Error("onesLike is not supported for string tensors");if("complex64"!==a.dtype)return ka({backend:r,attrs:{shape:a.shape,value:1,dtype:a.dtype}});{let t=wn({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),s=vY({inputs:{input:a},backend:r}),i=kx({inputs:{x:s},backend:r}),o=b9({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}}},{kernelName:ru,backendName:"cpu",kernelFunc:kb},kw,{kernelName:"Pow",backendName:"cpu",kernelFunc:kv},{kernelName:rp,backendName:"cpu",kernelFunc:vF},{kernelName:rd,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;b4(a,"prod");let o=a.shape.length,l=ha.parseAxisParam(s,a.shape),u=lz.getAxesPermutation(l,o),h=l,p=a,d=[];null!=u&&(d.push(p=wQ({inputs:{x:a},backend:n,attrs:{perm:u}})),h=lz.getInnerMostAxes(h.length,o));let c=n.data.get(p.dataId).values,{outVals:f,outShape:m,outDtype:g}=w0(p.shape,p.dtype,c,h),y=m;return i&&(y=lz.expandShapeToKeepDim(m,l)),d.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(y,g,f)}},{kernelName:rc,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=r,l=a.map(e=>n.data.get(e.dataId).values),u=a.map(e=>e.shape),h=n.data.get(s.dataId).values,p=n.data.get(i.dataId).values,[d,c,f]=w2(l,u,h,s.shape,s.dtype,p,i.shape,o),m=d.map(e=>n.makeTensorInfo([e.length],"int32",e)),g=n.makeTensorInfo(f,s.dtype,c);return m.concat([g])}},{kernelName:rf,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:s}=t,i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,h]=w3(i,r.shape,r.dtype,o,a.shape,l,s.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([h.length],r.dtype,h)]}},{kernelName:rm,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.data.get(a.dataId).values,h=n.data.get(s.dataId).values,p=n.data.get(i.dataId).values,d=o.map(e=>n.data.get(e.dataId).values),c=o.map(e=>e.shape),[f,m]=w7(u,a.shape,h,s.shape,s.dtype,p,i.shape,d,c,l);return n.makeTensorInfo(f,s.dtype,m)}},{kernelName:rg,backendName:"cpu",kernelFunc:function(e){let{backend:t,attrs:n}=e,{start:r,stop:a,dtype:s,step:i}=n,o=w9(r,a,i,s);return t.makeTensorInfo([o.length],s,o)}},{kernelName:ry,backendName:"cpu",kernelFunc:wn},kn,{kernelName:rx,backendName:"cpu",kernelFunc:kk},{kernelName:rb,backendName:"cpu",kernelFunc:v_},{kernelName:rS,backendName:"cpu",kernelFunc:vD},{kernelName:rw,backendName:"cpu",kernelFunc:vL},{kernelName:rN,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;b4(a,"resizeBilinear");let l=ha.computeStrides(a.shape),[u,h]=o,[p,d,c,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(ha.sizeFromShape([p,u,h,f])),y=[s&&u>1?d-1:d,s&&h>1?c-1:c],x=[s&&u>1?u-1:u,s&&h>1?h-1:h],b=0,w=y[0]/x[0],v=y[1]/x[1];for(let e=0;e<p;e++)for(let t=0;t<u;t++){let n,r=Math.max(0,Math.floor(n=i?w*(t+.5)-.5:w*t)),a=n-r,s=Math.min(d-1,Math.ceil(n)),o=e*l[0]+r*l[1],u=e*l[0]+s*l[1];for(let e=0;e<h;e++){let t,n=Math.max(0,Math.floor(t=i?v*(e+.5)-.5:v*e)),r=t-n,s=Math.min(c-1,Math.ceil(t)),h=o+n*l[2],p=u+n*l[2],d=o+s*l[2],y=u+s*l[2];for(let e=0;e<f;e++){let t=m[h+e],n=m[p+e],s=m[d+e],i=m[y+e],o=t+(s-t)*r,l=o+(n+(i-n)*r-o)*a;g[b++]=l}}}return n.makeTensorInfo([p,u,h,f],"float32",g)}},{kernelName:rI,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;b4([s,a],"resizeBilinearGrad");let o=ha.computeStrides(a.shape),[l,u,h,p]=a.shape,[,d,c]=s.shape,f=new Float32Array(l*u*h*p),m=[i&&d>1?u-1:u,i&&c>1?h-1:h],g=[i&&d>1?d-1:d,i&&c>1?c-1:c],y=m[0]/g[0],x=m[1]/g[1],b=n.data.get(s.dataId).values,w=0;for(let e=0;e<l;e++){let t=e*o[0];for(let e=0;e<d;e++){let n=e*y,r=Math.floor(n),a=Math.min(Math.ceil(n),u-1),s=t+r*o[1],i=t+a*o[1],l=n-r,d=1-l;for(let e=0;e<c;e++){let t=e*x,n=Math.floor(t),r=Math.min(Math.ceil(t),h-1),a=t-n,u=1-a,c=s+n*o[2],m=s+r*o[2],g=i+n*o[2],y=i+r*o[2],v=d*u,k=d*a,N=l*u,I=l*a;for(let e=0;e<p;e++){let t=b[w++];f[c+e]+=t*v,f[m+e]+=t*k,f[g+e]+=t*N,f[y+e]+=t*I}}}}return n.makeTensorInfo([l,h,u,p],"float32",f)}},{kernelName:rv,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;b4(a,"resizeNearestNeighbor");let l=ha.computeStrides(a.shape),[u,h]=o,[p,d,c,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(p*u*h*f),y=[s&&u>1?d-1:d,s&&h>1?c-1:c],x=[s&&u>1?u-1:u,s&&h>1?h-1:h],b=y[0]/x[0],w=y[1]/x[1],v=0;for(let e=0;e<p;e++){let t=e*l[0];for(let e=0;e<u;e++){let n=i?b*(e+.5):b*e,r=Math.min(d-1,s?Math.round(n):Math.floor(n));i&&(r=Math.max(0,r));let a=t+r*l[1];for(let e=0;e<h;e++){let t=i?w*(e+.5):w*e,n=Math.min(c-1,s?Math.round(t):Math.floor(t));i&&(n=Math.max(0,n));let r=a+n*l[2];for(let e=0;e<f;e++){let t=m[r+e];g[v++]=t}}}}return n.makeTensorInfo([p,u,h,f],a.dtype,g)}},{kernelName:rk,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;b4([s,a],"resizeNearestNeighborGrad");let o=ha.computeStrides(a.shape),l=ha.computeStrides(s.shape),[u,h,p,d]=a.shape,[,c,f]=s.shape,m=new Float32Array(u*h*p*d),g=n.data.get(s.dataId).values,y=[i&&c>1?h-1:h,i&&f>1?p-1:p],x=[i&&c>1?c-1:c,i&&f>1?f-1:f],b=y[0]/x[0],w=y[1]/x[1],v=1/b,k=1/w,N=2*Math.ceil(v)+2,I=2*Math.ceil(k)+2;for(let e=0;e<u;e++){let t=e*o[0];for(let e=0;e<h;e++){let n=t+e*o[1],r=Math.floor(Math.floor(e*v)-N/2);for(let a=0;a<p;a++){let s=n+a*o[2],u=Math.floor(Math.floor(a*k)-I/2);for(let n=0;n<d;n++){let o=0;for(let s=0;s<N;s++){let d=s+r;if(d<0||d>=c)continue;let m=t+d*l[1],y=d*b;if(e===Math.min(h-1,i?Math.round(y):Math.floor(y)))for(let e=0;e<I;e++){let t=e+u;if(t<0||t>=f)continue;let r=m+t*l[2],s=t*w;a===Math.min(p-1,i?Math.round(s):Math.floor(s))&&(o+=g[r+n])}}m[s+n]=o}}}}return n.makeTensorInfo(a.shape,a.dtype,m)}},{kernelName:rC,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r;b4(a,"reverse");let i=a.shape.length,o=ha.parseAxisParam(s,a.shape);if(0===i)return wt({inputs:{x:a},backend:n});let l=new aT(a.shape,a.dtype),u=n.bufferSync(a);for(let e=0;e<l.size;e++){let t=l.indexToLoc(e),n=t.slice();o.forEach(e=>n[e]=a.shape[e]-1-n[e]),l.set(u.get(...n),...t)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},{kernelName:an,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:a,fillValue:s,center:i}=t,o=ha.getTypedArrayFromDType(r.dtype,ha.sizeFromShape(r.shape)),[l,u,h,p]=r.shape,[d,c]=lz.getImageCenter(i,u,h),f=Math.sin(a),m=Math.cos(a),g=n.data.get(r.dataId).values;for(let e=0;e<l;e++){let t=e*h*u*p;for(let e=0;e<u;e++){let n=h*p*e;for(let r=0;r<h;r++){let a=r*p;for(let i=0;i<p;i++){let y=[l,e,r,i],x=y[2],b=y[1],w=(x-d)*m-(b-c)*f,v=(x-d)*f+(b-c)*m;w=Math.round(w+d),v=Math.round(v+c);let k=s;"number"!=typeof s&&(k=3===i?255:s[i]),w>=0&&w<h&&v>=0&&v<u&&(k=g[t+h*p*v+w*p+i]),o[t+n+a+i]=k}}}}return{dataId:n.write(o,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},{kernelName:rT,backendName:"cpu",kernelFunc:kN},{kernelName:r$,backendName:"cpu",kernelFunc:vt},{kernelName:rE,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:h,outputSize:p}=lz.calculateShapes(s,a,i),d=vn(n.bufferSync(a),n.bufferSync(s),i,p,u,l,o,h,0,!0);return n.makeTensorInfo(i,d.dtype,d.values)}},{kernelName:rR,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=function(e,t,n,r,a,s){let i=ha.getArrayFromDType("int32",n*a);for(let o=0;o<n;++o){let n=e.slice(o*r,(o+1)*r),l=o*a;for(let e=0;e<a;++e)i[l+e]="left"===s?function(e,t){let n=0,r=e.length,a=0;for(;n<r;)e[a=Math.floor((n+r)/2)]<t?n=a+1:r=a;return r}(n,t[e+l]):function(e,t){let n=0,r=e.length,a=0;for(;n<r;)e[a=Math.floor((n+r)/2)]<=t?n=a+1:r=a;return r}(n,t[e+l])}return i}(n.data.get(a.dataId).values,n.data.get(s.dataId).values,a.shape[0],a.shape[1],s.shape[1],i);return n.makeTensorInfo(s.shape,"int32",o)}},{kernelName:rF,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t;b4([r,a,s],"select");let i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,h=aD(a.dtype,s.dtype),p=ha.makeZerosTypedArray(ha.sizeFromShape(a.shape),h),d=0,c=0===i||i>1||1===a.shape.length?1:ha.sizeFromShape(a.shape.slice(1));for(let e=0;e<o.length;e++)for(let t=0;t<c;t++)1===o[e]?p[d++]=l[e]:p[d++]=u[e];return n.makeTensorInfo(a.shape,h,p)}},{kernelName:r_,backendName:"cpu",kernelFunc:kC},{kernelName:rL,backendName:"cpu",kernelFunc:va},{kernelName:rM,backendName:"cpu",kernelFunc:kT},{kernelName:"Sin",backendName:"cpu",kernelFunc:k$},{kernelName:rO,backendName:"cpu",kernelFunc:kE},{kernelName:rD,backendName:"cpu",kernelFunc:vo},{kernelName:rU,backendName:"cpu",kernelFunc:kf},{kernelName:rz,backendName:"cpu",kernelFunc:kR},{kernelName:rB,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;b4([a],"spaceToBatchND");let o=ha.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let e=1+s.length;e<a.shape.length;++e)l.push([0,0]);let u=kw.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),h=lz.getReshaped(u.shape,s,o,!1),p=lz.getPermuted(h.length,s.length,!1),d=lz.getReshapedPermuted(u.shape,s,o,!1),c=vL({inputs:{x:u},backend:n,attrs:{shape:h}}),f=wQ({inputs:{x:c},backend:n,attrs:{perm:p}}),m=vL({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(f),m}},{kernelName:rj,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(1!==s.shape.length)throw Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(2!==r.shape.length)throw Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(1!==a.shape.length)throw Error(`Values must be a vector, saw:
        ${a.shape}`);if(0!==i.shape.length)throw Error(`Default value must be a scalar, saw:
        ${i.shape}`);let o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,h=n.data.get(i.dataId).values[0],[p,d,c,f,m]=vl(o,r.shape,r.dtype,l,a.dtype,u,h);return[n.makeTensorInfo(d,r.dtype,p),n.makeTensorInfo([d[0]],a.dtype,c),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(e=>Number(e)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}},{kernelName:rV,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(2!==r.shape.length)throw Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(1!==a.shape.length)throw Error(`Input shape should be a vector but received shape
        ${a.shape}`);if(1!==s.shape.length)throw Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.data.get(a.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(s.dataId).values),[u,h,p]=vu(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(h,r.dtype,u),n.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}},{kernelName:rG,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw Error(`Indices should be a vector but received shape
          ${a.shape}`);if(1!==s.shape.length)throw Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(a.shape[0]!==s.shape[0])throw Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,h]=vh(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(h,r.dtype,u)}},{kernelName:rH,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw Error(`Indices should be a vector but received shape
         ${a.shape}`);if(1!==s.shape.length)throw Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(a.shape[0]!==s.shape[0])throw Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,h]=vh(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(h,r.dtype,u)}},{kernelName:rq,backendName:"cpu",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{sparseIndices:s,sparseValues:i,defaultValue:o}=n,{outputShape:l}=a,{sliceRank:u,numUpdates:h,sliceSize:p,strides:d,outputSize:c}=lz.calculateShapes(i,s,l),f=r.bufferSync(s);switch(i.dtype){case"bool":t=vn(f,r.bufferSync(i),l,c,p,h,u,d,!!r.data.get(o.dataId).values[0],!1);break;case"float32":case"int32":t=vn(f,r.bufferSync(i),l,c,p,h,u,d,r.data.get(o.dataId).values[0],!1);break;case"string":t=vn(f,r.bufferSync(i),l,c,p,h,u,d,ha.decodeString(r.data.get(o.dataId).values[0]),!1);break;default:throw Error(`Unsupported type ${i.dtype}`)}return r.makeTensorInfo(l,t.dtype,t.values)}},{kernelName:rW,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=ha.parseAxisParam(i,a.shape)[0],l=lz.prepareSplitSize(a,s,o),u=Array(a.shape.length).fill(0),h=a.shape.slice();return l.map(e=>{let t=[...h];t[o]=e;let r=vo({inputs:{x:a},backend:n,attrs:{begin:u,size:t}});return u[o]+=e,r})}},{kernelName:rP,backendName:"cpu",kernelFunc:vd},{kernelName:rX,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{let{x:n}=e;b4(n,"square");let r=t.data.get(n.dataId).values,a=new Float32Array(r.length);for(let e=0;e<r.length;++e){let t=r[e];a[e]=t*t}return{dataId:t.write(a,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},{kernelName:rK,backendName:"cpu",kernelFunc:vf},{kernelName:rY,backendName:"cpu",kernelFunc:vg},{kernelName:ae,backendName:"cpu",kernelFunc:kF},{kernelName:rZ,backendName:"cpu",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{begin:i,end:o,strides:l,beginMask:u,endMask:h,ellipsisMask:p,newAxisMask:d,shrinkAxisMask:c}=a;b4(s,"stridedSlice");let{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:x,begin:b,end:w,strides:v}=vs.sliceInfo(s.shape,i,o,l,u,h,p,d,c);if(g)t=vL({inputs:{x:s},backend:r,attrs:{shape:m}});else if(y||x){ha.assert(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);let e=vs.computeOutShape(b,w,v),n=vo({inputs:{x:s},backend:r,attrs:{begin:b,size:e}});t=vL({inputs:{x:n},backend:r,attrs:{shape:m}}),r.disposeIntermediateTensorInfo(n)}else{let e=vy(f,r.bufferSync(s),v,b);t=r.makeTensorInfo(m,e.dtype,e.values)}return t}},{kernelName:rJ,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:h,dataSplits:p}=t,[d,c]=vb(n.data.get(h.dataId).values,n.data.get(p.dataId).values,a,s,i,o,l,u);return[n.makeTensorInfo([d.length],"string",d),n.makeTensorInfo(p.shape,"int32",c)]}},{kernelName:rQ,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if("string"!==s.dtype)throw Error("Input must be of datatype string");if(1!==s.shape.length)throw Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==i.shape.length)throw Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let[o,l,u]=vw(n.data.get(s.dataId).values,n.data.get(i.dataId).values[0],a),h=l.length;return[n.makeTensorInfo([h,2],"int32",o),n.makeTensorInfo([h],"string",l),n.makeTensorInfo([2],"int32",new Int32Array(u))]}},{kernelName:r0,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if("string"!==s.dtype)throw Error("Input must be of datatype string");if(a<=0)throw Error("Number of buckets must be at least 1");let i=vv(n.data.get(s.dataId).values,a);return n.makeTensorInfo(s.shape,"int32",i)}},{kernelName:"Sub",backendName:"cpu",kernelFunc:vN},{kernelName:"Sum",backendName:"cpu",kernelFunc:v2},{kernelName:"Tan",backendName:"cpu",kernelFunc:k_},{kernelName:r1,backendName:"cpu",kernelFunc:kD},{kernelName:rA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{tensor:r,indices:a,updates:s}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:u,outputSize:h}=lz.calculateShapes(s,a,r.shape),p=n.bufferSync(a),d=n.bufferSync(s),c=n.bufferSync(r),f=vn(p,d,r.shape,h,l,o,i,u,c,!1);return n.makeTensorInfo(r.shape,f.dtype,f.values)}},{kernelName:r2,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;b4(a,"tile");let i=vI(n.bufferSync(a),s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}},{kernelName:r3,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r;b4(a,"topk");let[o,l]=vC(n.data.get(a.dataId).values,a.shape,a.dtype,s,i);return[n.makeTensorInfo(o.shape,o.dtype,o.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}},{kernelName:r4,backendName:"cpu",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[h,p,d,c]=a.shape,[f,m]=null!=u?u:[p,d],g=[h,f,m,c],y=ha.computeStrides(a.shape),x=y[0],b=y[1],w=y[2],v=ha.computeStrides(g),k=v[0],N=v[1],I=v[2],S=ha.getTypedArrayFromDType(a.dtype,ha.sizeFromShape(g));S.fill(l);let C=r.data.get(a.dataId).values,T=r.data.get(s.dataId).values;for(let e=0;e<h;++e){let t=1===s.shape[0]?T:T.subarray(8*e,8*e+8);for(let n=0;n<f;++n)for(let r=0;r<m;++r)for(let a=0;a<c;++a){let s,u=t[6]*r+t[7]*n+1;if(0===u)continue;let h=(t[0]*r+t[1]*n+t[2])/u,c=(t[3]*r+t[4]*n+t[5])/u,f=kO(h,d,o),m=kO(c,p,o);switch(i){case"nearest":s=kM(C,p,d,x,b,w,e,Math.round(m),Math.round(f),a,l);break;case"bilinear":s=function(e,t,n,r,a,s,i,o,l,u,h){let p=Math.floor(o),d=Math.floor(l),c=p+1,f=d+1,m=(f-l)*kM(e,t,n,r,a,s,i,p,d,u,h)+(l-d)*kM(e,t,n,r,a,s,i,p,f,u,h),g=(f-l)*kM(e,t,n,r,a,s,i,c,d,u,h)+(l-d)*kM(e,t,n,r,a,s,i,c,f,u,h);return(c-o)*m+(o-p)*g}(C,p,d,x,b,w,e,m,f,a,l);break;default:throw Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}S[e*k+n*N+r*I+a]=s}return r.makeTensorInfo(g,a.dtype,S)}return{dataId:r.write(S,g,a.dtype),shape:a.shape,dtype:a.dtype}}},{kernelName:r5,backendName:"cpu",kernelFunc:wQ},{kernelName:r6,backendName:"cpu",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;b4(s,"unique");let{outputValues:i,outputShape:o,indices:l}=vT(r.data.get(s.dataId).values,a,s.shape,s.dtype);return[r.makeTensorInfo(o,s.dtype,i),r.makeTensorInfo([l.length],"int32",l)]}},{kernelName:r8,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a.shape.length,o=a.shape[s],l=Array(i-1),u=0;for(let e=0;e<i;e++)e!==s&&(l[u++]=a.shape[e]);let h=Array(i).fill(0),p=a.shape.slice();p[s]=1;let d=Array(o);for(let e=0;e<d.length;e++){h[s]=e;let t=vo({inputs:{x:a},backend:n,attrs:{begin:h,size:p}});d[e]=vL({inputs:{x:t},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(t)}return d}},{kernelName:r7,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r;b4(a,"unsortedSegmentSum");let o=a.shape.length,l=s.shape.length,u=[],h=[],p=o-l,d=s;for(let e=0;e<p;++e){let t=ke({inputs:{input:d},backend:n,attrs:{dim:e+1}});d=t,h.push(t)}for(let e=0;e<i;++e){let t=ha.createScalarValue(e,"int32"),r=n.makeTensorInfo([],"int32",t),s=ww({inputs:{a:r,b:d},backend:n}),i=wa({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),o=wK({inputs:{a:i,b:a},backend:n}),l=v2({inputs:{x:o},backend:n,attrs:{axis:0,keepDims:!1}});u.push(l),h.push(r),h.push(s),h.push(i),h.push(o),h.push(l)}let c=kb({inputs:u,backend:n,attrs:{axis:0}});return h.forEach(e=>n.disposeIntermediateTensorInfo(e)),c}},{kernelName:r9,backendName:"cpu",kernelFunc:kx}])ad(e);var kL=e.i(31654),kL=kL,kL=kL,ha=ha;let kz={},kP={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function kB(e,t){kz[e]=t}function kW(e,t){if(!(e in kz)||null!=t){let n=function(e,t){if(1!==e&&2!==e)throw Error("Cannot get WebGL rendering context, WebGL is disabled.");let n=null==t?function(e){if(!tU.getBool("IS_SAFARI")&&"undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw Error("Cannot create a canvas in this context")}(e):t;return(n.addEventListener("webglcontextlost",t=>{t.preventDefault(),delete kz[e]},!1),tU.getBool("SOFTWARE_WEBGL_ENABLED")&&(kP.failIfMajorPerformanceCaveat=!1),1===e)?n.getContext("webgl",kP)||n.getContext("experimental-webgl",kP):n.getContext("webgl2",kP)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;kz[e]=n}let n=kz[e];return null==n||n.isContextLost()?(delete kz[e],kW(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),kz[e])}var ha=ha;function kU(e){let t=Math.ceil(ha.sizeFromShape(e)/4);return ha.sizeToSquarishShape(t)}function kj(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function kV(e,t){let n,r,a,s,i,o,l,u,h,p;return 2===tU.getNumber("WEBGL_VERSION")?(n=e.R32F,r=e.R16F,a=e.RGBA16F,s=e.RGBA32F,i=e.RED,l=4,u=1,h=e.HALF_FLOAT,p=e.FLOAT,o=e.RGBA8):(n=e.RGBA,r=e.RGBA,a=e.RGBA,s=e.RGBA,i=e.RGBA,l=4,u=4,h=null!=t?t.HALF_FLOAT_OES:null,p=e.FLOAT,o=e.RGBA),{internalFormatFloat:n,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:s,textureFormatFloat:i,downloadTextureFormat:o,downloadUnpackNumChannels:l,defaultNumChannels:u,textureTypeHalfFloat:h,textureTypeFloat:p}}function kG(e,t){let n=t();return tU.getBool("DEBUG")&&function(e){let t=e.getError();if(t!==e.NO_ERROR)throw Error("WebGL Error: "+kq(e,t))}(e),n}function kH(e){return!!(tU.getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||596e-10<Math.abs(e)&&65504>Math.abs(e))}function kq(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function kK(e,t){return Nu(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function kX(e,t){let n=Nu(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(kG(e,()=>e.shaderSource(n,t)),kG(e,()=>e.compileShader(n)),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),Error("Failed to compile vertex shader.");return n}function kY(e,t){let n=Nu(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(kG(e,()=>e.shaderSource(n,t)),kG(e,()=>e.compileShader(n)),tU.get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw kJ(t,e.getShaderInfoLog(n)),Error("Failed to compile fragment shader.");return n}(v=M||(M={}))[v.DENSE=0]="DENSE",v[v.SHARED_BATCH=1]="SHARED_BATCH",(k=L||(L={}))[k.RENDER=0]="RENDER",k[k.UPLOAD=1]="UPLOAD",k[k.PIXELS=2]="PIXELS",k[k.DOWNLOAD=3]="DOWNLOAD",(N=z||(z={}))[N.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",N[N.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",N[N.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",N[N.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",N[N.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16";let kZ=/ERROR: [0-9]+:([0-9]+):/g;function kJ(e,t){let n=kZ.exec(t);if(null==n){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}let r=+n[1],a=e.split("\n"),s=a.length.toString().length+2,i=a.map((e,t)=>ha.rightPad((t+1).toString(),s)+e),o=0;for(let e=0;e<i.length;e++)o=Math.max(i[e].length,o);let l=i.slice(0,r-1),u=i.slice(r-1,r),h=i.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${ha.rightPad(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(h.join("\n"))}function kQ(e){return Nu(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function k0(e,t){if(kG(e,()=>e.linkProgram(t)),!tU.get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),Error("Failed to link vertex and fragment shaders.")}function k1(e,t){if(kG(e,()=>e.validateProgram(t)),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),Error("Shader program validation failed.")}function k2(e,t){let n=Nu(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return kG(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),kG(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function k3(e,t){let n=Nu(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return kG(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),kG(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function k4(){return 2===tU.getNumber("WEBGL_VERSION")?1:4}function k5(e){return Nu(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function k6(e,t){let n=tU.getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}function k8(e){return Nu(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function k7(e,t,n,r,a,s,i){let o=e.getAttribLocation(t,n);return -1!==o&&(kG(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),kG(e,()=>e.vertexAttribPointer(o,a,e.FLOAT,!1,s,i)),kG(e,()=>e.enableVertexAttribArray(o)),!0)}function k9(e,t,n){Nh(e,n),kG(e,()=>e.activeTexture(e.TEXTURE0+n)),kG(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function Ne(e,t){Nh(e,t),kG(e,()=>e.activeTexture(e.TEXTURE0+t)),kG(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function Nt(e,t,n){return Nu(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function Nn(e,t,n){return e.getUniformLocation(t,n)}function Nr(e,t,n,r){kG(e,()=>k9(e,t,r)),kG(e,()=>e.uniform1i(n,r))}function Na(e){kG(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),kG(e,()=>e.viewport(0,0,e.canvas.width,e.canvas.height)),kG(e,()=>e.scissor(0,0,e.canvas.width,e.canvas.height))}function Ns(e,t,n){kG(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),kG(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function Ni(e,t){kG(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),kG(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function No(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw Error("Error binding framebuffer: "+Nl(e,t))}function Nl(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function Nu(e,t,n){let r=kG(e,()=>t());if(null==r)throw Error(n);return r}function Nh(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){let e=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw Error(`textureUnit must be in ${e}.`)}}function Np(e,t=2){return ha.sizeFromShape(e.slice(0,e.length-t))}function Nd(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function Nc(e){let t=[1,1,1];return 0!==e.length&&(1!==e.length||1!==e[0])&&(t=[Np(e),...Nd(e)]),t}function Nf(e,t=!1){let n=tU.getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=tU.getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&tU.getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n*=2,r*=2,1===(e=e.map((t,n)=>n>=e.length-2?ha.nearestLargerEven(e[n]):e[n])).length&&(e=[2,e[0]])),2!==e.length&&(e=ha.squeezeShape(e).newShape);let a=ha.sizeFromShape(e),s=null;e.length<=1&&a<=n?s=[1,a]:2===e.length&&e[0]<=n&&e[1]<=n?s=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?s=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?s=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?s=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(s=[e[0],e[1]*e[2]*e[3]]);let i=null!=s&&Math.max(...s)>r&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(null==s||i)if(t){let t=Np(e),n=2,r=2;e.length&&([n,r]=Nd(e)),a=n/2*t*(r/2),s=ha.sizeToSquarishShape(a).map(e=>2*e)}else s=ha.sizeToSquarishShape(a);return s}function Nm(e,t){if(e=e.slice(-2),t=t.slice(-2),ha.arraysEqual(e,t)||!e.length||!t.length||0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){let n=e[e.length-1],r=t[t.length-1];if(n===r||n%2==0&&r%2==0&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&e[0]%2==0&&t[0]%2==0}function Ng(e){if(null==i){let t=kW(e);i=t.getParameter(t.MAX_TEXTURE_SIZE)}return i}function Ny(){i=null}function Nx(){o=null}function Nb(e){if(null==o){let t=kW(e);o=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,o)}function Nw(e){if(0===e)return 0;let t=kW(e);return Nv(t,"EXT_disjoint_timer_query_webgl2")&&2===e?2:+!!Nv(t,"EXT_disjoint_timer_query")}function Nv(e,t){return null!=e.getExtension(t)}function Nk(e){try{let t=kW(e);if(null!=t)return!0}catch(e){console.log("Error when getting WebGL context: ",e)}return!1}function NN(e){if(0===e)return!1;let t=kW(e);if(1===e){if(!Nv(t,"OES_texture_float"))return!1}else if(!Nv(t,"EXT_color_buffer_float"))return!1;return NS(t)}function NI(e){if(0===e)return!1;let t=kW(e);if(1===e){if(!Nv(t,"OES_texture_float")||!Nv(t,"WEBGL_color_buffer_float"))return!1}else{if(Nv(t,"EXT_color_buffer_float"))return NS(t);let e="EXT_color_buffer_half_float";if(Nv(t,e)){var n;let r,a,s,i,o=t.getExtension(e);return r=kV(n=t,o),a=n.createTexture(),n.bindTexture(n.TEXTURE_2D,a),n.texImage2D(n.TEXTURE_2D,0,r.internalFormatHalfFloat,1,1,0,r.textureFormatFloat,r.textureTypeHalfFloat,null),s=n.createFramebuffer(),n.bindFramebuffer(n.FRAMEBUFFER,s),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,a,0),i=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE,n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(a),n.deleteFramebuffer(s),i}return!1}return NS(t)}function NS(e){let t=kV(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);let r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),a}function NC(e){return 2===e&&null!=kW(e).fenceSync}function NT(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&ha.assert("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}e.s(["assertNotComplex",()=>NT,"bindCanvasToFramebuffer",()=>Na,"bindColorTextureToFramebuffer",()=>Ns,"bindTextureToProgramUniformSampler",()=>Nr,"bindTextureUnit",()=>k9,"bindVertexBufferToProgramAttribute",()=>k7,"callAndCheck",()=>kG,"canBeRepresented",()=>kH,"createFragmentShader",()=>kY,"createFramebuffer",()=>k8,"createProgram",()=>kQ,"createStaticIndexBuffer",()=>k3,"createStaticVertexBuffer",()=>k2,"createTexture",()=>k5,"createVertexShader",()=>kX,"getBatchDim",()=>Np,"getExtensionOrThrow",()=>kK,"getFramebufferErrorMessage",()=>Nl,"getMaxTexturesInShader",()=>Nb,"getNumChannels",()=>k4,"getProgramUniformLocation",()=>Nn,"getProgramUniformLocationOrThrow",()=>Nt,"getRowsCols",()=>Nd,"getShapeAs3D",()=>Nc,"getTextureShapeFromLogicalShape",()=>Nf,"getWebGLDisjointQueryTimerVersion",()=>Nw,"getWebGLErrorMessage",()=>kq,"getWebGLMaxTextureSize",()=>Ng,"hasExtension",()=>Nv,"isCapableOfRenderingToFloatTexture",()=>NN,"isDownloadFloatTextureEnabled",()=>NI,"isReshapeFree",()=>Nm,"isWebGLFenceEnabled",()=>NC,"isWebGLVersionEnabled",()=>Nk,"linkProgram",()=>k0,"logShaderSourceAndInfoLog",()=>kJ,"resetMaxTextureSize",()=>Ny,"resetMaxTexturesInShader",()=>Nx,"unbindColorTextureFromFramebuffer",()=>Ni,"unbindTextureUnit",()=>Ne,"validateFramebuffer",()=>No,"validateProgram",()=>k1,"validateTextureSize",()=>k6],79383);let N$=tU;N$.registerFlag("HAS_WEBGL",()=>N$.getNumber("WEBGL_VERSION")>0),N$.registerFlag("WEBGL_VERSION",()=>Nk(2)?2:+!!Nk(1)),N$.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),N$.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===N$.get("WEBGL_VERSION")),N$.registerFlag("WEBGL_CPU_FORWARD",()=>!0),N$.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),N$.registerFlag("WEBGL_PACK",()=>N$.getBool("HAS_WEBGL")),N$.registerFlag("WEBGL_PACK_NORMALIZATION",()=>N$.getBool("WEBGL_PACK")),N$.registerFlag("WEBGL_PACK_CLIP",()=>N$.getBool("WEBGL_PACK")),N$.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>N$.getBool("WEBGL_PACK")),N$.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>N$.getBool("WEBGL_PACK")),N$.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>N$.getBool("WEBGL_PACK")),N$.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>N$.getBool("WEBGL_PACK")),N$.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>N$.getBool("WEBGL_PACK")),N$.registerFlag("WEBGL_PACK_REDUCE",()=>N$.getBool("WEBGL_PACK")),N$.registerFlag("WEBGL_LAZILY_UNPACK",()=>N$.getBool("WEBGL_PACK")),N$.registerFlag("WEBGL_CONV_IM2COL",()=>N$.getBool("WEBGL_PACK")),N$.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>N$.getBool("WEBGL_PACK")),N$.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>Ng(N$.getNumber("WEBGL_VERSION"))),N$.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>Nb(N$.getNumber("WEBGL_VERSION"))),N$.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let e=N$.getNumber("WEBGL_VERSION");return 0===e?0:Nw(e)}),N$.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>N$.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!kL.isMobile()),N$.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>NN(N$.getNumber("WEBGL_VERSION"))),N$.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!N$.getBool("WEBGL_FORCE_F16_TEXTURES")&&N$.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),N$.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>NI(N$.getNumber("WEBGL_VERSION"))),N$.registerFlag("WEBGL_FENCE_API_ENABLED",()=>NC(N$.getNumber("WEBGL_VERSION"))),N$.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>4*!!N$.getBool("WEBGL_RENDER_FLOAT32_ENABLED")),N$.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if("number"!=typeof e)throw Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)}),N$.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>kL.isMobile()?1:-1,e=>{if("number"!=typeof e)throw Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)}),N$.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),N$.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),N$.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),N$.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),N$.registerFlag("WEBGL_EXP_CONV",()=>!1),N$.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>N$.getBool("IS_TEST")),N$.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),N$.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),N$.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),N$.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);var lz=lz,b3=b3,ha=ha;function NE(){let e,t,n,r,a,s,i,o,l,u;return 2===tU.getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",a="texture",s="outputColor",i="out vec4 outputColor;",o=tU.getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(e="",t="attribute",n="varying",r="varying",a="texture2D",s="gl_FragColor",i="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:a,output:s,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}var lz=lz,ha=ha,lz=lz,ha=ha,ha=ha;function NA(e,t,n="index"){let r=ha.computeStrides(t);return r.map((t,a)=>{let s=`int ${e[a]} = ${n} / ${t}`,i=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${t}`:`index -= ${e[a]} * ${t}`;return`${s}; ${i};`}).join("")}function NR(e,t,n="index"){let r=ha.computeStrides(t);return r.map((t,a)=>{let s=`int ${e[a]} = ${n} / outShapeStrides[${a}]`,i=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * outShapeStrides[${a}]`:`index -= ${e[a]} * outShapeStrides[${a}]`;return`${s}; ${i};`}).join("")}function NF(e){let t=ha.computeStrides(e).map(e=>e.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function N_(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}let ND=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:NO}=lz,NM=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,NL=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Nz=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,NP=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function NB(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function NW(e){return`offset${e}`}function NU(e){let t=e.name,n=ha.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function Nj(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";else if(6===e)return"ivec6";else throw Error(`GPU for rank ${e} is not yet supported`)}function NV(e,t,n){let{newShape:r,keptDims:a}=ha.squeezeShape(t),s=t.length,i=e&&3===s&&1===t[0],o=i?t.slice(1):r,l=!e&&s>1&&!ha.arraysEqual(t,n)&&r.length<s||i,u=l?o:t;return{useSqueezeShape:l,uniformShape:u,keptDims:a}}function NG(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function NH(e,t){return t.map(t=>e[t]).join(", ")}function Nq(e,t,n){let r,a,s,i=[],o=[],l=null,u=null;for(let r of(u=e.getUniformLocation(n,"NAN",!1),1===tU.getNumber("WEBGL_VERSION")&&(l=e.getUniformLocation(n,"INFINITY",!1)),t.variableNames)){let a={name:r,uniform:e.getUniformLocation(n,r,!1),offset:e.getUniformLocation(n,`offset${r}`,!1)};t.enableShapeUniforms&&(a.shape=e.getUniformLocation(n,`${r}Shape`,!1),a.texShape=e.getUniformLocation(n,`${r}TexShape`,!1)),i.push(a)}if(t.enableShapeUniforms&&(r=e.getUniformLocation(n,"outShape",!1),s=e.getUniformLocation(n,"outShapeStrides",!1),a=e.getUniformLocation(n,"outTexShape",!1)),t.customUniforms)for(let r of t.customUniforms)o.push(e.getUniformLocation(n,r.name,!1));return{variablesLocations:i,customUniformLocations:o,infLoc:l,nanLoc:u,outShapeLocation:r,outShapeStridesLocation:s,outTexShapeLocation:a}}function NK(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((e,n)=>{let r=e.logicalShape,a=t[n],s=a.shape;if(!ha.arraysEqual(r,s))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${s} must match`);if(e.isUniform&&a.isUniform)return;let i=e.texShape,o=a.isUniform?null:a.texData.texShape;if(!ha.arraysEqual(i,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${o} must match`)})}function NX(e){return tU.getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class NY{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=M.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=NE();this.outputShape=e,this.enableShapeUniforms=NX(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?NR(["r","c","d"],e):NA(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}class NZ{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=M.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=NE();this.outputShape=e,this.enableShapeUniforms=NX(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?NR(["r","c","d"],e):NA(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}class NJ{constructor(e){this.variableNames=["A"],this.outTexUsage=L.DOWNLOAD;const t=NE();this.outputShape=e,this.userCode=`
      ${ND}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}class NQ{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=L.DOWNLOAD;const t=NE();this.outputShape=e,this.userCode=`
      ${ND}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}let N0={R:0,G:1,B:2,A:3};class N1{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=NE();this.outputShape=e,this.enableShapeUniforms=NX(this.outputShape.length);let a="result";t&&(a="floor(result * 255. + 0.5)");let s="";for(let e=0;e<n.length;e++){const t=n[e];s+=`
          if(offset == ${e}) {
            result = values[${N0[t]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?N_():NF(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${n.length});

        flatIndex = idiv(flatIndex, ${n.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${s}
        }
        ${r.output} = vec4(${a}, 0., 0., 0.);
      }
    `}}class N2{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=NE();this.outputShape=e,this.enableShapeUniforms=NX(this.outputShape.length);let r="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let t=0;t<=1;t++)for(let a=0;a<=1;a++){const s=2*t+a;r+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${t} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${t};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${s}] = values[0];
            } else if (offset == 1) {
              result[${s}] = values[1];
            } else if (offset == 2) {
              result[${s}] = values[2];
            } else {
              result[${s}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?N_():NF(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${n.output} = ${a};
        }
    `}}var ha=ha;function N3(e){let t=NE();return kX(e,`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`)}function N4(e){return k2(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function N5(e){return k3(e,new Uint16Array([0,1,2,2,1,3]))}function N6(e,t,n,r,a,s){k6(t,n);let i=k5(e),o=e.TEXTURE_2D;return kG(e,()=>e.bindTexture(o,i)),kG(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),kG(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),kG(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),kG(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),1===tU.getNumber("WEBGL_VERSION")?kG(e,()=>e.texImage2D(o,0,r,t,n,0,a,s,null)):kG(e,()=>e.texStorage2D(o,1,r,t,n)),kG(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:i,texShape:[n,t]}}function N8(e){return e.internalFormatFloat}function N7(e,t,n,r){let[a,s]=[n,t];return N6(e,a,s,N8(r),r.textureFormatFloat,e.FLOAT)}function N9(e){return e.internalFormatHalfFloat}function Ie(e,t,n,r){let[a,s]=[n,t];return N6(e,a,s,N9(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function It(e){return e.downloadTextureFormat}function In(e,t,n,r){let[a,s]=[n,t];return N6(e,a,s,It(r),e.RGBA,e.UNSIGNED_BYTE)}function Ir(e){return e.internalFormatPackedFloat}function Ia(e,t,n,r){let[a,s]=kj(t,n);return N6(e,a,s,Ir(r),e.RGBA,e.FLOAT)}function Is(e){return e.internalFormatPackedHalfFloat}function Ii(e,t,n,r){let[a,s]=kj(t,n);return N6(e,a,s,Is(r),e.RGBA,r.textureTypeHalfFloat)}function Io(e,t,n){return kG(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),k7(e,t,"clipSpacePos",n,3,20,0)&&k7(e,t,"uv",n,2,20,12)}function Il(e,t,n,r,a,s){let i,o,l;kG(e,()=>e.bindTexture(e.TEXTURE_2D,t)),a instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,l=s.internalFormatPackedFloat),i.set(a),2===tU.getNumber("WEBGL_VERSION")?kG(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i)):kG(e,()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,i)),kG(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function Iu(e,t,n){kG(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?2===tU.getNumber("WEBGL_VERSION")?kG(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):kG(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):2===tU.getNumber("WEBGL_VERSION")?kG(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):kG(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),kG(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function Ih(e,t,n,r){let a=e.createBuffer();kG(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,a));let s=16*t*n;return kG(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ)),kG(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),kG(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),a}function Ip(e,t,n){let r=new Float32Array(n);return e.bindBuffer(e.PIXEL_PACK_BUFFER,t),e.getBufferSubData(e.PIXEL_PACK_BUFFER,0,r),e.bindBuffer(e.PIXEL_PACK_BUFFER,null),r}function Id(e,t,n,r){let[a,s]=[n,t],i=new Uint8Array(t*n*4);return kG(e,()=>e.readPixels(0,0,a,s,r.downloadTextureFormat,e.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}function Ic(e,t,n,r,a,s,i,o){let l=new Float32Array(function(e,t){let[n,r]=kj(e,t);return n*r*4}(s,i));return e.bindBuffer(e.PIXEL_PACK_BUFFER,t),e.getBufferSubData(e.PIXEL_PACK_BUFFER,0,l),e.bindBuffer(e.PIXEL_PACK_BUFFER,null),l}function If(e,t,n){let r=new Float32Array(t*n*4);return kG(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r)),r}e.s(["bindVertexProgramAttributeStreams",()=>Io,"createBufferFromOutputTexture",()=>Ih,"createFloat16MatrixTexture",()=>Ie,"createFloat16PackedMatrixTexture",()=>Ii,"createFloat32MatrixTexture",()=>N7,"createIndexBuffer",()=>N5,"createPackedMatrixTexture",()=>Ia,"createUnsignedBytesMatrixTexture",()=>In,"createVertexBuffer",()=>N4,"createVertexShader",()=>N3,"downloadByteEncodedFloatMatrixFromOutputTexture",()=>Id,"downloadFloat32MatrixFromBuffer",()=>Ip,"downloadMatrixFromPackedOutputTexture",()=>If,"downloadPackedMatrixFromBuffer",()=>Ic,"getInternalFormatForFloat16MatrixTexture",()=>N9,"getInternalFormatForFloat16PackedMatrixTexture",()=>Is,"getInternalFormatForFloat32MatrixTexture",()=>N8,"getInternalFormatForPackedMatrixTexture",()=>Ir,"getInternalFormatForUnsignedBytesMatrixTexture",()=>It,"uploadDenseMatrixToTexture",()=>Il,"uploadPixelDataToTexture",()=>Iu],97604);class Im{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=tU.getNumber("WEBGL_VERSION");if(null!=e){var n;this.gl=e,n=e,kz[t]=n}else this.gl=kW(t);if(e=this.gl,2===tU.getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>kG(t,()=>t.createVertexArray()),this.bindVertexArray=e=>kG(t,()=>t.bindVertexArray(e)),this.deleteVertexArray=e=>kG(t,()=>t.deleteVertexArray(e)),this.getVertexArray=()=>kG(t,()=>t.getParameter(t.VERTEX_ARRAY_BINDING))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>kG(e,()=>t.createVertexArrayOES()),this.bindVertexArray=n=>kG(e,()=>t.bindVertexArrayOES(n)),this.deleteVertexArray=n=>kG(e,()=>t.deleteVertexArrayOES(n)),this.getVertexArray=()=>kG(e,()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const a="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===tU.getNumber("WEBGL_VERSION")){const e="OES_texture_half_float";if(this.textureFloatExtension=kK(this.gl,"OES_texture_float"),Nv(this.gl,e))this.textureHalfFloatExtension=kK(this.gl,e);else if(tU.get("WEBGL_FORCE_F16_TEXTURES"))throw Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),Nv(this.gl,a))this.colorBufferHalfFloatExtension=kK(this.gl,a);else if(tU.get("WEBGL_FORCE_F16_TEXTURES"))throw Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",Nv(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(Nv(this.gl,a))this.colorBufferHalfFloatExtension=this.gl.getExtension(a);else throw Error("GL context does not support color renderable floats");this.vertexBuffer=N4(this.gl),this.indexBuffer=N5(this.gl),this.framebuffer=k8(this.gl),this.textureConfig=kV(this.gl,this.textureHalfFloatExtension)}get debug(){return tU.getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;kG(e,()=>e.finish()),kG(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),kG(e,()=>e.deleteFramebuffer(this.framebuffer)),kG(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),kG(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),kG(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),N7(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),Ie(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),In(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),Iu(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),Il(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),Ii(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),Ia(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(Ni(this.gl,this.framebuffer),this.outputTexture=null),kG(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>Id(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,r,a,s){return Ic(this.gl,e,t,n,r,a,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return Ip(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let r=Ih(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(tU.getBool("WEBGL_FENCE_API_ENABLED")){let r=e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let t=e.clientWaitSync(r,0,0);return t===e.ALREADY_SIGNALED||t===e.CONDITION_SATISFIED},t=r}else tU.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,tU.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>If(this.gl,t,n))}createProgram(e){this.throwIfDisposed();let t=this.gl;null==this.vertexShader&&(this.vertexShader=N3(t));let n=kQ(t);kG(t,()=>t.attachShader(n,this.vertexShader)),kG(t,()=>t.attachShader(n,e)),k0(t,n);let r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&k1(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);let t=this.gl;kG(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),Io(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(kG(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&k1(this.gl,this.program),kG(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return(this.throwIfDisposed(),n)?Nt(this.gl,e,t):Nn(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),kG(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),Nr(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[r,a]=kj(t,n);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&k1(this.gl,this.program),No(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;this.debug&&(console.assert(this.getVertexArray()===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()),kG(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),kG(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=kK(this.gl,2===tU.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===tU.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===tU.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let e=this.gl,t=this.getQueryTimerExtensionWebGL2();e.endQuery(t.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await ha.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,tU.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,tU.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){let t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{let t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){let t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{let t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=function(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){let n;this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1||("setTimeoutCustom"in tU.platform&&(n=tU.platform.setTimeoutCustom.bind(tU.platform)),ha.repeatedTry(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,n))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Ns(this.gl,e,this.framebuffer),this.debug&&No(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(Ns(this.gl,this.outputTexture,this.framebuffer),this.debug&&No(this.gl)):Ni(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let r=this.gl;Ns(r,e,this.framebuffer),this.debug&&No(r),this.outputTexture=e,kG(r,()=>r.viewport(0,0,t,n)),kG(r,()=>r.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),kG(this.gl,()=>this.gl.scissor(e,t,n,r))}throwIfDisposed(){if(this.disposed)throw Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw Error("No GPU program is currently set.")}}let{addImpl:Ig,bincountImpl:Iy,bincountReduceImpl:Ix,bitwiseAndImpl:Ib,castImpl:Iw,ceilImpl:Iv,concatImpl:Ik,equalImpl:IN,expImpl:II,expm1Impl:IS,floorImpl:IC,gatherNdImpl:IT,gatherV2Impl:I$,greaterImpl:IE,greaterEqualImpl:IA,lessImpl:IR,lessEqualImpl:IF,linSpaceImpl:I_,logImpl:ID,maxImpl:IO,maximumImpl:IM,minimumImpl:IL,multiplyImpl:Iz,negImpl:IP,notEqualImpl:IB,prodImpl:IW,raggedGatherImpl:IU,raggedRangeImpl:Ij,raggedTensorToTensorImpl:IV,rangeImpl:IG,rsqrtImpl:IH,scatterImpl:Iq,sigmoidImpl:IK,simpleAbsImpl:IX,sliceImpl:IY,sparseFillEmptyRowsImpl:IZ,sparseReshapeImpl:IJ,sparseSegmentReductionImpl:IQ,sqrtImpl:I0,staticRegexReplaceImpl:I1,stridedSliceImpl:I2,stringNGramsImpl:I3,stringSplitImpl:I4,stringToHashBucketFastImpl:I5,subImpl:I6,tileImpl:I8,topKImpl:I7,transposeImpl:I9,uniqueImpl:Se}=v$;function St(e,t){return["x","y","z","w","u","v"].slice(0,t).map(t=>`${e}.${t}`)}function Sn(e,t){return 1===t?[e]:St(e,t)}class Sr{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=NX(this.outputShape.length),0===this.rank)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const e=Sn("rc",this.rank),t=Nj(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),a=this.getOutput(e);this.userCode=`
        void main() {
          ${t} rc = getOutputCoords();

          if(${n}) {
            setOutput(vec4(0));
          } else {
            ${r}

            setOutput(vec4(${a}));
          }
        }
      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let a=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let t=2;t<this.rank;t++)a=`${e[e.length-1-t]},`+a;t.push(a)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){let t=this.getSourceCoordsArr(e);if(1===this.rank){let e=this.enableShapeUniforms?"outShape":this.outputShape[0];return`getA(rc), (rc + 1 >= ${e} ? 0. : getA(rc + 1)), 0, 0`}return`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}class Sa{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=NX(this.outputShape.length);let n="";for(let e=0;e<4;e++){let t="thisRC = rc;";e%2==1&&(t+="thisRC.z += 1;"),e>1&&(t+="thisRC.y += 1;"),n+=`
        ${t}
        ${e>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${e}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${e>0?"}":""}
      `}this.userCode=`
      ${function(e,t){let n=t?function(e,t,n="index"){let r=function(e,t){let n=e.length,r=e.map(e=>`${t}[${e}]`),a=Array(n-1);a[n-2]=r[n-1];for(let e=n-3;e>=0;--e)a[e]=`(${a[e+1]} * ${r[e+1]})`;return a}(e.map((e,t)=>t),t);return r.map((t,a)=>{let s=`int ${e[a]} = ${n} / ${r[a]}`,i=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${r[a]}`:`index -= ${e[a]} * ${r[a]}`;return`${s}; ${i};`}).join("")}(["r","c","d"],"inputShape"):NA(["r","c","d"],e);return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${n}
      return ivec3(r, c, d);
    }
  `}(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?N_():NF(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${n}

        setOutput(result);
      }
    `}}class Ss{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){let r,a=So(t,n),s=Sl(e,a,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);let i=Si(e,a,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();let e=this.freeTextures[s].pop();return this.usedTextures[s].push(e),e}return a===z.PACKED_2X2_FLOAT32?r=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):a===z.PACKED_2X2_FLOAT16?r=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):a===z.UNPACKED_FLOAT32?r=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):a===z.UNPACKED_FLOAT16?r=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):a===z.PACKED_4X1_UNSIGNED_BYTE&&(r=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(r),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),r}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;let a=So(n,r),s=Sl(t,a,r);s in this.freeTextures||(this.freeTextures[s]=[]);let i=Si(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=tU.getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let l=this.usedTextures[s],u=l&&l.indexOf(e);if(null==u||u<0)throw Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(let e in this.freeTextures)this.freeTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(let e in this.usedTextures)this.usedTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function Si(e,t,n,r,a){let s,i=function(e,t){switch(e){case z.PACKED_2X2_FLOAT32:return Ir(t);case z.PACKED_2X2_FLOAT16:return Is(t);case z.UNPACKED_FLOAT32:return N8(t);case z.UNPACKED_FLOAT16:return N9(t);case z.PACKED_4X1_UNSIGNED_BYTE:return It(t);default:throw Error(`Unknown physical texture type ${e}`)}}(t,r);if(a){let[t,n]=kj(e[0],e[1]);s=t*n}else{var o;let[t,n]=(o=e[0],[e[1],o]);s=t*n}return s*function(e,t){if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===e.RGBA16F)return 8;else if(t===e.RGBA8)return 4;throw Error(`Unknown internal format ${t}`)}(n,i)}function So(e,t){if(e===L.UPLOAD)return z.PACKED_2X2_FLOAT32;if(e===L.RENDER||null==e)return tU.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?z.PACKED_2X2_FLOAT32:z.UNPACKED_FLOAT32:t?z.PACKED_2X2_FLOAT16:z.UNPACKED_FLOAT16;if(e===L.DOWNLOAD||e===L.PIXELS)return z.PACKED_4X1_UNSIGNED_BYTE;throw Error(`Unknown logical texture type ${e}`)}function Sl(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class Su{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=NX(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}let Sh="if (isnan(x)) return x;",Sp="return abs(x);",Sd=Sh+`
  return (x < 0.0) ? 0.0 : x;
`,Sc=Sh+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Sf="return x;",Sm=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Sg=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Sy=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;class Sx{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=NX(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}class Sb{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=NX(this.outputShape.length);const t=e.length,n=Sn("rc",t),r=Nj(t),a=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),s=n.slice(-2),i=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${a});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}}let Sw=b3.whereImpl,Sv={},Sk=tU.getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class SN extends e0{nextDataId(){return SN.nextDataId++}constructor(e){let t;if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!tU.getBool("HAS_WEBGL"))throw Error("WebGL is not supported on this device");null!=e?(t=e instanceof Im?e:new Im(kW(tU.getNumber("WEBGL_VERSION"),e)),this.binaryCache={},this.gpgpuCreatedLocally=!1):(t=new Im(kW(tU.getNumber("WEBGL_VERSION"))),this.binaryCache=function(e){return e in Sv||(Sv[e]={}),Sv[e]}(tU.getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0),this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Ss(this.gpgpu),this.numMBBeforeWarning=null==tU.global.screen?1024:tU.global.screen.height*tU.global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new eQ(this,aH)}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,r,a,s){let i=this.makeTensorInfo(t,n),o=this.texData.get(i.dataId);o.isPacked=!1,o.texture={texture:e,texShape:[r,a]},o.texShape=[r,a];let l=new N1(Nc(t),!1,s),u=this.runWebGLProgram(l,[i],n,[[r,a]]);return u.shape=t,o.texture=null,this.disposeIntermediateTensorInfo(i),u.dataId}write(e,t,n){if((tU.getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||tU.getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:L.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){let t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){let t=this.texData.get(e);t.refCount--}}move(e,t,n,r,a){if(tU.getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:L.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let t,n,{values:r,dtype:a,complexTensorInfos:s,slice:i,shape:o,isPacked:l}=this.texData.get(e);if(null!=i){let t;t=l?new Sx(o,Sf):new Su(o,Sf);let n=this.runWebGLProgram(t,[{dataId:e,shape:o,dtype:a}],a),r=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=r)return this.convertAndCacheOnCPU(e);if("string"===a)return r;let u=null!=this.activeTimers;if(u&&(t=ha.now()),"complex64"===a){let e=this.readSync(s.real.dataId),t=this.readSync(s.imag.dataId);n=lz.mergeRealAndImagArrays(e,t)}else n=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=ha.now()-t),this.convertAndCacheOnCPU(e,n)}async read(e){let t,n;if(this.pendingRead.has(e)){let t=this.pendingRead.get(e);return new Promise(e=>t.push(e))}let{values:r,shape:a,slice:s,dtype:i,complexTensorInfos:o,isPacked:l}=this.texData.get(e);if(null!=s){let t;t=l?new Sx(a,Sf):new Su(a,Sf);let n=this.runWebGLProgram(t,[{dataId:e,shape:a,dtype:i}],i),r=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=r)return this.convertAndCacheOnCPU(e);if(tU.getBool("DEBUG")&&!tU.getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===tU.getNumber("WEBGL_VERSION"))throw Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null;if("complex64"!==i&&tU.get("WEBGL_BUFFER_SUPPORTED")){t=this.decode(e);let n=this.texData.get(t.dataId);u=this.gpgpu.createBufferFromTexture(n.texture.texture,...kU(a))}if(this.pendingRead.set(e,[]),"complex64"!==i&&await this.gpgpu.createAndWaitForFence(),"complex64"===i){let e=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),t=e[0],r=e[1];n=lz.mergeRealAndImagArrays(t,r)}else if(null==u)n=this.getValuesFromTexture(e);else{let e=ha.sizeFromShape(a);n=this.gpgpu.downloadFloat32MatrixFromBuffer(u,e)}if(null!=t&&this.disposeIntermediateTensorInfo(t),null!=u){let e=this.gpgpu.gl;kG(e,()=>e.deleteBuffer(u))}let h=this.convertAndCacheOnCPU(e,n),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach(e=>e(h)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&aH.removeDataId(e,this),this.pendingDeletes--),h}readToGPU(e,t={}){let{values:n,shape:r,slice:a,dtype:s,isPacked:i,texture:o}=this.texData.get(e);if("complex64"===s)throw Error("Does not support reading texture for complex64 dtype.");if(null!=a){let n;n=i?new Sx(r,Sf):new Su(r,Sf);let a=this.runWebGLProgram(n,[{dataId:e,shape:r,dtype:s}],s),o=this.readToGPU(a,t);return this.disposeIntermediateTensorInfo(a),o}if(null==o)if(null!=n)throw Error("Data is not on GPU but on CPU.");else throw Error("There is no data on GPU or CPU.");let l=this.decode(e,t.customTexShape);return Object.assign({tensorRef:aH.makeTensorFromTensorInfo(l)},this.texData.get(l.dataId).texture)}bufferSync(e){let t=this.readSync(e.dataId);if("string"===e.dtype)try{let n=t.map(e=>ha.decodeString(e));return sW(e.shape,e.dtype,n)}catch(e){throw Error("Failed to decode encoded string bytes into utf-8")}return sW(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){let n=e[t];if(!kH(n)){if(tU.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){let{shape:t,dtype:n,isPacked:r}=this.texData.get(e),a=ha.sizeFromShape(t);if(tU.getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let n=this.decode(e),r=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...kU(t)).subarray(0,a);return this.disposeIntermediateTensorInfo(n),s}let s=tU.getBool("WEBGL_PACK")&&!0===r,i=s?Nc(t):t,o=s?new NQ(i):new NJ(i),l=this.runWebGLProgram(o,[{shape:i,dtype:n,dataId:e}],"float32"),u=this.texData.get(l.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(l),h}timerAvailable(){return tU.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){let t=this.activeTimers,n=[],r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();let a=ha.flatten(this.activeTimers.map(e=>e.query)).filter(e=>null!=e),s=ha.flatten(this.activeTimers.map(e=>e.name)).filter(e=>null!=e);this.activeTimers=t,r&&(this.programTimersStack=null);let i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(tU.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let e=await Promise.all(a);i.kernelMs=ha.sum(e),i.getExtraProfileInfo=()=>e.map((e,t)=>({name:s[t],ms:e})).map(e=>`${e.name}: ${e.ms}`).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return tU.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:ha.now(),endMs:null}}endTimer(e){return tU.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.endQuery():e.endMs=ha.now(),e}async getQueryTime(e){return tU.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:t,dtype:n,texShape:r,usage:a,isPacked:s,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,a,s)));let u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=Sk){return tU.getBool("WEBGL_CPU_FORWARD")&&e.every(e=>null==this.texData.get(e.dataId).texture&&ha.sizeFromShape(e.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){lz.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let t=e.dataSync();return Sw(e.shape,t)}packedUnaryOp(e,t,n){let r=new Sx(e.shape,t),a=this.compileAndRun(r,[e],n);return aH.makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){let t=IX(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(tU.getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Sp,e.dtype);let t=new Su(e.shape,Sp),n=this.compileAndRun(t,[e]);return aH.makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&ha.isString(n[0])){let a=n.map(e=>ha.encodeString(e));r=this.write(a,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return aH.makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){let t=new Sb(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){let t=new Sr(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){let n=[Np(e.shape),...Nd(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},a=new Sa([Np(t),...Nd(t)],n),s=this.runWebGLProgram(a,[r],e.dtype,[n],!0);return{dataId:s.dataId,shape:t,dtype:s.dtype}}decode(e,t){let n,{isPacked:r,shape:a,dtype:s}=this.texData.get(e);if(null!=t){let e=ha.sizeFromShape(a),n=t[0]*t[1]*4;ha.assert(e<=n,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let i=Nc(a);n=r?new NZ(i):new NY(i);let o=[null!=t?t:kU(i)],l=this.runWebGLProgram(n,[{shape:i,dtype:s,dataId:e}],s,o,!0,t);return{dtype:s,shape:a,dataId:l.dataId}}runWebGLProgram(e,t,n,r,a=!1,s){let i,o,l,u=this.makeTensorInfo(e.outputShape,n),h=this.texData.get(u.dataId);if(e.packedOutput&&(h.isPacked=!0),e.outPackingScheme===M.DENSE&&(h.texShape=(null!=s?s:kU(e.outputShape)).map(e=>2*e)),null!=e.outTexUsage&&(h.usage=e.outTexUsage),0===ha.sizeFromShape(u.shape))return h.values=ha.getTypedArrayFromDType(u.dtype,0),u;let p=[],d=t.map(t=>{if("complex64"===t.dtype)throw Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&ha.sizeFromShape(t.shape)<=tU.getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),p.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!Nm(n.shape,t.shape)){let e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),p.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}});this.uploadToGPU(u.dataId);let c={shape:u.shape,texData:h,isUniform:!1},f=(o="",d.concat(c).forEach(t=>{let n=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){let r=t.texData.texShape,{useSqueezeShape:a,uniformShape:s,keptDims:i}=NV(e.packedInputs,t.shape,r),l="",u="",h="";if(1===s.length&&e.packedInputs){let e=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];l=`${e[0]>1}_${e[1]>1}`}else if(2!==s.length||e.packedInputs){if(s.length>2&&!e.packedInputs){let e=ha.computeStrides(s);h=`${e[0]===r[1]}_${e[e.length-1]===r[1]}`}}else u=`${s[0]>1}_${s[1]>1}`;let p=t.shape.length,d=2===s.length&&ha.arraysEqual(t.shape,r),f=1===ha.sizeFromShape(t.shape),m=lz.getBroadcastDims(t.shape,c.shape),g=!e.packedInputs&&p===c.shape.length&&ha.arraysEqual(r,c.texData.texShape),y=e.packedInputs||s.length>2?"":`${r[0]>1}_${r[1]>1}`;o+=`${p}_${g}_${a?i:""}_${s.length}_${f}_${m}_${d}_${l}_${u}_${h}_${y}_${n}`}else{let e=t.isUniform?"uniform":t.texData.texShape;o+=`${t.shape}_${e}_${n}`}}),l=e.userCode,e.constructor.name+("_"+o+"_"+l)+`${tU.getNumber("WEBGL_VERSION")}`),m=this.getAndSaveBinary(f,()=>{var t;let n,r,a,s,i,o;return t=this.gpgpu,r=(n=d.map((t,n)=>{let r={logicalShape:t.shape,texShape:t.isUniform?null:t.texData.texShape,isUniform:t.isUniform,isPacked:!t.isUniform&&t.texData.isPacked,flatOffset:null};return null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0&&(r.flatOffset=t.texData.slice.flatOffset),{name:e.variableNames[n],shapeInfo:r}})).map(e=>e.shapeInfo),s=function(e,t,n){var r,a,s,i;let o,l,u=[];if(e.forEach(e=>{let t=ha.sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?u.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(u.push(`uniform sampler2D ${e.name};`),u.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){let{uniformShape:t}=NV(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:u.push(`uniform int ${e.name}Shape;`);break;case 2:u.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:u.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:u.push(`uniform ivec4 ${e.name}Shape;`)}u.push(`uniform ivec2 ${e.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:u.push("uniform int outShape;");break;case 2:u.push("uniform ivec2 outShape;"),u.push("uniform int outShapeStrides;");break;case 3:u.push("uniform ivec3 outShape;"),u.push("uniform ivec2 outShapeStrides;");break;case 4:u.push("uniform ivec4 outShape;"),u.push("uniform ivec3 outShapeStrides;")}u.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(e=>{u.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)});let h=u.join("\n"),p=e.map(e=>(function(e,t,n=!1,r){let a="";n?a+=function e(t,n){switch(t.shapeInfo.logicalShape.length){case 0:let r,a,s;return a="get"+(r=t.name).charAt(0).toUpperCase()+r.slice(1),s=NE(),`
    vec4 ${a}() {
      return ${s.texture2D}(${r}, halfCR);
    }
  `;case 1:return function(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=e.shapeInfo.texShape,s=NE();if(t)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${n}, uv);
    }
  `;let i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${s.texture2D}(${n}, uv);
    }
  `}(t,n);case 2:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=s[0],o=s[1],l=NE();if(null!=s&&ha.arraysEqual(n,s))return t?`
      vec4 ${a}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${a}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(t)return`
    vec4 ${a}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;let u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],h=Math.ceil(n[1]/2);return`
    vec4 ${a}(int row, int col) {
      vec2 uv = packedUVfrom2D(${h}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}(t,n);case 3:return function(t,n){let r=t.shapeInfo.logicalShape,a=t.name,s="get"+a.charAt(0).toUpperCase()+a.slice(1),i=t.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(1===r[0]){let a=NG(t,r.slice(1));return`
        ${e(a,n)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${NH(["b","row","col"],[1,2])});
        }
      `}let l=NE();if(n)return`
    vec4 ${s}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${a}TexShape[0]) / 2.0), ceil(float(${a}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${a}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${a}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${l.texture2D}(${a}, uv);
    }
  `;let u=o[0],h=o[1],p=Math.ceil(r[2]/2),d=p*Math.ceil(r[1]/2);return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${h}, ${d}, ${p}, b, row, col);
      return ${l.texture2D}(${a}, uv);
    }
  `}(t,n);default:return function(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=NE();if(t)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${a.texture2D}(${n}, uv);
    }
  `;let s=e.shapeInfo.logicalShape,i=s.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],h=l[1],p=Math.ceil(s[i-1]/2),d=p*Math.ceil(s[i-2]/2),c="int b, int row, int col",f=`b * ${d} + (row / 2) * ${p} + (col / 2)`;for(let e=2;e<i-1;e++)c=`int b${e}, `+c,d*=s[i-e-1],f=`b${e} * ${d} + `+f;return`
    vec4 ${r}(${c}) {
      int index = ${f};
      int texR = index / ${h};
      int texC = index - texR * ${h};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}, ${u});
      return ${a.texture2D}(${n}, uv);
    }
  `}(t,n)}}(e,r):a+=function e(t,n=!1){let r=t.shapeInfo.logicalShape;switch(r.length){case 0:return function(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;let[a,s]=e.shapeInfo.texShape;if(1===a&&1===s)return`
      float ${r}() {
        return sampleTexture(${n}, halfCR);
      }
    `;let i=NW(n);if(t)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});
      return sampleTexture(${n}, uv);
    }
  `;let[o,l]=e.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${o}, ${l}, ${i});
      return sampleTexture(${n}, uv);
    }
  `}(t,n);case 1:return function(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${NU(e)}
      }
    `;let a=e.shapeInfo.texShape,s=a[0],i=a[1];if(1===i&&1===s)return`
      float ${r}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;let o=NW(n);return 1===i?t?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);
        return sampleTexture(${n}, uv);
      }
    `:1===s?t?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:t?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${s}, ${i}, index + ${o});
      return sampleTexture(${n}, uv);
    }
  `}(t,n);case 2:return function(t,n){let r=t.shapeInfo.logicalShape,a=t.name,s="get"+a.charAt(0).toUpperCase()+a.slice(1),i=t.shapeInfo.texShape;if(null!=i&&ha.arraysEqual(r,i)){if(n)return`
      float ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `;let e=i[0],t=i[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${t}.0, ${e}.0);
      return sampleTexture(${a}, uv);
    }
  `}let{newShape:o,keptDims:l}=ha.squeezeShape(r);if(o.length<r.length){let r=NG(t,o);return`
      ${e(r,n)}
      float ${s}(int row, int col) {
        return ${s}(${NH(["row","col"],l)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${r[1]}, 1)));
        ${NU(t)}
      }
    `;let u=i[0],h=i[1],p=NW(a);return 1===h?n?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${a}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${a}TexShape[0]));
        return sampleTexture(${a}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${r[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${a}, uv);
    }
  `:1===u?n?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${a}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${a}TexShape[1]), 0.5);
        return sampleTexture(${a}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${r[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${h}.0, 0.5);
      return sampleTexture(${a}, uv);
    }
  `:n?`
      float ${s}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index);
        return sampleTexture(${a}, uv);
      }
    `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${r[1]} + col + ${p};
    vec2 uv = uvFromFlat(${u}, ${h}, index);
    return sampleTexture(${a}, uv);
  }
`}(t,n);case 3:return function(t,n){let r=t.shapeInfo.logicalShape,a=t.name,s="get"+a.charAt(0).toUpperCase()+a.slice(1),i=r[1]*r[2],o=r[2],{newShape:l,keptDims:u}=ha.squeezeShape(r);if(l.length<r.length){let r=NG(t,l);return`
        ${e(r,n)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${NH(["row","col","depth"],u)});
        }
      `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${i}, ${o}, 1)));
        ${NU(t)}
      }
    `;let h=t.shapeInfo.texShape,p=h[0],d=h[1],c=t.shapeInfo.flatOffset;if(d===i&&null==c)return n?`
      float ${s}(int row, int col, int depth) {
        int stride1 = ${a}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${p}.0);
          return sampleTexture(${a}, uv);
        }
      `;if(d===o&&null==c)return n?`
      float ${s}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${a}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${r[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${p}.0);
      return sampleTexture(${a}, uv);
    }
  `;let f=NW(a);return n?`
    float ${s}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${a}Shape[1] * ${a}Shape[2];
      int stride1 = ${a}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index);
      return sampleTexture(${a}, uv);
    }
    `:`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i} + col * ${o} + depth + ${f};
        vec2 uv = uvFromFlat(${p}, ${d}, index);
        return sampleTexture(${a}, uv);
      }
  `}(t,n);case 4:return function(t,n){let r=t.shapeInfo.logicalShape,a=t.name,s="get"+a.charAt(0).toUpperCase()+a.slice(1),i=r[3],o=r[2]*i,l=r[1]*o,{newShape:u,keptDims:h}=ha.squeezeShape(r);if(u.length<r.length){let r=NG(t,u);return`
      ${e(r,n)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${NH(["row","col","depth","depth2"],h)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${l}, ${o}, ${i}, 1)));
        ${NU(t)}
      }
    `;let p=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,c=d[0],f=d[1],m=`int stride2 = ${a}Shape[3];`,g=`int stride1 = ${a}Shape[2] * stride2;`,y=`int stride0 = ${a}Shape[1] * stride1;`;if(f===l&&null==p)return n?`
      float ${s}(int row, int col, int depth, int depth2) {
        ${m}
        ${g}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${c}.0);
        return sampleTexture(${a}, uv);
      }
    `;if(f===i&&null==p)return n?`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${a}Shape[1] * ${a}Shape[2], ${a}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r[1]*r[2]}, ${r[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${c}.0);
        return sampleTexture(${a}, uv);
      }
    `;let x=NW(a);return n?`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${m}
      ${g}
      ${y}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index + ${x});
      return sampleTexture(${a}, uv);
    }
  `:`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${l} + col * ${o} +
          depth * ${i} + depth2;
      vec2 uv = uvFromFlat(${c}, ${f}, index + ${x});
      return sampleTexture(${a}, uv);
    }
  `}(t,n);case 5:return function(t){let n=t.shapeInfo.logicalShape,r=t.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[4],i=n[3]*s,o=n[2]*i,l=n[1]*o,{newShape:u,keptDims:h}=ha.squeezeShape(n);if(u.length<n.length){let n=NG(t,u);return`
      ${e(n)}
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        return ${a}(${NH(["row","col","depth","depth2","depth3"],h)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${l}, ${o}, ${i}, ${s})) +
          depth3;
        ${NU(t)}
      }
    `;let p=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,c=d[0],f=d[1];if(f===l&&null==p)return`
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${c}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(f===s&&null==p)return`
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${n[1]*n[2]*n[3]},
               ${n[2]*n[3]}, ${n[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${c}.0);
        return sampleTexture(${r}, uv);
      }
    `;let m=NW(r);return`
    float ${a}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${l} + col * ${o} + depth * ${i} +
          depth2 * ${s} + depth3 + ${m};
      vec2 uv = uvFromFlat(${c}, ${f}, index);
      return sampleTexture(${r}, uv);
    }
  `}(t);case 6:return function(t){let n=t.shapeInfo.logicalShape,r=t.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),{newShape:s,keptDims:i}=ha.squeezeShape(n);if(s.length<n.length){let n=NG(t,s);return`
      ${e(n)}
      float ${a}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${a}(${NH(["row","col","depth","depth2","depth3","depth4"],i)});
      }
    `}let o=n[5],l=n[4]*o,u=n[3]*l,h=n[2]*u,p=n[1]*h;if(t.shapeInfo.isUniform)return`
      float ${a}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${p}, ${h}, ${u}, ${l})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${NU(t)}
      }
    `;let d=t.shapeInfo.flatOffset,c=t.shapeInfo.texShape,f=c[0],m=c[1];if(m===p&&null==d)return`
      float ${a}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${h}, ${u}, ${l}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${m}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(m===o&&null==d)return`
      float ${a}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${n[1]*n[2]*n[3]*n[4]},
               ${n[2]*n[3]*n[4]},
               ${n[3]*n[4]},
               ${n[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${m}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;let g=NW(r);return`
    float ${a}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${p} + col * ${h} + depth * ${u} +
          depth2 * ${l} + depth3 * ${o} + depth4 + ${g};
      vec2 uv = uvFromFlat(${f}, ${m}, index);
      return sampleTexture(${r}, uv);
    }
  `}(t);default:throw Error(`${r.length}-D input sampling is not yet supported`)}}(e,r);let s=e.shapeInfo.logicalShape,i=t.logicalShape;return s.length<=i.length&&(n?a+=function(e,t){let n,r=e.name,a=r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=NO(e.shapeInfo.logicalShape,t.logicalShape),l=Nj(i),u=i-s,h=["x","y","z","w","u","v"];n=0===s?"":i<2&&o.length>=1?"coords = 0;":o.map(e=>`coords.${h[e+u]} = 0;`).join("\n");let p="";p=i<2&&s>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>`coords.${h[t+u]}`).join(", ");let d="return outputValue;",c=1===ha.sizeFromShape(e.shapeInfo.logicalShape),f=1===ha.sizeFromShape(t.logicalShape);if(1!==s||c||f){if(c&&!f)d=1===i?`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:`
        return vec4(outputValue.x);
      `;else if(o.length){let e=s-2,t=s-1;o.indexOf(e)>-1&&o.indexOf(t)>-1?d="return vec4(outputValue.x);":o.indexOf(e)>-1?d="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(t)>-1&&(d="return vec4(outputValue.xx, outputValue.zz);")}}else d=`
      return vec4(outputValue.xy, outputValue.xy);
    `;return`
    vec4 ${"get"+a+"AtOutCoords"}() {
      ${l} coords = getOutputCoords();
      ${n}
      vec4 outputValue = get${a}(${p});
      ${d}
    }
  `}(e,t):a+=function(e,t){let n,r=e.name,a=r.charAt(0).toUpperCase()+r.slice(1),s="get"+a+"AtOutCoords",i=t.texShape,o=e.shapeInfo.texShape,l=e.shapeInfo.logicalShape.length,u=t.logicalShape.length;if(!e.shapeInfo.isUniform&&l===u&&null==e.shapeInfo.flatOffset&&ha.arraysEqual(o,i))return`
      float ${s}() {
        return sampleTexture(${r}, resultUV);
      }
    `;let h=Nj(u),p=NO(e.shapeInfo.logicalShape,t.logicalShape),d=u-l,c=["x","y","z","w","u","v"];n=0===l?"":u<2&&p.length>=1?"coords = 0;":p.map(e=>`coords.${c[e+d]} = 0;`).join("\n");let f="";return f=u<2&&l>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>`coords.${c[t+d]}`).join(", "),`
    float ${s}() {
      ${h} coords = getOutputCoords();
      ${n}
      return get${a}(${f});
    }
  `}(e,t)),a})(e,t,n.packedInputs,n.enableShapeUniforms)).join("\n"),d=t.texShape,c=NE(),f=(r=c,`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${r.texture2D}(textureSampler, uv).r;
    }
  `),m=(a=c,`${a.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${a.varyingFs} vec2 resultUV;
    ${a.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${a.defineSpecialNaN}
    ${a.defineSpecialInf}
    ${a.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${NM}
    ${NL}
    ${Nz}
  `);return t.isPacked?(o=function(e,t,n){switch(e.length){case 0:return NB();case 1:var r,a;let s;return r=t,a=n,1===(s=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)])[0]?a?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:1===s[1]?a?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:a?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `;case 2:var i=e,o=t,l=n;let u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(ha.arraysEqual(i,o))return l?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${u[0]}, ${u[1]}));
      }
    `;let h=Math.ceil(i[1]/2);return l?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${u[0]}, ${u[1]}));

      int index = resTexRC.x * ${u[1]} + resTexRC.y;
      int r = 2 * (index / ${h});
      int c = imod(index, ${h}) * 2;

      return ivec2(r, c);
    }
  `;case 3:var p=e,d=t,c=n;if(c)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let f=[Math.ceil(d[0]/2),Math.ceil(d[1]/2)],m=Math.ceil(p[2]/2),g=m*Math.ceil(p[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${f[0]}, ${f[1]}));
      int index = resTexRC.x * ${f[1]} + resTexRC.y;

      int b = index / ${g};
      index -= b * ${g};

      int r = 2 * (index / ${m});
      int c = imod(index, ${m}) * 2;

      return ivec3(b, r, c);
    }
  `;default:return function(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[e.length-1]/2),s=a*Math.ceil(e[e.length-2]/2),i=s,o="",l="b, r, c";for(let t=2;t<e.length-1;t++)i*=e[e.length-t-1],o=`
      int b${t} = index / ${i};
      index -= b${t} * ${i};
    `+o,l=`b${t}, `+l;return`
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${o}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${a});
      int c = imod(index, ${a}) * 2;

      return ivec${e.length}(${l});
    }
  `}(e,t,n)}}(t.logicalShape,d,n.enableShapeUniforms),s=c,l=`
    void setOutput(vec4 val) {
      ${s.output} = val;
    }
  `):(o=function(e,t,n){switch(e.length){case 0:return NB();case 1:return r=t,a=n,1===r[0]?a?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${r[1]}.0);
      }
    `:1===r[1]?a?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${r[0]}.0);
      }
    `:a?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return resTexRC.x * ${r[1]} + resTexRC.y;
    }
  `;case 2:return s=e,i=t,o=n,ha.arraysEqual(s,i)?o?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${i[0]}, ${i[1]}));
      }
    `:1===s[1]?o?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${i[0]}, ${i[1]}));
        int index = resTexRC.x * ${i[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:1===s[0]?o?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${i[0]}, ${i[1]}));
        int index = resTexRC.x * ${i[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:o?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${i[0]}, ${i[1]}));
      int index = resTexRC.x * ${i[1]} + resTexRC.y;
      int r = index / ${s[1]};
      int c = index - r * ${s[1]};
      return ivec2(r, c);
    }
  `;case 3:var r,a,s,i,o,l,u,h,p,d=e,c=t,f=n;if(f){let e=NR(["r","c","d"],d);return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${e}
    return ivec3(r, c, d);
  }
`}let m=NA(["r","c","d"],d);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${c[0]}, ${c[1]}));
      int index = resTexRC.x * ${c[1]} + resTexRC.y;
      ${m}
      return ivec3(r, c, d);
    }
  `;case 4:var g=e,y=t,x=n;if(x){let e=NR(["r","c","d","d2"],g);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${e}
      return ivec4(r, c, d, d2);
    }
  `}let b=NA(["r","c","d","d2"],g);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${y[0]}, ${y[1]}));
      int index = resTexRC.x * ${y[1]} + resTexRC.y;
      ${b}
      return ivec4(r, c, d, d2);
    }
  `;case 5:let w;return l=e,u=t,w=NA(["r","c","d","d2","d3"],l),`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${u[0]},
                             ${u[1]}));

      int index = resTexRC.x * ${u[1]} + resTexRC.y;

      ${w}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `;case 6:let v;return h=e,p=t,v=NA(["r","c","d","d2","d3","d4"],h),`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${p[0]}, ${p[1]}));
      int index = resTexRC.x * ${p[1]} + resTexRC.y;

      ${v}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `;default:throw Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,d,n.enableShapeUniforms),i=c,l=`
    void setOutput(float val) {
      ${i.output} = vec4(val, 0, 0, 0);
    }
  `),n.packedInputs&&(m+=NP),[m,f,l,h,o,p,n.userCode].join("\n")}(n,a={logicalShape:c.shape,texShape:c.texData.texShape,isUniform:!1,isPacked:c.texData.isPacked,flatOffset:null},e),i=kY(t.gl,s),o=t.createProgram(i),tU.get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:i,source:s,webGLProgram:o,inShapeInfos:r,outShapeInfo:a,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(t.buildVao(o),Object.assign({program:e,fragmentShader:i,source:s,webGLProgram:o,inShapeInfos:r,outShapeInfo:a},Nq(t,e,o)))}),g=null!=this.activeTimers;g&&(i=this.startTimer()),tU.get("ENGINE_COMPILE_ONLY")||function(e,t,n,r,a){t.program.enableShapeUniforms||(NK(t.inShapeInfos,n),NK([t.outShapeInfo],[r]));let s=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):e.setOutputMatrixTexture(s.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===tU.getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let r=0;r<n.length;++r){let a=n[r],{uniform:s,offset:i,shape:o,texShape:l}=t.variablesLocations[r];if(o){let{uniformShape:n}=NV(t.program.packedInputs,a.shape,a.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(o,new Int32Array(n));break;case 2:e.gl.uniform2iv(o,new Int32Array(n));break;case 3:e.gl.uniform3iv(o,new Int32Array(n));break;case 4:e.gl.uniform4iv(o,new Int32Array(n))}}if(l&&e.gl.uniform2i(l,a.texData.texShape[0],a.texData.texShape[1]),null!=s){if(a.isUniform){if(2>ha.sizeFromShape(a.shape))e.gl.uniform1f(s,a.uniformValues[0]);else{let t=a.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(s,t)}continue}null!=a.texData.slice&&null!=i&&e.gl.uniform1i(i,a.texData.slice.flatOffset),e.setInputMatrixTexture(a.texData.texture.texture,s,r)}}let o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape))}if(t.outShapeStridesLocation){let n=ha.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&a)for(let n=0;n<t.program.customUniforms.length;++n){let r=t.program.customUniforms[n],s=t.customUniformLocations[n],i=a[n];if("float"===r.type)e.gl.uniform1fv(s,i);else if("vec2"===r.type)e.gl.uniform2fv(s,i);else if("vec3"===r.type)e.gl.uniform3fv(s,i);else if("vec4"===r.type)e.gl.uniform4fv(s,i);else if("int"===r.type)e.gl.uniform1iv(s,i);else if("ivec2"===r.type)e.gl.uniform2iv(s,i);else if("ivec3"===r.type)e.gl.uniform3iv(s,i);else if("ivec4"===r.type)e.gl.uniform4iv(s,i);else throw Error(`uniform type ${r.type} is not supported yet.`)}e.executeProgram()}(this.gpgpu,m,d,c,r),p.forEach(e=>this.disposeIntermediateTensorInfo(e)),g&&(i=this.endTimer(i),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(i)}));let y=tU.getNumber("WEBGL_FLUSH_THRESHOLD");if(y>0){let e=ha.now();e-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!tU.getBool("WEBGL_LAZILY_UNPACK")&&h.isPacked&&!1===a){let e=this.unpackTensor(u);return this.disposeIntermediateTensorInfo(u),e}return u}compileAndRun(e,t,n,r,a=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,r,a)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(tU.getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=st(()=>{if(!tU.get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=tU.getBool("DEBUG");tU.set("DEBUG",!1);let t=this.abs(sQ(1e-8)).dataSync()[0];if(tU.set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){let t,n=this.texData.get(e),{shape:r,dtype:a,values:s,texture:i,usage:o,isPacked:l}=n;if(null!=i)return;let u=null!=this.activeTimers;u&&(t=ha.now());let h=n.texShape;if(null==h&&(n.texShape=h=Nf(r,l)),null!=s){let e,i=Nc(r),o=h[1],p=h[0],d=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(l||!d)&&([o,p]=kj(h[0],h[1])),e=l?new N2(i,d):new N1(i,d);let c=d?[p,o]:h,f=this.makeTensorInfo(c,a),m=this.texData.get(f.dataId);d?m.usage=L.PIXELS:m.usage=L.UPLOAD,m.texShape=c,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),o,p,s);let g=[[p,o]],y=this.runWebGLProgram(e,[f],a,g,!0),x=this.texData.get(y.dataId);n.texShape=x.texShape,n.isPacked=x.isPacked,n.usage=x.usage,tU.get("ENGINE_COMPILE_ONLY")?this.disposeData(y.dataId):(n.texture=x.texture,n.values=null,this.texData.delete(y.dataId)),this.disposeIntermediateTensorInfo(f),u&&(this.uploadWaitMs+=ha.now()-t)}else n.texture=this.acquireTexture(h,o,a,l)}convertAndCacheOnCPU(e,t){let n=this.texData.get(e),{dtype:r}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){let n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){let e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*ha.bytesPerElement(t)}checkCompileCompletion(){for(let[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){let e=[];if(this.gpgpu.parallelCompilationExtension){for(let[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(let[,t]of Object.entries(this.binaryCache)){let n=new Promise(e=>{try{this.checkCompletion_(t),e(!0)}catch(e){throw e}});e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await c$(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw kJ(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),Error("Failed to compile fragment shader.");throw Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(let e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);let{variablesLocations:t,customUniformLocations:n,infLoc:r,nanLoc:a,outShapeLocation:s,outShapeStridesLocation:i,outTexShapeLocation:o}=Nq(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=a,e.outShapeLocation=s,e.outShapeStridesLocation=i,e.outTexShapeLocation=o}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";let{texture:r,height:a,width:s,channels:i}=e,o=aH.backend;if(!o.gpgpu.gl.isTexture(r))throw Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let l=o.writeTexture(r,t,n,a,s,i);return aH.makeTensorFromDataId(l,t,n,o)}}SN.nextDataId=0;var SI=e.i(97604),SS=e.i(79383);function SC(){tU.set("WEBGL_FORCE_F16_TEXTURES",!0)}e.s(["forceHalfFloat",()=>SC],32712),kL.isBrowser()&&sa("webgl",()=>new SN,2),e.s(["webgl",0,{forceHalfFloat:SC}],50248);var vM=oK,ha=ha,lz=lz,lz=lz;let ST=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class S${constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=lz.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=NX(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}var lz=lz,ha=ha;let SE=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class SA{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=lz.assertAndGetBroadcastShape(t,n);const a=this.outputShape.length;this.enableShapeUniforms=NX(a);let s="";if(r)if(0===a||1===ha.sizeFromShape(this.outputShape))s=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else{const e=Nj(a);if(s=`
          ${e} coords = getOutputCoords();
        `,1===a)this.enableShapeUniforms?s+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:s+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const e=Sn("coords",a);this.enableShapeUniforms?s+=`
            bool nextRowOutOfBounds =
              (${e[a-2]} + 1) >= outShape[${a} - 2];
            bool nextColOutOfBounds =
              (${e[a-1]} + 1) >= outShape[${a} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:s+=`
            bool nextRowOutOfBounds =
              (${e[a-2]} + 1) >= ${this.outputShape[a-2]};
            bool nextColOutOfBounds =
              (${e[a-1]} + 1) >= ${this.outputShape[a-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${s}

        setOutput(result);
      }
    `}}function SR(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function SF(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.makeTensorInfo(r.shape,"complex64");return n.texData.get(s.dataId).complexTensorInfos={real:SR({inputs:{x:r},backend:n}),imag:SR({inputs:{x:a},backend:n})},s}var ha=ha;let S_="return (a < 0.) ? b * a : a;",SD=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`,SO="return (a < 0.) ? b * a : a;",SM=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`,SL="if (isnan(x)) return x;";function Sz({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:a,backend:s})=>{let i,{x:o}=a,l=r||o.dtype;if(s.shouldExecuteOnCPU([o])&&null!=n){let e=n(s.texData.get(o.dataId).values,l);return s.makeTensorInfo(o.shape,l,e)}return i=tU.getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new Sx(o.shape,t):new Su(o.shape,e),s.runWebGLProgram(i,[o],l)}}function SP({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:a,dtype:s}){return({inputs:i,backend:o})=>{let l,{a:u,b:h}=i;if(r&&"complex64"===u.dtype){let t=o.texData.get(u.dataId),n=o.texData.get(h.dataId),[r,a]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map(t=>{let[n,r]=t,a={dataId:n.dataId,dtype:n.dtype,shape:u.shape},s={dataId:r.dataId,dtype:r.dtype,shape:h.shape},i=new S$(e,u.shape,h.shape);return o.runWebGLProgram(i,[a,s],aD(n.dtype,r.dtype))}),s=SF({inputs:{real:r,imag:a},backend:o});return o.disposeIntermediateTensorInfo(r),o.disposeIntermediateTensorInfo(a),s}let p=s||aD(u.dtype,h.dtype);if(("string"===u.dtype||"string"===h.dtype||o.shouldExecuteOnCPU([u,h]))&&null!=a){let e=o.texData.get(u.dataId).values,t=o.texData.get(h.dataId).values,n="string"===u.dtype?lz.fromUint8ToStringArray(e):e,r="string"===u.dtype?lz.fromUint8ToStringArray(t):t,[s,i]=a(u.shape,h.shape,n,r,p),l=o.makeTensorInfo(i,p);return o.texData.get(l.dataId).values=s,l}return l=tU.getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new SA(t,u.shape,h.shape,n):new S$(e,u.shape,h.shape),o.runWebGLProgram(l,[u,h],p)}}function SB(e,t=!1){if("linear"===e)return"return x;";if("relu"===e)return t?Sg:Sd;if("elu"===e)return t?Sm:"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?Sy:Sc;if("prelu"===e)return t?SM:SO;else if("leakyrelu"===e)return t?SD:S_;else if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class SW{constructor(e,t,n,r=!1,a=!1,s=!1,i=null,o=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=NX(this.outputShape.length);const u=Math.ceil((r?e[1]:e[2])/2),h=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],p=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let d="",c="";i&&(d=o?`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:l?`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:`vec4 activation(vec4 x) {
          ${i}
        }`,c="result = activation(result);"),s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let f="rc.x",m="rc.x";e[0]<t[0]?f=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(m=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${d}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${u}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${f};
        int batchB = ${m};
        for (int i = 0; i < ${u}; i++) {
          vec4 a = getMatrixA(batchA, ${r?"i * 2, rc.y":"rc.y, i * 2"});
          vec4 b = getMatrixB(batchB, ${a?"rc.z, i * 2":"i * 2, rc.z"});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${h[0]} * ${p[0]});
          result += (${h[1]} * ${p[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${s?"result += getBiasAtOutCoords();":""}

        ${c}

        setOutput(result);
      }
    `}}var lz=lz,lz=lz;class SU{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=lz.assertAndGetBroadcastShape(t,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}let Sj="return a * b;";function SV(e){let t,{inputs:n,backend:r}=e,{a,b:s}=n,i=lz.upcastType(a.dtype,s.dtype);if("complex64"===a.dtype){let e=r.texData.get(a.dataId),t=r.texData.get(s.dataId),n=new SU("return areal * breal - aimag * bimag;",a.shape,s.shape),i=new SU("return areal * bimag + aimag * breal;",a.shape,s.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:a.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape}],l=r.runWebGLProgram(n,o,"float32"),u=r.runWebGLProgram(i,o,"float32"),h=SF({inputs:{real:l,imag:u},backend:r});return r.disposeIntermediateTensorInfo(l),r.disposeIntermediateTensorInfo(u),h}if(r.shouldExecuteOnCPU([a,s])){let e=r.texData.get(a.dataId),t=r.texData.get(s.dataId),[n,o]=Iz(a.shape,s.shape,e.values,t.values,i),l=r.makeTensorInfo(o,i);return r.texData.get(l.dataId).values=n,l}return t=tU.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new SA(Sj,a.shape,s.shape):new S$(Sj,a.shape,s.shape),r.runWebGLProgram(t,[a,s],i)}var ha=ha;function SG(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=ha.sizeFromShape(a.shape),o=ha.inferFromImplicitShape(s,i),l=ha.sizeFromShape(o);ha.assert(i===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${a.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`);let u=n.texData.get(a.dataId);if(u.isPacked&&!Nm(a.shape,o)&&!(null!==u.texture&&Nm(u.shape,o))){let e,t,r,s,i;return e=[Np(a.shape),...Nd(a.shape)],t={dtype:a.dtype,shape:e,dataId:a.dataId},r=new Sa([Np(o),...Nd(o)],e),s=[e],{dataId:(i=n.runWebGLProgram(r,[t],a.dtype,s,!0)).dataId,shape:o,dtype:i.dtype}}return n.incRef(a.dataId),{dataId:a.dataId,shape:o,dtype:a.dtype}}var lz=lz,ha=ha,lz=lz,ha=ha;class SH{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];const i=4*Math.floor(n/4),o=n%4;let l="sumValue += dot(values, ones);";if(null!=t){const e=1/t;l=`sumValue += dot(values * ${ha.isInt(e)?e.toPrecision(2):e}, ones);`}let u="";a%n>0&&(u=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${i};
        if (${1===o}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${2===o}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${3===o}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}}class Sq{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let i="0.0",o="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",o="min"):"max"===t&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?l="sumValue":"prod"===t?l="prodValue":"all"===t?l="allValue":"any"===t&&(l="anyValue");const u=4*Math.floor(n/4),h=n%4;let p=`
      if (${"sum"===t}) {
        sumValue += dot(values, ones);
      } else if (${"prod"===t}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${o}(values, minMaxValue);
        if (${"min"===t} || ${"max"===t}) {
          minMaxValue = ${o}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,d="vec4";"all"===t?(i="1.0",p=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,d="bvec4"):"any"===t&&(i="0.0",p=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,d="bvec4");let c="";a%n>0&&(c=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${p}
        }

        int inIdx = inOffset + ${u};
        if (${1===h}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${2===h}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${3===h}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${p}
        }
        setOutput(${l});
      }
    `}}function SK(e,t,n,r){let a=function(e){let t=[];for(;0===t.length||1!==t[t.length-1].outSize;){let n=t.length?t[t.length-1].outSize:e[1],r=lz.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape),s=e;for(let i=0;i<a.length;i++){let o,l,{inSize:u,windowSize:h,outSize:p}=a[i];o="mean"===n?0===i?new SH({windowSize:h,inSize:u,batchSize:e.shape[0],outSize:p},u):new SH({windowSize:h,inSize:u,batchSize:e.shape[0],outSize:p}):new Sq({windowSize:h,inSize:u,batchSize:e.shape[0],outSize:p},n),l=s,s=r.runWebGLProgram(o,[s],t),l.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(l)}return s}class SX{constructor(e,t){this.variableNames=["A"];const n=Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.rank=n.length;const r=Nj(this.rank),a=function(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=Array(t);for(let t=0;t<e.length;t++)r[e[t]]=n[t];return r.join()}(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${a}));
    }
    `}}class SY{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=Nj(this.rank),a=St("rc",this.rank),s=Array(this.rank);for(let e=0;e<t.length;e++)s[t[e]]=a[e];const i=`vec2(${s.slice(-2).join()})`,o=`++${a[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${i})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${o}) {
        result[1] = ${l};
      }
      --${a[this.rank-1]};
      if(++${a[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${l};
        if(${o}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}}function SZ(e,t,n){let r=tU.getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new SY(e.shape,t):new SX(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function SJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;return function(e,t,n,r){let a=e.shape.length,s=ha.parseAxisParam(t,e.shape),i=s,o=lz.getAxesPermutation(i,a),l=null!=o,u=e;l&&(u=SZ(e,o,r),i=lz.getInnerMostAxes(i.length,a)),lz.assertAxesAreInnerMostDims("sum",i,a);let[h,p]=lz.computeOutAndReduceShapes(u.shape,i),d=h;n&&(d=lz.expandShapeToKeepDim(h,s));let c=ha.sizeFromShape(p),f=SG({inputs:{x:u},attrs:{shape:[ha.sizeFromShape(e.shape)/c,c]},backend:r}),m=SK(f,aO(e.dtype),"sum",r),g=SG({inputs:{x:m},attrs:{shape:d},backend:r});return r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(m),l&&r.disposeIntermediateTensorInfo(u),g}(a,s,i,n)}function SQ(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{perm:i}=a,o=Array(s.shape.length);for(let e=0;e<o.length;e++)o[e]=s.shape[i[e]];if(r.shouldExecuteOnCPU([s])){let e=I9(r.texData.get(s.dataId).values,s.shape,s.dtype,i,o);t=r.makeTensorInfo(o,s.dtype),r.texData.get(t.dataId).values=e}else t=SZ(s,i,r);return t}function S0({a:e,b:t,transposeA:n,transposeB:r,backend:a,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){let u,h=e.shape.length,p=t.shape.length,d=n?e.shape[h-2]:e.shape[h-1],c=r?t.shape[p-1]:t.shape[p-2],f=n?e.shape[h-1]:e.shape[h-2],m=r?t.shape[p-2]:t.shape[p-1],g=e.shape.slice(0,-2),y=t.shape.slice(0,-2),x=ha.sizeFromShape(g),b=ha.sizeFromShape(y),w=vM.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([f,m]);ha.assert(d===c,()=>`Error in matMul: inner shapes (${d}) and (${c}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`);let v=n?[x,d,f]:[x,f,d],k=r?[b,m,c]:[b,c,m],N=SG({inputs:{x:e},backend:a,attrs:{shape:v}}),I=SG({inputs:{x:t},backend:a,attrs:{shape:k}}),S=[N,I],C=Math.max(x,b),T=n?N.shape[1]:N.shape[2],$=null!=s,E=null!=i,A="leakyrelu"===l,R=null!=l?SB(l,!0):null,F=$||E||A||null!=R;if((1===f||1===m)&&T>1e3&&!1===F){let e=N,t=I;n&&(e=SQ({inputs:{x:N},backend:a,attrs:{perm:[0,2,1]}}),S.push(e)),r&&(t=SQ({inputs:{x:I},backend:a,attrs:{perm:[0,2,1]}}),S.push(t));let s=1!==m,i=1===m,o=e;s&&(o=SG({inputs:{x:e},backend:a,attrs:{shape:[C,T,1]}}),S.push(o));let l=t;i&&(l=SG({inputs:{x:t},backend:a,attrs:{shape:[C,1,T]}}),S.push(l));let h=SV({inputs:{a:o,b:l},backend:a});u=SJ({inputs:{x:h},backend:a,attrs:{axis:1===m?2:1,keepDims:!0}}),S.push(h)}else{let l=aD(e.dtype,t.dtype),h=new SW(v,k,[C,f,m],n,r,$,R,E,A),p=[N,I];if(null!=s&&p.push(s),E&&p.push(i),A){let e=a.makeTensorInfo([],"float32",ha.createScalarValue(o,"float32"));p.push(e),S.push(e)}u=a.runWebGLProgram(h,p,l)}let _=SG({inputs:{x:u},backend:a,attrs:{shape:w}});for(let e of(S.push(u),S))a.disposeIntermediateTensorInfo(e);return _}let S1="return abs(x);",S2=Sz({opSnippet:Sh+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`}),S3=Sz({opSnippet:Sh+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`}),S4="return a + b;",S5=SP({opSnippet:S4,packedOpSnippet:S4,supportsComplex:!0,cpuKernelImpl:Ig});class S6{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((e,t)=>`T${t}`);const n=[];this.variableNames.forEach(e=>{n.push(`float v${e} = get${e}AtOutCoords();`)});const r=this.variableNames.map(e=>`v${e}`).join(" + ");this.userCode=`
      void main() {
        ${n.join("\n        ")}

        float result = ${r};
        setOutput(result);
      }
    `}}class S8{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((e,t)=>`T${t}`);const n=[];this.variableNames.forEach(e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)});const r=this.variableNames.map(e=>`v${e}`).join(" + ");this.userCode=`
      void main() {
        ${n.join("\n        ")}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}var lz=lz,ha=ha,lz=lz,ha=ha,lz=lz,ha=ha,lz=lz,ha=ha;class S7{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:a,outSize:s}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[a,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};
          float candidate = getA(batch, inIdx);
          if (candidate ${"max"===t?">":"<"} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}var ha=ha;class S9{constructor(e,t,n,r){let a,s;this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,ha.assert(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);const i=Math.ceil(e[e.length-1]/t);this.outputShape=e.slice(0,-1),i>1&&this.outputShape.push(i),r||this.variableNames.push("bestIndicesA");const o=this.outputShape,l=o.length,u=Nj(l),h=Sn("coords",l);if(1===i){const e=Nj(s=l+1);a=`
        ${e} sourceLocR = ${e}(${h.join()}, 0);
        ++${h[l-1]};
        ${e} sourceLocG = ${e}(${h.join()}, 0);
        ++${h[l-2]};
        ${e} sourceLocA = ${e}(${h.join()}, 0);
        --${h[l-1]};
        ${e} sourceLocB = ${e}(${h.join()}, 0);
        --${h[l-2]};`}else s=l,a=`
        ${u} sourceLocR = coords;
        ++${h[l-1]};
        ${u} sourceLocG = coords;
        ++${h[l-2]};
        ${u} sourceLocA = coords;
        --${h[l-1]};
        ${u} sourceLocB = coords;
        --${h[l-2]};`;const p=["x","y","z","w","u","v"].slice(0,s),d="."+p[s-1],c=p.map(e=>"int "+e),f=Sn("sourceLocR",s-1).concat("inIdx.r"),m=Sn("sourceLocG",s-1).concat("inIdx.g"),g=Sn("sourceLocB",s-1).concat("inIdx.b"),y=Sn("sourceLocA",s-1).concat("inIdx.a"),x="max"===n?"greaterThan":"lessThan",b=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${f.join()}),
                             getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()})));`,w=`vec4(
            getAChannel(${f.join()}),
            hasNextCol ? getAChannel(${m.join()}) : 0.,
            hasNextRow ? getAChannel(${g.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${y.join()}) : 0.)`,v=r?"":`
      float getBestIndicesAChannel(${c.join()}) {
        return getChannel(getBestIndicesA(${p.join()}),
                                          vec2(${p.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${c.join()}) {
        return getChannel(getA(${p.join()}),
                               vec2(${p.slice(-2).join()}));
      }
      ${v}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${h[l-1]} < ${o[l-1]-1};
        bool hasNextRow = ${h[l-2]} < ${o[l-2]-1};
        ${a}
        ivec4 srcIdx = ivec4(sourceLocR${d}, sourceLocG${d},
          sourceLocB${d}, sourceLocA${d}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${w};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${b}
          vec4 candidate = ${w};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}function Ce(e,t,n,r){let a=[n];if(lz.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,t.shape.length),!tU.getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let n=[],s=e.texData.get(t.dataId),i=null!==s&&s.isPacked,o=t;i&&n.push(o=e.unpackTensor(t));let[l,u]=lz.computeOutAndReduceShapes(o.shape,a),h=SG({inputs:{x:o},backend:e,attrs:{shape:[-1,ha.sizeFromShape(u)]}});n.push(h);let p=function e(t,n,r,a=null){let s=n.shape[0],i=n.shape[1];null!=a&&(s=a.shape[0],i=a.shape[1]);let o=lz.computeOptimalWindowSize(i),l=new S7({windowSize:o,inSize:i,batchSize:s,outSize:Math.ceil(i/o)},r,null==a),u=[n];null!=a&&u.push(a);let h=t.runWebGLProgram(l,u,"int32");if(1===h.shape[1])return h;let p=e(t,n,r,h);return t.disposeIntermediateTensorInfo(h),p}(e,h,r);n.push(p);let d=SG({inputs:{x:p},backend:e,attrs:{shape:l}});return n.forEach(t=>e.disposeIntermediateTensorInfo(t)),d}return function e(t,n,r,a=null){let s=null!=a?a.shape:n.shape,i=s[s.length-1],o=new S9(s,lz.computeOptimalWindowSize(i),r,null==a),l=null==a?[n]:[n,a],u=t.runWebGLProgram(o,l,"int32");if(u.shape.length===n.shape.length){let a=e(t,n,r,u);return t.disposeIntermediateTensorInfo(u),a}return u}(e,t,r)}var lz=lz,ha=ha;let Ct=Sz({opSnippet:Sh+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`}),Cn=Sz({opSnippet:Sh+"return log(x + sqrt(x * x + 1.0));"}),Cr=Sz({opSnippet:Sh+`
  return atan(x);
`}),Ca=SP({opSnippet:ST+`
  return atan(a, b);
`,packedOpSnippet:`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+SE+`
  return result;
`}),Cs=Sz({opSnippet:Sh+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`});var lz=lz,ha=ha;class Ci{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],"avg"===t&&n)throw Error("Cannot compute positions for average pool.");const s=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,h=e.effectiveFilterHeight,p=e.effectiveFilterWidth,d=e.padInfo.top,c=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let y="0.0";if(f||(y="-1.0 / 1e-20"),n){this.userCode=`
        const ivec2 strides = ivec2(${i}, ${o});
        const ivec2 pads = ivec2(${d}, ${c});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?a?m:g:`wR * ${p} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(x="avgValue / max(count, 1.0)");const b=4*Math.floor(s/4),w=s%4,v=`
      if (${f}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = max(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${d}, ${c});
      const float initializationValue = ${y};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${y});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${b}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${v}
          }

          int xC = xCCorner + ${b};
          if (${1===w}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${v}
          } else if (${2===w}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${v}
          } else if (${3===w}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${v}
          }
        }
        setOutput(${x});
      }
    `}}class Co{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],"avg"===t&&n)throw Error("Cannot compute positions for average pool.");const s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,h=e.dilationHeight,p=e.dilationWidth,d=e.effectiveFilterDepth,c=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const x="avg"===t;let b="0.0";if(x||(b="-1.0 / 1e-20"),n){this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${o}, ${l});
        const ivec3 pads = ivec3(${m}, ${g}, ${y});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${d};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${c};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${f};
                  wC += ${p}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${c} * ${f} +
                      wR * ${f} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let w=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(w="avgValue / max(count, 1.0)");const v=4*Math.floor(s/4),k=s%4,N=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = max(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${o}, ${l});
      const ivec3 pads = ivec3(${m}, ${g}, ${y});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${c};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${v}; wC += 4) {
              int xC = xCCorner + wC * ${p};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                getValue(batch, xD, xR, xC + 3 * ${p}, ch)
              );

              ${N}
            }

            int xC = xCCorner + ${v};
            if (${1===k}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${N}
            } else if (${2===k}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                initializationValue,
                initializationValue
              );

              ${N}
            } else if (${3===k}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                initializationValue
              );

              ${N}
            }
          }
        }
        setOutput(${w});
      }
    `}}var lz=lz,lz=lz;class Cl{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.top,h=l-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${u}, ${h});
      const float avgMultiplier = float(${1/(t*n)});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
            wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class Cu{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,d=e.effectiveFilterWidth,c=h-1-e.padInfo.front,f=p-1-e.padInfo.top,m=d-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${c}, ${f}, ${m});
      const float avgMultiplier = float(${1/(t*n*r)});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${a}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${p};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}var lz=lz,ha=ha,lz=lz;class Ch{constructor(e,t,n,r,a,s){this.outputShape=[],this.variableNames=["x","mean","variance"],lz.assertAndGetBroadcastShape(e,t),lz.assertAndGetBroadcastShape(e,n);let i="0.0";null!=r&&(lz.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";null!=a&&(lz.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${o};
        float inv = scale * inversesqrt(variance + float(${s}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}var lz=lz;class Cp{constructor(e,t,n,r,a,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],lz.assertAndGetBroadcastShape(e,t),lz.assertAndGetBroadcastShape(e,n);let i="vec4(0.0)";null!=r&&(lz.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=a&&(lz.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${o};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${s}));

        setOutput((x - mean) * inv + offset);
      }
    `}}var lz=lz,ha=ha,vs=oB,ha=ha;class Cd{constructor(e){let t;this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const n=Nj(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=function(e){if(1===e)return"sourceLoc";if(e<=6)return Cc.slice(0,e).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank),a=e.map((e,t)=>`sourceLoc.${Cc[t]} = start[${t}] + coords.${Cc[t]};`);t=`
        ${n} sourceLoc;
        ${n} coords = getOutputCoords();
        ${a.join("\n")}
      `,this.userCode=`
      void main() {
        ${t}
        setOutput(getSource(${r}));
      }
    `}}let Cc=["x","y","z","w","u","v"];class Cf{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=Nj(this.rank),n=Sn("coords",this.rank),r=Sn("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,s=`getChannel(getSource(${r.join()}), ${a})`,i=`
      result.x = ${s};
      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${s};
        --${r[this.rank-1]};
      }
    `,o=1===this.rank?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${s};
        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${s};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((e,t)=>`start[${t}]`).join()});`:e.map((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`).join("\n");this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${i}
        ${o}
        setOutput(result);
      }
    `}}function Cm(e){let t,n,r,a,s,{inputs:i,backend:o,attrs:l}=e,{x:u}=i,{begin:h,size:p}=l,[d,c]=vs.parseSliceParams(u,h,p);if(vs.assertParamsValid(u,d,c),0===ha.sizeFromShape(c))return o.makeTensorInfo(c,u.dtype,[]);if(o.shouldExecuteOnCPU([u])||"string"===u.dtype){let e=IY(o.texData.get(u.dataId).values,d,c,u.shape,u.dtype);return o.makeTensorInfo(c,u.dtype,e)}let{isPacked:f}=o.texData.get(u.dataId),m=vs.isSliceContinous(u.shape,d,c);if(f||!m){let e=tU.getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Cf(c):new Cd(c),t=[d];return o.runWebGLProgram(e,[u],u.dtype,t)}return o.uploadToGPU(u.dataId),t=o.texData.get(u.dataId),n=o.makeTensorInfo(c,u.dtype),Object.assign(r=o.texData.get(n.dataId),t),r.refCount=1,r.shape=c,r.dtype=u.dtype,a=vs.computeFlatOffset(d,ha.computeStrides(u.shape)),t.slice&&(a+=t.slice.flatOffset),r.slice={flatOffset:a,origDataId:t.slice&&t.slice.origDataId||u.dataId},s=o.dataRefCount.get(r.slice.origDataId)||1,o.dataRefCount.set(r.slice.origDataId,s+1),n}let Cg=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,Cy=`
  return float(int(a.r) & int(b.r));
`;var lz=lz,ha=ha;let Cx=SP({opSnippet:"return float(a != b);",cpuKernelImpl:IB,dtype:"bool"});function Cb(e){let{inputs:t,backend:n}=e,{input:r}=t;return SR({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}let Cw="return ceil(x);",Cv=Sz({opSnippet:Cw,packedOpSnippet:Cw,cpuKernelImpl:Iv});class Ck{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}class CN{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}class CI{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}function CS(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}var lz=lz,ha=ha,lz=lz,ha=ha,lz=lz;class CC{constructor(e){this.outputShape=[],this.outputShape=lz.computeOutShape(e,1),this.variableNames=e.map((e,t)=>`T${t}`);const t=Array(e.length-1);t[0]=e[0][1];for(let n=1;n<t.length;n++)t[n]=t[n-1]+e[n][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let e=1;e<t.length;e++){const r=t[e-1];n.push(`else if (yC < ${t[e]}) setOutput(getT${e}(yR, yC-${r}));`)}const r=t.length,a=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${a}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join("\n        ")}
      }
    `}}var lz=lz;class CT{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=lz.computeOutShape(e,t);const n=this.outputShape,r=n.length,a=Nj(r),s=Sn("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((e,t)=>`T${t}`);const o=Array(e.length-1);o[0]=e[0][t];for(let n=1;n<o.length;n++)o[n]=o[n-1]+e[n][t];const l=i[t],u=i.slice(-2),h=i.join();let p=`if (${l} < ${o[0]}) {
        return getChannel(
            getT0(${h}), vec2(${u.join()}));
        }`;for(let e=1;e<o.length;e++){const t=o[e-1];p+=`
        if (${l} < ${o[e]}  && ${l} >= ${o[e-1]}) {
          return getChannel(
            getT${e}(${C$(i,l,t)}),
            vec2(${C$(u,l,t)}));
        }`}const d=o.length,c=o[o.length-1];p+=`
        return getChannel(
          getT${d}(${C$(i,l,c)}),
          vec2(${C$(u,l,c)}));`,this.userCode=`
      float getValue(${i.map(e=>"int "+e)}) {
        ${p}
      }

      void main() {
        ${a} coords = getOutputCoords();
        vec4 result = vec4(getValue(${s}), 0., 0., 0.);

        ${s[r-1]} = ${s[r-1]} + 1;
        if (${s[r-1]} < ${n[r-1]}) {
          result.g = getValue(${s});
        }

        ${s[r-2]} = ${s[r-2]} + 1;
        if (${s[r-2]} < ${n[r-2]}) {
          result.a = getValue(${s});
        }

        ${s[r-1]} = ${s[r-1]} - 1;
        if (${s[r-2]} < ${n[r-2]} &&
            ${s[r-1]} < ${n[r-1]}) {
          result.b = getValue(${s});
        }
        setOutput(result);
      }
    `}}function C$(e,t,n){let r=e.indexOf(t);return e.map((e,t)=>t===r?`${e} - ${n}`:e).join()}function CE(e){let{inputs:t,backend:n}=e,{input:r}=t;return SR({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}function CA(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=ha.parseAxisParam(a,t[0].shape)[0],i=t.map(e=>e.shape);lz.assertParamsConsistent(i,s);let o=lz.computeOutShape(t.map(e=>e.shape),s);if(0===ha.sizeFromShape(o))return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter(e=>ha.sizeFromShape(e.shape)>0);return 1===l.length?SR({inputs:{x:l[0]},backend:n}):function e(t,n,r){var a,s,i;let o,l=t[0].dtype;if("complex64"===l){let a=t.map(e=>Cb({inputs:{input:e},backend:r})),s=t.map(e=>CE({inputs:{input:e},backend:r})),i=e(a,n,r),o=e(s,n,r),l=SF({inputs:{real:i,imag:o},backend:r});return a.forEach(e=>r.disposeIntermediateTensorInfo(e)),s.forEach(e=>r.disposeIntermediateTensorInfo(e)),r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),l}let u=r.shouldExecuteOnCPU(t);if("string"===l&&(u=!0),u){let e=t.map(e=>{let t=ha.sizeFromShape(e.shape.slice(n));return SG({inputs:{x:e},backend:r,attrs:{shape:[-1,t]}})}),a=Ik(e.map(e=>({vals:r.readSync(e.dataId),shape:e.shape})),lz.computeOutShape(e.map(e=>e.shape),1),l,1===e[0].shape[0]),s=lz.computeOutShape(t.map(e=>e.shape),n),i=r.makeTensorInfo(s,l,a);return e.forEach(e=>r.disposeIntermediateTensorInfo(e)),i}let h=t.filter(e=>ha.sizeFromShape(e.shape)>0),p=tU.getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&h[0].shape.length>1;if(1===h.length){let e=p?new Su(t[0].shape,Sf):new Sx(t[0].shape,Sf);return r.runWebGLProgram(e,t,l)}let d=tU.getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(h.length>d){let t=[];for(let a=0;a<h.length;a+=d){let s=h.slice(a,a+d);t.push(e(s,n,r))}let a=e(t,n,r);for(let e of t)r.disposeIntermediateTensorInfo(e);return a}if(p){let e=new CT(h.map(e=>e.shape),n);return r.runWebGLProgram(e,h,l)}let{tensors2D:c,outShape:f}=(a=h,s=n,i=r,o=lz.computeOutShape(a.map(e=>e.shape),s),{tensors2D:a.map(e=>SG({inputs:{x:e},attrs:{shape:[-1,ha.sizeFromShape(e.shape.slice(s))]},backend:i})),outShape:o}),m=new CC(c.map(e=>e.shape)),g=r.runWebGLProgram(m,c,l);c.forEach(e=>r.disposeIntermediateTensorInfo(e));let y=SG({inputs:{x:g},attrs:{shape:f},backend:r});return r.disposeIntermediateTensorInfo(g),y}(l,s,n)}var lz=lz;class CR{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const s=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,h=e.dilationWidth,p=e.filterHeight,d=e.filterWidth,c=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat;let g="",y="";n&&(g=r?`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:a?`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:`
          float activation(float x) {
            ${n}
          }
        `,y="result = activation(result);"),t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${g}

      const ivec2 strides = ivec2(${o}, ${l});
      const ivec2 pads = ivec2(${s}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${m?3:1}];

        ivec2 xRCCorner =
            ivec2(coords[${m?1:2}], coords[${m?2:3}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${p}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${d}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${c}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${m}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${1===f}) {

              if (${m}) {
                dotProd +=
                    getX(batch, xR, xC, ${c}) *
                    getW(wR, wC, ${c}, d2);
              } else {
                dotProd +=
                    getX(batch, ${c}, xR, xC) *
                    getW(wR, wC, ${c}, d2);
              }

            } else if (${2===f}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${c}, d2),
                getW(wR, wC, ${c} + 1, d2)
              );

              if (${m}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${c}),
                  getX(batch, xR, xC, ${c} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${c}, xR, xC),
                  getX(batch, ${c} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${3===f}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${c}, d2),
                getW(wR, wC, ${c} + 1, d2),
                getW(wR, wC, ${c} + 2, d2)
              );

              if (${m}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${c}),
                  getX(batch, xR, xC, ${c} + 1),
                  getX(batch, xR, xC, ${c} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${c}, xR, xC),
                  getX(batch, ${c} + 1, xR, xC),
                  getX(batch, ${c} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${t?"result += getBiasAtOutCoords();":""}
        ${y}
        setOutput(result);
      }
    `}}class CF{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,h=e.filterDepth,p=e.filterHeight,d=e.filterWidth,c=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${a}, ${s}, ${i});
      const ivec3 pads = ivec3(${t}, ${n}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${o};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${c}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${1===f}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${c}) *
                  getW(wF, wR, wC, ${c}, d2);
              } else if (${2===f}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${c}),
                  getX(batch, xF, xR, xC, ${c} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${c}, d2),
                  getW(wF, wR, wC, ${c} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${3===f}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${c}),
                  getX(batch, xF, xR, xC, ${c} + 1),
                  getX(batch, xF, xR, xC, ${c} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${c}, d2),
                  getW(wF, wR, wC, ${c} + 1, d2),
                  getW(wF, wR, wC, ${c} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}var ha=ha;class C_{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=NX(this.outputShape.length);const s=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,u=e.filterWidth;let h=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let e=0;e<u;e++)h+=`
           vec4 xTexelC${2*e};
           int xTexelC${2*e}Ready;
           vec4 xTexelC${2*e+1};
           int xTexelC${2*e+1}Ready;
           vec4 xC${e};`;h+=`
     for (int r = 0; r < ${l}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let e=0;e<u;e++)h+=`
           xTexelC${2*e} = vec4(0.0);
           xTexelC${2*e}Ready = 0;
           xTexelC${2*e+1} = vec4(0.0);
           xTexelC${2*e+1}Ready = 0;
           xC${e} = vec4(0.0);`;h+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let t=0;t<(u+1)/2;t++){const n=2*t;if(h+=`
           xC = xCCorner + ${n*o};
           `,1===i){if(n<u&&(s%2==1?(h+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {
                   xTexelC${n} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${n}.zw = vec2(0.0);
                   }
                   xTexelC${n}Ready = 1;
                 }
               `,1===o&&n>0?h+=`
                 xC${n} = vec4(xTexelC${n-2}.zw, xTexelC${n}.xy);
                 `:h+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${n} = vec4(previous.zw, xTexelC${n}.xy);
                   } else {
                     xC${n} = vec4(0.0, 0.0, xTexelC${n}.xy);
                   }
                   `):h+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {
                   xTexelC${n} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${n}.zw = vec2(0.0);
                   }
                   xTexelC${n}Ready = 1;
                 }

                 xC${n} = xTexelC${n};
                 `,n+1<u)){const e=s%2==0?ha.nearestLargerEven(o):o;o%2==0&&s%2==1||o%2!=0&&s%2!=1?(h+=`
                   xCOffset = xC + imod(pads[1], 2) + ${e};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {
                     xTexelC${n+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${n+1}.zw = vec2(0.0);
                     }
                     xTexelC${n+1}Ready = 1;
                   }
                   `,o>1?h+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${n+1} = vec4(previous.zw, xTexelC${n+1}.xy);
                     } else {
                      xC${n+1} = vec4(0.0, 0.0, xTexelC${n+1}.xy);
                     }
                     `:h+=`
                     xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.xy);
                     `):1===e?h+=`
                     xC${n+1} = xTexelC${n};
                     `:h+=`
                     xCOffset = xC + ${e};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {
                       xTexelC${n+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${n+1}.zw = vec2(0.0);
                       }
                       xTexelC${n+1}Ready = 1;
                     }

                     xC${n+1} = xTexelC${n+1};
                     `}}else n<u&&(s%2==1?(h+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {
                   xTexelC${n} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${n}.zw = vec2(0.0);
                   }
                   xTexelC${n}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${n+1}Ready == 0) {
                   xTexelC${n+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${n+1}.zw = vec2(0.0);
                   }
                   xTexelC${n+1}Ready = 1;
                 }

                 xC${n} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);
               `,n+1<u&&(h+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${n+1} = vec4(xTexelC${n+1}.xy, final.xy);
                 `)):(h+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {
                   xTexelC${n} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${n}.zw = vec2(0.0);
                   }
                   xTexelC${n}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {
                   xTexelC${n+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${n+1}.zw = vec2(0.);
                   }
                   xTexelC${n+1}Ready = 1;
                 }

                 xC${n} = vec4(
                   xTexelC${n}.xy, xTexelC${n+1}.xy);
               `,n+1<u&&(h+=`
                   xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);
                 `)));n<u&&(h+=`
             wTexel = getW(r, ${n}, d1, d2);
             dotProd += xC${n}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${n}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,n+1<u&&(h+=`
               wTexel = getW(r, ${n+1}, d1, d2);
               dotProd += xC${n+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${n+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}h+=`
     }
   
     }
   
     }
   `;let p="",d="";n&&(p=r?`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${n}
         }`:a?`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${n}
         }`:`vec4 activation(vec4 x) {
           ${n}
         }`,d="result = activation(result);"),t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${p}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${h}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${t?"result += getBiasAtOutCoords();":""}
         ${d}
         setOutput(result);
       }
     `}}var ha=ha;class CD{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=NX(this.outputShape.length);const{dataFormat:n}=t,r=NE(),a="channelsLast"===n,s=a?1:2,i=a?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let l="";for(let e=0;e<=1;e++)for(let t=0;t<=1;t++)l+=`
          blockIndex = rc.z + ${t};
          pos = rc.y + ${e};

          ${o}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${s}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${a}) {
                  innerDims = vec2(d1, ch);
                  result[${2*e+t}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${2*e+t}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${r.output} = result;
      }
    `}}function CO(e,t){let n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function CM({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let l,u=e.shape,h=r.texData.get(e.dataId),p=n.inChannels,d=u[0]*u[1]*u[2],c=n.outChannels,f="channelsLast"===n.dataFormat,m=[];if(null!=s){let e=CO(s.shape,f);null!=e&&(s=SG({inputs:{x:s},backend:r,attrs:{shape:e}}),m.push(s))}if(null!=a){let e=CO(a.shape,f);null!=e&&(a=SG({inputs:{x:a},backend:r,attrs:{shape:e}}),m.push(a))}if(!((1===d||1===c)&&p>1e3)&&h.isPacked&&f&&null!=h.texture&&u[2]%2!=0&&ha.arraysEqual(h.shape.slice(-3),u.slice(-3))){let p=u[0]*u[1]*(u[2]+1),d={dataId:e.dataId,shape:[1,p,n.inChannels],dtype:e.dtype},c=h.shape;h.shape=h.shape.slice(),h.shape[h.shape.length-2]++,ha.assert(Nm(h.shape,d.shape),()=>`packed reshape ${h.shape} to ${d.shape} isn't free`);let f=SG({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});m.push(f);let g=S0({a:d,b:f,backend:r,transposeA:!1,transposeB:!1,bias:a,activation:o,preluActivationWeights:s,leakyreluAlpha:i}),y=r.texData.get(g.dataId);ha.assert(y.isPacked,()=>"batchMatMul result is expected to be packed"),h.shape=c,y.shape=n.outShape,(l=SR({inputs:{x:g},backend:r})).shape=n.outShape,m.push(g)}else{let u=n.outHeight*n.outWidth,h=SG({inputs:{x:e},backend:r,attrs:{shape:f?[n.batchSize,u,n.inChannels]:[n.batchSize,n.inChannels,u]}}),p=SG({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),d=S0({a:f?h:p,b:f?p:h,transposeA:!f,transposeB:!1,backend:r,bias:a,activation:o,preluActivationWeights:s,leakyreluAlpha:i});l=SG({inputs:{x:d},backend:r,attrs:{shape:n.outShape}}),m.push(h),m.push(p),m.push(d)}for(let e of m)r.disposeIntermediateTensorInfo(e);return l}function CL({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let{filterWidth:l,filterHeight:u,inChannels:h,outWidth:p,outHeight:d,dataFormat:c}=n,f="channelsLast"===c,m=l*u*h,g=d*p,y=[n.batchSize,m,g],x=[];if(null!=s){let e=CO(s.shape,f);null!=e&&(s=SG({inputs:{x:s},backend:r,attrs:{shape:e}}),x.push(s))}if(null!=a){let e=CO(a.shape,f);null!=e&&(a=SG({inputs:{x:a},backend:r,attrs:{shape:e}}),x.push(a))}let b=SG({inputs:{x:t},backend:r,attrs:{shape:[1,m,ha.sizeFromShape(t.shape)/m]}});x.push(b);let w=new CD(y,n),v=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],k=r.runWebGLProgram(w,[e],"float32",v),N=SG({inputs:{x:k},backend:r,attrs:{shape:y}});x.push(k),x.push(N);let I=null!=a,S=null!=s,C="leakyrelu"===o,T=o?SB(o,!0):null,$=new SW(f?N.shape:b.shape,f?b.shape:N.shape,f?[n.batchSize,g,n.outChannels]:[n.batchSize,n.outChannels,g],!0,!1,I,T,S,C),E=f?[N,b]:[b,N];if(a&&E.push(a),S&&E.push(s),C){let e=r.makeTensorInfo([],"float32",ha.createScalarValue(i,"float32"));E.push(e),x.push(e)}let A=r.runWebGLProgram($,E,"float32"),R=SG({inputs:{x:A},backend:r,attrs:{shape:n.outShape}});for(let e of(x.push(A),x))r.disposeIntermediateTensorInfo(e);return R}var lz=lz;class Cz{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s="channelsLast"===e.dataFormat;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${s?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class CP{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,o=n-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${s?3:1}];

        ivec2 dyCorner = ivec2(coords[${s?1:2}], coords[${s?2:3}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${s}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class CB{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${a};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${s};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${i};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class CW{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${o}, ${l}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${a}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}var lz=lz;class CU{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=NX(this.outputShape.length);const t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,a=n-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            int wCPerm = ${n} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}var lz=lz,lz=lz,lz=lz;let Cj=Sz({opSnippet:SL+`
  return cos(x);
`,packedOpSnippet:`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${SE}
  return result;
`}),CV=Sz({opSnippet:`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`});class CG{constructor(e,t,n,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[s,i,o,l]=e,[u]=t,[h,p]=n;this.outputShape=[u,h,p,l];const[d,c]=[`${i-1}.0`,`${o-1}.0`],[f,m,g]=h>1?[`${(i-1)/(h-1)}`,"(y2-y1) * height_ratio",`y1*${d} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${d}`],[y,x,b]=p>1?[`${(o-1)/(p-1)}`,"(x2-x1) * width_ratio",`x1*${c} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${c}`];this.userCode=`
      const float height_ratio = float(${f});
      const float width_ratio = float(${y});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${s}) {
          return;
        }

        float height_scale = ${m};
        float width_scale = ${x};

        float in_y = ${g};
        if( in_y < 0.0 || in_y > ${d} ) {
          setOutput(float(${a}));
          return;
        }
        float in_x = ${b};
        if( in_x < 0.0 || in_x > ${c} ) {
          setOutput(float(${a}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${+("bilinear"===r)} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}(I=P||(P={})).Prod="*",I.Sum="+";class CH{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const a=this.outputShape.length,s=this.op===P.Prod?"1.0":"0.0",i=n?s:`getX(${Cq(a,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1];let l="",u="";n?(l=r?`end != ${o-1}`:"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Nj(a)} coords = getOutputCoords();
        int end = ${CK(a,"coords",this.op)};
        float val = ${i};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${u};
          ${CK(a,"coords",this.op)} = idx;
          val ${this.op}= getX(${Cq(a,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function Cq(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function CK(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw Error(`Cumulative ${n} for rank ${e} is not yet supported`)}var lz=lz;function CX(e,t,n,r,a,s){let i=t.shape.length,o=lz.getAxesPermutation([r],i),l=t;null!=o&&(l=SQ({inputs:{x:t},backend:n,attrs:{perm:o}}));let u=lz.getInnerMostAxes(1,i)[0];if(u!==i-1)throw Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);let h=l.shape[u],p=SR({inputs:{x:l},backend:n});for(let t=0;t<=Math.ceil(Math.log2(h))-1;t++){let r=new CH(e,l.shape,!1,s),a=[[t]],i=p;p=n.runWebGLProgram(r,[p],p.dtype,a),n.disposeIntermediateTensorInfo(i)}if(a){let t=new CH(e,l.shape,a,s),r=p;p=n.runWebGLProgram(t,[p],p.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=o){let e=SQ({inputs:{x:p},backend:n,attrs:{perm:lz.getUndoAxesPermutation(o)}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(l),e}return p}class CY{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}var lz=lz,ha=ha;class CZ{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=NX(this.outputShape.length);const s=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels;let l="",u="";n&&(l=r?`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:a?`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:`
          float activation(float x) {
            ${n}
          }
        `,u="result = activation(result);"),t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${s}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${t?"result += getBiasAtOutCoords();":""}
        ${u}
        setOutput(result);
      }
    `}}var ha=ha;class CJ{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=NX(this.outputShape.length);const s=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,h=e.filterWidth;let p=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let e=0;e<h;e++)p+=`
          vec4 xTexelC${2*e};
          int xTexelC${2*e}Ready;
          vec4 xTexelC${2*e+1};
          int xTexelC${2*e+1}Ready;
          vec4 xC${e};`;p+=`
    for (int r = 0; r < ${u}; r++) {
      `;for(let e=0;e<h;e++)p+=`
          xTexelC${2*e} = vec4(0.0);
          xTexelC${2*e}Ready = 0;
          xTexelC${2*e+1} = vec4(0.0);
          xTexelC${2*e+1}Ready = 0;
          xC${e} = vec4(0.0);`;p+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let e=0;e<(h+1)/2;e++){const t=2*e;if(p+=`
          xC = xCCorner + ${t*l};
          `,1===o){if(t<h&&(i%2==1?(p+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {
                  xTexelC${t} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${t}.zw = vec2(0.0);
                  }
                  xTexelC${t}Ready = 1;
                }
              `,1===l&&t>0?p+=`
                xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);
                `:p+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${t} = vec4(previous.zw, xTexelC${t}.xy);
                  } else {
                    xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);
                  }
                  `):p+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {
                  xTexelC${t} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${t}.zw = vec2(0.0);
                  }
                  xTexelC${t}Ready = 1;
                }

                xC${t} = xTexelC${t};
                `,t+1<h)){const e=i%2==0?ha.nearestLargerEven(l):l;l%2==0&&i%2==1||l%2!=0&&i%2!=1?(p+=`
                  xCOffset = xC + imod(pads[1], 2) + ${e};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {
                    xTexelC${t+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${t+1}.zw = vec2(0.0);
                    }
                    xTexelC${t+1}Ready = 1;
                  }
                  `,l>1?p+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);
                    } else {
                     xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);
                    }
                    `:p+=`
                    xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);
                    `):1===e?p+=`
                    xC${t+1} = xTexelC${t};
                    `:p+=`
                    xCOffset = xC + ${e};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {
                      xTexelC${t+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${t+1}.zw = vec2(0.0);
                      }
                      xTexelC${t+1}Ready = 1;
                    }

                    xC${t+1} = xTexelC${t+1};
                    `}}else t<h&&(i%2==1?(p+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {
                  xTexelC${t} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${t}.zw = vec2(0.0);
                  }
                  xTexelC${t}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {
                  xTexelC${t+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${t+1}.zw = vec2(0.0);
                  }
                  xTexelC${t+1}Ready = 1;
                }

                xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);
              `,t+1<h&&(p+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);
                `)):(p+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {
                  xTexelC${t} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${t}.zw = vec2(0.0);
                  }
                  xTexelC${t}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {
                  xTexelC${t+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${t+1}.zw = vec2(0.);
                  }
                  xTexelC${t+1}Ready = 1;
                }

                xC${t} = vec4(
                  xTexelC${t}.xy, xTexelC${t+1}.xy);
              `,t+1<h&&(p+=`
                  xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);
                `)));t<h&&(p+=`
            wTexel = getW(r, ${t}, d1, q);
            dotProd += xC${t} * vec4(wTexel.xz, wTexel.xz);
          `,t+1<h&&(p+=`
              wTexel = getW(r, ${t+1}, d1, q);
              dotProd += xC${t+1} * vec4(wTexel.xz, wTexel.xz);
            `))}p+=`
    }
  
      }
    `;let d="",c="";n&&(d=r?`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:a?`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:`vec4 activation(vec4 x) {
          ${n}
        }`,c="result = activation(result);"),t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${d}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${s};
        int q = d2 - d1 * ${s};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${p}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${t?"result += getBiasAtOutCoords();":""}
        ${c}
        setOutput(result);
      }
    `}}var lz=lz;class CQ{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${s} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class C0{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${s}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${o}; dm++) {
              int d2 = d1 * ${o} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}var lz=lz,ha=ha;class C1{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}var lz=lz;class C2{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:a,strideWidth:s,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:h,left:p}=r;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${s});
      const ivec2 pads = ivec2(${h}, ${p});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${o}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}var lz=lz,ha=ha;let C3=Sz({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`}),C4=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,C5=SP({opSnippet:"return float(a == b);",packedOpSnippet:`
  return vec4(equal(a, b));
`,dtype:"bool",cpuKernelImpl:IN});var lz=lz;let C6=Sz({opSnippet:`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${lz.ERF_P};
  float a1 = ${lz.ERF_A1};
  float a2 = ${lz.ERF_A2};
  float a3 = ${lz.ERF_A3};
  float a4 = ${lz.ERF_A4};
  float a5 = ${lz.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`}),C8=Sz({opSnippet:SL+`
  return exp(x);
`,packedOpSnippet:`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,cpuKernelImpl:II,dtype:"float32"});var ha=ha;function C7(e){let{inputs:t,attrs:n,backend:r}=e,{dim:a}=n,{input:s}=t,i=s.shape.length,o=s.shape.slice(),l=a;return a<0&&(ha.assert(-(i+1)<=a,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+a+1),o.splice(l,0,1),SG({inputs:{x:s},backend:r,attrs:{shape:o}})}let C9="return exp(x) - 1.0;",Te=Sz({opSnippet:C9,packedOpSnippet:C9,cpuKernelImpl:IS});var ha=ha;class Tt{constructor(e,t,n){let r;this.variableNames=["real","imag"];const a=t[1];this.outputShape=t;const s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=n?`${a}.0`:"1.0";if("real"===e)r="return real * expR - imag * expI;";else if("imag"===e)r="return real * expI + imag * expR;";else throw Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${r}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${a});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${a}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}function Tn(e,t,n){let r=n.texData.get(e.dataId),a=ha.sizeFromShape(e.shape),s=e.shape[e.shape.length-1],i=SG({inputs:{x:e},backend:n,attrs:{shape:[a/s,s]}}),o=i.shape,l=new Tt("real",o,t),u=new Tt("imag",o,t),h=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:o},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:o}],p=n.runWebGLProgram(l,h,"float32"),d=n.runWebGLProgram(u,h,"float32"),c=SF({inputs:{real:p,imag:d},backend:n});n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d);let f=SG({inputs:{x:c},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(c),f}var ha=ha;class Tr{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}function Ta(e){let{backend:t,attrs:n}=e,{shape:r,value:a}=n,{dtype:s}=n;if("string"===(s=s||ha.inferDtype(a))){let e=ha.getArrayFromDType(s,ha.sizeFromShape(r));return e.fill(a),t.makeTensorInfo(r,s,e)}{let e=new Tr(r,a),n=[[a]];return t.runWebGLProgram(e,[],s,n)}}class Ts{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}let Ti="return floor(x);",To=Sz({opSnippet:Ti,packedOpSnippet:Ti,cpuKernelImpl:IC}),Tl=SP({opSnippet:`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,packedOpSnippet:`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,dtype:"int32"});class Tu{constructor(e){this.variableNames=["A"];const t=NE(),[n,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}class Th{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=NE(),[n,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${n}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}let Tp=tU.getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");var lz=lz,ha=ha,lz=lz,ha=ha,lz=lz,ha=ha;class Td{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;const a=Nj(n.length);let s=`
    int index;`;for(let e=0;e<this.sliceDim;e++)s+=`
          index = round(getIndices(coords[0], ${e}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[e]};
          flattenIndex += index * ${this.strides[e]};`;this.userCode=`
         void main() {
          ${a} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${s}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}var lz=lz,ha=ha;class Tc{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=Nj(this.rank),r=function(e,t){let n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let t=0;t<e.length;t++)2===t?r.push("index"):r.push(`${n[t]}`);return r.join()}(e,0);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}function Tf(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r,l=ha.parseAxisParam(i,a.shape)[0];if(tU.get("DEBUG")){let e=n.readSync(s.dataId),t=a.shape[l];for(let n=0;n<e.length;++n){let r=e[n];ha.assert(r<=t-1&&r>=0,()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`)}}let u=lz.segment_util.collectGatherOpShapeInfo(a,s,l,o),h=ha.sizeFromShape(s.shape),p=[],d=SG({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),c=SG({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,h/u.batchSize]}});p.push(d),p.push(c);let f=[u.batchSize,u.outerSize,h/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([a,s])||"string"===a.dtype){let e=n.bufferSync(c),t=I$(n.bufferSync(d),e,f);return p.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(u.outputShape,t.dtype,t.values)}let m=new Tc(d.shape,f),g=n.runWebGLProgram(m,[d,c],d.dtype);p.push(g);let y=SG({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return p.forEach(e=>n.disposeIntermediateTensorInfo(e)),y}let Tm=SP({opSnippet:"return float(a > b);",packedOpSnippet:`
  return vec4(greaterThan(a, b));
`,cpuKernelImpl:IE,dtype:"bool"}),Tg=SP({opSnippet:"return float(a >= b);",packedOpSnippet:`
  return vec4(greaterThanEqual(a, b));
`,dtype:"bool",cpuKernelImpl:IA}),Ty=Sz({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),Tx=Sz({opSnippet:"return float(isinf(x));",dtype:"bool"}),Tb=Sz({opSnippet:"return float(isnan(x));",dtype:"bool"}),Tw=SP({opSnippet:"return float(a < b);",packedOpSnippet:`
  return vec4(lessThan(a, b));
`,cpuKernelImpl:IR,dtype:"bool"}),Tv=SP({opSnippet:"return float(a <= b);",packedOpSnippet:`
  return vec4(lessThanEqual(a, b));
`,cpuKernelImpl:IF,dtype:"bool"}),Tk=Sz({opSnippet:SL+`
  return x < 0.0 ? 0./0. : log(x);
`,packedOpSnippet:`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,cpuKernelImpl:ID}),TN=Sz({opSnippet:SL+`
  return log(1.0 + x);
`}),TI=SP({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,dtype:"bool"}),TS=Sz({opSnippet:"return float(!(x >= 1.0));"}),TC=SP({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,dtype:"bool"});class TT{constructor(e,t,n,r,a){let s;this.variableNames=["x"],this.outputShape=[];const i=e[3]-1;this.outputShape=e;const o=`float(${n}) + float(${r}) * sum`;s=.5===a?`inversesqrt(${o})`:1===a?`1.0/(${o})`:`exp(log(${o}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${t}; j <= ${t}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${s};
        setOutput(val);
      }
    `}}class T${constructor(e,t,n,r,a){let s;this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=e[3]-1;this.outputShape=e;const o=`float(${n}) + float(${r}) * sum`;s=.5===a?`inversesqrt(${o})`:1===a?`1.0/(${o})`:`exp(log(${o}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${t};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${t}; j <= ${t}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${s};
        setOutput(result);
      }
    `}}class TE{constructor(e,t,n,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=a,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${a})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${a});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}var lz=lz,ha=ha,ha=ha;function TA(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{reductionIndices:i,keepDims:o}=a,l=s.shape.length,u=ha.parseAxisParam(i,s.shape),h=u,p=lz.getAxesPermutation(h,l),d=null!=p,c=r.shouldExecuteOnCPU([s]),f=s;if(d){if(c){let e=r.texData.get(f.dataId).values,t=Array(l);for(let e=0;e<t.length;e++)t[e]=s.shape[p[e]];let n=I9(e,s.shape,s.dtype,p,t);f=r.makeTensorInfo(t,s.dtype),r.texData.get(f.dataId).values=n}else f=SZ(s,p,r);h=lz.getInnerMostAxes(h.length,l)}lz.assertAxesAreInnerMostDims("max",h,l);let[m,g]=lz.computeOutAndReduceShapes(f.shape,h),y=m;if(o&&(y=lz.expandShapeToKeepDim(m,u)),c){let e=IO(r.texData.get(f.dataId).values,ha.sizeFromShape(g),y,s.dtype);t=r.makeTensorInfo(y,s.dtype),r.texData.get(t.dataId).values=e}else{var x,b;let e,n,a,s,i;x=f,b=y,e=ha.sizeFromShape(g),n=ha.sizeFromShape(x.shape),s=SK(a=SG({inputs:{x},attrs:{shape:[n/e,e]},backend:r}),x.dtype,"max",r),i=SG({inputs:{x:s},attrs:{shape:b},backend:r}),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(s),t=i}return d&&r.disposeIntermediateTensorInfo(f),t}let TR=SP({opSnippet:ST+`
  return max(a, b);
`,packedOpSnippet:`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+SE+`
  return result;
`,cpuKernelImpl:IM});var lz=lz,ha=ha,lz=lz,lz=lz;class TF{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,s=e.effectiveFilterWidth,i=a-1-e.padInfo.top,o=s-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${a};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${a*s-1} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${s} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class T_{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,h=o-1-e.padInfo.front,p=l-1-e.padInfo.top,d=u-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${h}, ${p}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${o};
           wD += ${a}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${s}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${o*l*u-1} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}var lz=lz,lz=lz,ha=ha,lz=lz,ha=ha,ha=ha,lz=lz,ha=ha;let TD=SP({opSnippet:ST+`
  return min(a, b);
`,packedOpSnippet:`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+SE+`
  return result;
`,cpuKernelImpl:IL});class TO{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,a=Nj(r),s=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l=+("reflect"!==n);if(1===r){this.userCode=`
        int start = ${s};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${s});
      ${a} end = ${a}(${i});

      void main() {
        ${a} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${a} coords = outC - start;
        setOutput(getX(${o}));
      }
    `}}class TM{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,a=Nj(r),s=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=Sn("rc",r),l=Sn("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,h=1===r?"source":`vec2(${l.slice(-2).join()})`,p=+("reflect"!==n);let d="";if(1===r){const e=`
        ${a} source = rc;
        if (source < start) {
          source = start * 2 - source - ${p};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${p};
        }
        source -= start;
      `;d=`
        ${a} rc = outputLoc;
        ${e}
        result[0] = getChannel(getX(${l.join()}), ${h});
        ${o[r-1]} += 1;
        if(${u}) {
          ${e}
          result[1] = getChannel(getX(${l.join()}), ${h});
        }
      `}else{const e=`
        ${a} source = rc;
        ${a} lt = ${a}(lessThan(source, start));
        ${a} gte = ${a}(greaterThanEqual(source, end));
        ${a} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${p}) +
                gte * ((end - 1) * 2 - source + ${p});
        source -= start;
      `;d=`
        ${a} rc = outputLoc;
        ${e}
        result[0] = getChannel(getX(${l.join()}), ${h});
        ${o[r-1]} += 1;
        if(${u}) {
          ${e}
          result[1] = getChannel(getX(${l.join()}), ${h});
        }
        rc = outputLoc;
        ${o[r-2]} += 1;
        if(${o[r-2]} < ${this.outputShape[r-2]}) {
          ${e}
          result[2] = getChannel(getX(${l.join()}), ${h});
          ${o[r-1]} += 1;
          if(${u}) {
            ${e}
            result[3] = getChannel(getX(${l.join()}), ${h});
          }
        }
      `}this.userCode=`
      const ${a} start = ${a}(${s});
      const ${a} end = ${a}(${i});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}}let TL=SP({opSnippet:`if (b == 0.0) return NAN;
  return mod(a, b);`,packedOpSnippet:`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+SE+`
  return result;
`});class Tz{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}var lz=lz,ha=ha;let TP=SP({opSnippet:`
if (a == b) {
  return 1.0;
};
return a / b;`,packedOpSnippet:`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,checkOutOfBounds:!0}),TB="return a - b;",TW=SP({opSnippet:TB,packedOpSnippet:TB,supportsComplex:!0,cpuKernelImpl:I6});function TU(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=ha.parseAxisParam([s],a.shape),o=TA({inputs:{x:a},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=lz.expandShapeToKeepDim(o.shape,i),u=SG({inputs:{x:o},backend:n,attrs:{shape:l}}),h=TW({inputs:{a:a,b:u},backend:n}),p=C8({inputs:{x:h},backend:n}),d=SJ({inputs:{x:p},backend:n,attrs:{axis:i,keepDims:!1}}),c=SG({inputs:{x:d},backend:n,attrs:{shape:l}}),f=TP({inputs:{a:p,b:c},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),f}let Tj=Sh+`
  return -x;
`,TV=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;var lz=lz,b3=b3;let TG=b3.nonMaxSuppressionV3Impl;var lz=lz,b3=b3;let TH=b3.nonMaxSuppressionV4Impl;var lz=lz,b3=b3;let Tq=b3.nonMaxSuppressionV5Impl;var ha=ha;class TK{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${n}),
                      float(index == coords.y)));
      }
    `}}function TX(e){let{inputs:t,backend:n}=e,{x:r}=t;if("complex64"!==r.dtype)return Ta({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n});{let e=Cb({inputs:{input:r},backend:n}),t=TX({inputs:{x:e},backend:n}),a=CE({inputs:{input:r},backend:n}),s=TX({inputs:{x:a},backend:n}),i=SF({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}}var ha=ha,ha=ha;class TY{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,a=Nj(r),s=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(1===r){this.userCode=`
        int start = ${s};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${s});
      ${a} end = ${a}(${i});

      void main() {
        ${a} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${a} coords = outC - start;
          setOutput(getX(${o}));
        }
      }
    `}}class TZ{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,a=Nj(r),s=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=Sn("rc",r),l=Sn("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,h=1===r?"source":`vec2(${l.slice(-2).join()})`,p=[`${a} rc = outputLoc;`,`${o[r-1]} += 1;
       if(${u}) {
      `,1===r?"":`}
       rc = outputLoc;
       ${o[r-2]} += 1;
       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${o[r-1]} += 1;
         if(${u}) {`],d=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let c="";for(let e=0,t=1===r?2:4;e<t;e++)c+=`
        ${p[e]}
        if (${d}) {
          result[${e}] = float(value);
        } else {
          ${a} source = rc - start;
          result[${e}] = getChannel(getX(${l.join()}), ${h});
        }
      `;c+=1===r?"} ":"}}",this.userCode=`
      const ${a} start = ${a}(${s});
      const ${a} end = ${a}(${i});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${c}
        setOutput(result);
      }
    `}}let TJ=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;if(0===ha.sizeFromShape(a.shape))return Ta({backend:n,attrs:{shape:s.map((e,t)=>e[0]+a.shape[t]+e[1]),value:i,dtype:a.dtype}});let o=tU.getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new TZ(a.shape,s,i):new TY(a.shape,s,i),l=[[i]];return n.runWebGLProgram(o,[a],a.dtype,l)},TQ=SP({opSnippet:`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,packedOpSnippet:`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+SE+`
  return result;
`});var lz=lz,ha=ha;let T0=e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:i}=n,o=IG(r,a,s,i);return t.makeTensorInfo([o.length],i,o)},T1=Sz({opSnippet:"return 1.0 / x;"}),T2=Sz({opSnippet:Sh+`
  return (x < 0.0) ? 0.0 : x;
`,packedOpSnippet:`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`}),T3=Sz({opSnippet:Sh+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,packedOpSnippet:`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`});class T4{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];const[s,i,o,l]=e;this.outputShape=[s,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],h=[r&&t>1?t-1:t,r&&n>1?n-1:n];this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/h[0]},
          ${u[1]/h[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${a?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC"};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}class T5{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,i,o,l]=e;this.outputShape=[s,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],h=[r&&t>1?t-1:t,r&&n>1?n-1:n];this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/h[0]},
          ${u[1]/h[1]},
          ${u[1]/h[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${a?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC"};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}class T6{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],h=o[1]/l[1],p=1/u,d=1/h,c=2*Math.ceil(p)+2,f=2*Math.ceil(d)+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${h});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${d});

        const int winHeight = int(${c});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${s}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}class T8{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];const[s,i,o,l]=e;this.outputShape=[s,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],h=[r&&t>1?t-1:t,r&&n>1?n-1:n];this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/h[0]},
          ${u[1]/h[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${a?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC"};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${r?"0.5":"0.0"})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}class T7{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,i,o,l]=e;this.outputShape=[s,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],h=[r&&t>1?t-1:t,r&&n>1?n-1:n];this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/h[0]},
          ${u[1]/h[1]},
          ${u[1]/h[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${a?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC"};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${r?"0.5":"0.0"})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}class T9{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],h=o[1]/l[1],p=1/u,d=1/h,c=2*Math.ceil(p)+2,f=2*Math.ceil(d)+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${h});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${d});

        const int winHeight = int(${c});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${s}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${o[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${o[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${a}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}var ha=ha;class $e{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const r=e.map((n,r)=>-1!==t.indexOf(r)&&1!==e[r]?`${e[r]} - coords[${r}] - 1`:`coords[${r}]`).join(","),a=Nj(n);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${r}));
      }
    `}}class $t{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=Sn("rc",n),a=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=Nj(n);function o(n){let r=e.map((r,a)=>{var s,i;return s=a,i=n,-1!==t.indexOf(s)&&1!==e[s]?`${e[s]} - ${i[s]} - 1`:`${i[s]}`}),a=r.join(","),s=r.slice(-2).join(",");return`getChannel(getX(${a}), vec2(${s}))`}1===n?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${a}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${o(r.slice())};
          if(${a}){
            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",o(e)}(r.slice())};
          }
          if(${s}) {
            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};
            if(${a}) {
              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};
            }
          }
          setOutput(result);
        }
    `}}var lz=lz;class $n{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],r=e[2];this.outputShape=e;let a="";a="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${a}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}let $r=Sz({opSnippet:`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`}),$a=Sz({opSnippet:"return inversesqrt(x);",cpuKernelImpl:IH});var lz=lz;class $s{constructor(e,t,n,r,a,s,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;const l=Nj(a.length),u=Nj(s.length);let h="";1===n?h="i":2===n&&(h="i, j");const p=`getIndices(${h})`;let d="";1===r?d="i":2===r&&(d="i, coords[1]");const c=`getUpdates(${d})`;let f="";o&&(f="coords[0], coords[1]");const m=`getDefaultValue(${f})`;this.userCode=`
        ${l} strides = ${l}(${a});

        void main() {
          ${u} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${p});
              flattenedIndex += index * ${t>1?"strides[j]":"strides"};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${c};
              found = true;
            }
          }
          setOutput(mix(${m}, sum, float(found)));
        }
      `}}class $i{constructor(e,t,n,r,a,s,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;const l=Nj(a.length),u=Nj(s.length);let h="";1===n?h="i":2===n&&(h="i, j");const p=`getIndices(${h})`;let d="";1===r?d="i":2===r&&(d="i, coords[1]");const c=`getUpdates(${d})`;let f="";o&&(f="coords[0], coords[1]");const m=`getDefaultValue(${f})`;this.userCode=`
        ${l} strides = ${l}(${a});

        void main() {
          ${u} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${p});
              flattenedIndex += index.xz * ${t>1?"strides[j]":"strides"};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${t>1?"strides[j + 1]":"strides"};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${c};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${m}, sum, found));
        }
      `}}class $o{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,s=2===tU.getNumber("WEBGL_VERSION")?"while (left < right) {":a;this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${s}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${"left"===r?"<":"<="} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}class $l{constructor(e,t,n){let r,a;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)a="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],i=[];for(let r=0;r<t.length;r++)i.push(`${n[r]}`),r<e&&s.push(`${n[r]}`);r=s.join(),a=i.join()}const s=Nj(n);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${a}));
        } else {
          setOutput(getB(${a}));
        }
      }
    `}}var lz=lz;let $u=Sz({opSnippet:`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${lz.SELU_SCALEALPHA};
  float scale = ${lz.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`}),$h=Sz({opSnippet:SL+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,packedOpSnippet:`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,cpuKernelImpl:IK}),$p=Sz({opSnippet:`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`}),$d=Sz({opSnippet:SL+`
  return sin(x);
`,packedOpSnippet:`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${SE}
  return result;
`}),$c=Sz({opSnippet:`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`}),$f=Sz({opSnippet:`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`});var lz=lz,ha=ha,lz=lz,ha=ha,lz=lz,ha=ha;let $m="return sqrt(x);",$g=Sz({opSnippet:$m,packedOpSnippet:$m,cpuKernelImpl:I0}),$y=Sz({opSnippet:"return x * x;"}),$x="return (a - b) * (a - b);",$b=SP({opSnippet:$x,packedOpSnippet:$x});var lz=lz,vs=oB,ha=ha;class $w{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,a=Nj(n.length),s=Nj(n.length);let i="";if(1===r)i="coords * strides + begin";else{let e=0;i=n.map((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`)).join(",")}this.userCode=`
      ${a} begin = ${a}(${e});
      ${a} strides = ${a}(${t});

      void main() {
        ${s} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}let $v=Sz({opSnippet:"return tan(x);"}),$k=Sz({opSnippet:`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`});var lz=lz,ha=ha;class $N{constructor(e,t){this.variableNames=["A"];const n=Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.rank=n.length;const r=Nj(this.rank),a=function(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let t=0;t<e.length;t++)r.push(`imod(${n[t]}, ${e[t]})`);return r.join()}(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${a}));
      }
    `}}function $I(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;if("string"===a.dtype||a.shape.length>5){let e=n.readSync(a.dataId),t="string"===a.dtype?e.map(e=>ha.decodeString(e)):e,r=I8(sW(a.shape,a.dtype,t),s);return n.makeTensorInfo(r.shape,r.dtype,r.values)}let i=new $N(a.shape,s);return n.runWebGLProgram(i,[a],a.dtype)}var ha=ha;class $S{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class $C{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}function $T(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function $$(e){let t=1;for(;t<e;)t*=2;return t}class $E{constructor(e,t,n,r,a,s){let i;switch(this.variableNames=["Image","Transforms"],this.outputShape=s,r){case"constant":default:i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${i} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${i} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${i} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${a});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${a});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${"nearest"===n?1:2} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}var lz=lz,ha=ha;class $A{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,a=e.inSize,s=e.numSegments,i=s*Math.ceil(a/n);this.outputShape=[r,i];const o=4*Math.floor(n/4),l=n%4,u=`
        sumValue += dot(values, segFilter);
    `;let h="";a%n>0&&(h=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `);let p="";a%n>0&&(p=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = 0.0;

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${p}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${s})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${s})));

        float sumValue = 0.0;

        for (int i = 0; i < ${o}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${u}
        }

        int inIdx = inOffset + ${o};
        if (${1===l}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${u}
        } else if (${2===l}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${u}
        } else if (${3===l}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${u}
        }
        setOutput(sumValue);
      }
    `}}for(let e of[{kernelName:ar,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:h,leakyreluAlpha:p}=r;return S0({a,b:s,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:p,activation:h})}},{kernelName:"Abs",backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r}=e,{x:a}=n;if(r.shouldExecuteOnCPU([a])&&"complex64"!==a.dtype){let e=IX(r.texData.get(a.dataId).values);return r.makeTensorInfo(a.shape,a.dtype,e)}return t=tU.getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Sx(a.shape,S1):new Su(a.shape,S1),r.runWebGLProgram(t,[a],a.dtype)}},{kernelName:tG,backendName:"webgl",kernelFunc:S2},{kernelName:tH,backendName:"webgl",kernelFunc:S3},{kernelName:"Add",backendName:"webgl",kernelFunc:S5},{kernelName:tq,backendName:"webgl",kernelFunc:function e(t){let{inputs:n,backend:r}=t;if(1===n.length)return SR({inputs:{x:n[0]},backend:r});if(n.length>tU.getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let t=Math.floor(n.length/2),a=e({inputs:n.slice(0,t),backend:r}),s=e({inputs:n.slice(t),backend:r});return e({inputs:[a,s],backend:r})}let a=n.map(e=>e.dtype).reduce((e,t)=>aD(e,t)),s=n.map(e=>e.shape),i=tU.getBool("WEBGL_PACK")?new S8(n[0].shape,s):new S6(n[0].shape,s);return r.runWebGLProgram(i,n,a)}},{kernelName:"All",backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{axis:i,keepDims:o}=a,l=s.shape.length,u=ha.parseAxisParam(i,s.shape),h=u,p=lz.getAxesPermutation(h,l),d=s;null!=p&&(d=SQ({inputs:{x:s},backend:r,attrs:{perm:p}}),h=lz.getInnerMostAxes(h.length,l)),lz.assertAxesAreInnerMostDims("all",h,l);let[c,f]=lz.computeOutAndReduceShapes(d.shape,h),m=SG({inputs:{x:d},backend:r,attrs:{shape:[-1,ha.sizeFromShape(f)]}}),g=SK(m,m.dtype,"all",r);return t=o?SG({inputs:{x:g},backend:r,attrs:{shape:lz.expandShapeToKeepDim(c,u)}}):SG({inputs:{x:g},backend:r,attrs:{shape:c}}),r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),null!=p&&r.disposeIntermediateTensorInfo(d),t}},{kernelName:"Any",backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{axis:i,keepDims:o}=a,l=s.shape.length,u=ha.parseAxisParam(i,s.shape),h=u,p=lz.getAxesPermutation(h,l),d=s;null!=p&&(d=SQ({inputs:{x:s},backend:r,attrs:{perm:p}}),h=lz.getInnerMostAxes(h.length,l)),lz.assertAxesAreInnerMostDims("any",h,l);let[c,f]=lz.computeOutAndReduceShapes(d.shape,h),m=SG({inputs:{x:d},backend:r,attrs:{shape:[-1,ha.sizeFromShape(f)]}}),g=SK(m,m.dtype,"any",r);return t=o?SG({inputs:{x:g},backend:r,attrs:{shape:lz.expandShapeToKeepDim(c,u)}}):SG({inputs:{x:g},backend:r,attrs:{shape:c}}),r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),null!=p&&r.disposeIntermediateTensorInfo(d),t}},{kernelName:tK,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r,i=ha.parseAxisParam(s,a.shape),o=lz.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(u.push(l=SQ({inputs:{x:a},backend:n,attrs:{perm:o}})),i=lz.getInnerMostAxes(i.length,l.shape.length)),lz.assertAxesAreInnerMostDims("argMax",[i[0]],l.shape.length);let h=Ce(n,l,i[0],"max");return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),h}},{kernelName:tX,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r,i=ha.parseAxisParam(s,a.shape),o=lz.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(u.push(l=SQ({inputs:{x:a},backend:n,attrs:{perm:o}})),i=lz.getInnerMostAxes(i.length,l.shape.length)),lz.assertAxesAreInnerMostDims("argMin",[i[0]],l.shape.length);let h=Ce(n,l,i[0],"min");return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),h}},{kernelName:tY,backendName:"webgl",kernelFunc:Ct},{kernelName:tZ,backendName:"webgl",kernelFunc:Cn},{kernelName:tJ,backendName:"webgl",kernelFunc:Cr},{kernelName:t0,backendName:"webgl",kernelFunc:Ca},{kernelName:tQ,backendName:"webgl",kernelFunc:Cs},{kernelName:t1,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;NT(a,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;ha.assert(lz.eitherStridesOrDilationsAreOne(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);let u=lz.computePool2DInfo(a.shape,s,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&ha.arraysEqual(u.inShape,u.outShape))return SR({inputs:{x:a},backend:n});let h=new Ci(u,"avg",!1);return n.runWebGLProgram(h,[a],"float32")}},{kernelName:t3,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,h=new Co(lz.computePool3DInfo(a.shape,s,i,[1,1,1],o,l,u),"avg",!1);return n.runWebGLProgram(h,[a],"float32")}},{kernelName:t4,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r,h=new Cu(lz.computePool3DInfo(s.shape,i,o,[1,1,1],l,u));return n.runWebGLProgram(h,[a],s.dtype)}},{kernelName:t2,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t;NT([a,s],"avgPoolGrad");let{filterSize:i,strides:o,pad:l}=r,u=new Cl(lz.computePool2DInfo(s.shape,i,o,1,l));return n.runWebGLProgram(u,[a],s.dtype)}},{kernelName:t5,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s}=t,{transposeA:i,transposeB:o}=r;return S0({a,b:s,transposeA:i,transposeB:o,backend:n})}},{kernelName:nM,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,mean:a,variance:s,offset:i,scale:o}=e;ha.assert(a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),ha.assert(null==i||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),ha.assert(null==o||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;null==l&&(l=.001);let u=[r,a,s],h=null;null!=i&&(h=i.shape,u.push(i));let p=null;null!=o&&(p=o.shape,u.push(o));let d=tU.getBool("WEBGL_PACK_NORMALIZATION")?new Cp(r.shape,a.shape,s.shape,h,p,l):new Ch(r.shape,a.shape,s.shape,h,p,l);return t.runWebGLProgram(d,u,u[0].dtype)}},{kernelName:t6,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;ha.assert(a.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let o=s.reduce((e,t)=>e*t),l=lz.getReshaped(a.shape,s,o),u=lz.getPermuted(l.length,s.length),h=lz.getReshapedPermuted(a.shape,s,o),p=lz.getSliceBeginCoords(i,s.length),d=lz.getSliceSize(h,i,s.length),c=[],f=SG({inputs:{x:a},backend:n,attrs:{shape:l}}),m=SQ({inputs:{x:f},backend:n,attrs:{perm:u}}),g=SG({inputs:{x:m},backend:n,attrs:{shape:h}}),y=Cm({inputs:{x:g},backend:n,attrs:{begin:p,size:d}});return c.push(f),c.push(m),c.push(g),c.forEach(e=>n.disposeIntermediateTensorInfo(e)),y}},{kernelName:t8,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=Iy(n.readSync(a.dataId),n.readSync(s.dataId),s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,o)}},{kernelName:t7,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r}=e,{a,b:s}=n,i=tU.getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=tU.getNumber("WEBGL_VERSION");if(r.shouldExecuteOnCPU([a,s])||1===o){let e=r.texData.get(a.dataId).values,t=r.texData.get(s.dataId).values,[n,i]=Ib(a.shape,s.shape,e,t,a.dtype),o=r.makeTensorInfo(i,a.dtype);return r.texData.get(o.dataId).values=n,o}return t=i?new SA(Cg,a.shape,s.shape,!1):new S$(Cy,a.shape,s.shape),r.runWebGLProgram(t,[a,s],a.dtype)}},{kernelName:t9,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.readSync(r.dataId),i=n.readSync(a.dataId),o=lz.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},{kernelName:ne,backendName:"webgl",kernelFunc:function e(t){let{inputs:n,backend:r,attrs:a}=t,{x:s}=n,{dtype:i}=a;if("complex64"===i){if("complex64"===s.dtype)return SR({inputs:{x:s},backend:r});let t=oy(s.shape),n=e({inputs:{x:s},backend:r,attrs:{dtype:"float32"}}),a=SF({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),a}if("complex64"===s.dtype){let t=Cb({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:i}});return r.disposeIntermediateTensorInfo(t),n}if(!ha.hasEncodingLoss(s.dtype,i)){let e=SR({inputs:{x:s},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:i}}if(r.shouldExecuteOnCPU([s])){let[e,t,n]=Iw(r.texData.get(s.dataId).values,s.shape,s.dtype,i);return r.makeTensorInfo(e,t,n)}if("int32"===i){let e,t;return e=new Su(s.shape,"return float(int(x));"),{dataId:(t=r.runWebGLProgram(e,[s],"int32")).dataId,shape:t.shape,dtype:t.dtype}}if("bool"===i){let e=r.makeTensorInfo([],"bool",ha.getTypedArrayFromDType("bool",1)),t=Cx({inputs:{a:s,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw Error(`Error in Cast: failed to cast ${s.dtype} to ${i}`)}},{kernelName:nt,backendName:"webgl",kernelFunc:Cv},{kernelName:nn,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{clipValueMin:i,clipValueMax:o}=a;return t=tU.getBool("WEBGL_PACK_CLIP")?new CN(s.shape):new Ck(s.shape),r.runWebGLProgram(t,[s],s.dtype,[[i],[o]])}},{kernelName:nr,backendName:"webgl",kernelFunc:SF},{kernelName:na,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t,a=n.texData.get(r.dataId),s=new CI(r.shape),i=[CS(r,a.complexTensorInfos.real),CS(r,a.complexTensorInfos.imag)];return n.runWebGLProgram(s,i,i[0].dtype)}},{kernelName:ns,backendName:"webgl",kernelFunc:CA},{kernelName:ni,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s,filter:i}=n,{strides:o,pad:l,dataFormat:u,dilations:h,dimRoundingMode:p}=a,d=lz.convertConv2DDataFormat(u),c=lz.computeConv2DInfo(s.shape,i.shape,o,h,l,p,!1,d);if(1===c.filterHeight&&1===c.filterWidth&&1===c.dilationHeight&&1===c.dilationWidth&&1===c.strideHeight&&1===c.strideWidth&&("SAME"===c.padInfo.type||"VALID"===c.padInfo.type))t=CM({x:s,filter:i,convInfo:c,backend:r});else if(c.strideWidth<=2&&"channelsLast"===d&&tU.getBool("WEBGL_EXP_CONV")){let e=new C_(c),n=[[c.padInfo.top,c.padInfo.left],[c.strideHeight,c.strideWidth],[c.dilationHeight,c.dilationWidth],[c.inHeight,c.inWidth]];t=r.runWebGLProgram(e,[s,i],"float32",n)}else if(tU.getBool("WEBGL_CONV_IM2COL"))t=CL({x:s,filter:i,convInfo:c,backend:r});else{let e=new CR(c);t=r.runWebGLProgram(e,[s,i],"float32")}let f=SG({inputs:{x:t},backend:r,attrs:{shape:c.outShape}});return r.disposeIntermediateTensorInfo(t),f}},{kernelName:no,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:h}=r,p=lz.convertConv2DDataFormat(l),d=new Cz(lz.computeConv2DInfo(a.shape,h,i,1,o,u,!1,p));return n.runWebGLProgram(d,[a,s],"float32")}},{kernelName:nl,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:h}=r,p=lz.convertConv2DDataFormat(u),d=lz.computeConv2DInfo(i,s.shape,o,1,l,h,!1,p);if(tU.getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===p){let e=[[d.strideHeight,d.strideWidth]],t=new CU(d);return n.runWebGLProgram(t,[a,s],"float32",e)}{let e=new CP(d);return n.runWebGLProgram(e,[a,s],"float32")}}},{kernelName:nu,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,u=new CF(lz.computeConv3DInfo(a.shape,s.shape,i,l,o));return n.runWebGLProgram(u,[a,s],"float32")}},{kernelName:nh,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r,u=new CB(lz.computeConv3DInfo(a.shape,l,i,1,o));return n.runWebGLProgram(u,[a,s],"float32")}},{kernelName:np,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r,u=new CW(lz.computeConv3DInfo(l,s.shape,o,1,i));return n.runWebGLProgram(u,[a,s],"float32")}},{kernelName:"Cos",backendName:"webgl",kernelFunc:Cj},{kernelName:nd,backendName:"webgl",kernelFunc:CV},{kernelName:nm,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,h=new CG(a.shape,s.shape,o,l,u);return n.runWebGLProgram(h,[a,s,i],"float32")}},{kernelName:nc,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return CX(P.Prod,a,n,s,i,o)}},{kernelName:nf,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return CX(P.Sum,a,n,s,i,o)}},{kernelName:ng,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(1===a.shape.length){let e=Iy(n.readSync(a.dataId),n.readSync(s.dataId),s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,e)}if(2===a.shape.length){let e=Ix(n.bufferSync(a),n.bufferSync(s),i,o);return n.makeTensorInfo(e.shape,s.dtype,e.values)}throw Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}},{kernelName:ny,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r,o=a.shape[0],l="NHWC"===i?a.shape[1]:a.shape[2],u="NHWC"===i?a.shape[2]:a.shape[3],h="NHWC"===i?a.shape[3]:a.shape[1],p=l*s,d=u*s,c=h/(s*s),f=new CY("NHWC"===i?[o,p,d,c]:[o,c,p,d],s,i);return n.runWebGLProgram(f,[a],a.dtype)}},{kernelName:nx,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s,filter:i}=n,{strides:o,pad:l,dilations:u,dimRoundingMode:h}=a,p=u;null==p&&(p=[1,1]),ha.assert(lz.eitherStridesOrDilationsAreOne(o,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${p}'`);let d=lz.computeConv2DInfo(s.shape,i.shape,o,p,l,h,!0);t=tU.getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels==1?new CJ(d):new CZ(d);let c=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return r.runWebGLProgram(t,[s,i],"float32",c)}},{kernelName:nb,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:h}=r,p=new CQ(lz.computeConv2DInfo(a.shape,h,i,o,l,u,!0));return n.runWebGLProgram(p,[a,s],"float32")}},{kernelName:nw,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:h}=r,p=new C0(lz.computeConv2DInfo(h,s.shape,i,o,l,u,!0));return n.runWebGLProgram(p,[a,s],"float32")}},{kernelName:nv,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t,a=[...r.shape,...r.shape],s=ha.sizeFromShape(r.shape),i=SG({inputs:{x:r},backend:n,attrs:{shape:[s]}}),o=new C1(s),l=n.runWebGLProgram(o,[i],i.dtype),u=SG({inputs:{x:l},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}},{kernelName:nk,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s,filter:i}=n,{strides:o,pad:l,dilations:u}=a,h=lz.computeDilation2DInfo(s.shape,i.shape,o,l,"NHWC",u),p=new C2(h),d=SG({inputs:{x:t=r.runWebGLProgram(p,[s,i],"float32")},backend:r,attrs:{shape:h.outShape}});return r.disposeIntermediateTensorInfo(t),d}},{kernelName:nT,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,{allDims:s,summedDims:i,idDims:o}=lz.decodeEinsumEquation(a,t.length);lz.checkEinsumDimSizes(s.length,o,t);let{path:l,steps:u}=lz.getEinsumComputePath(i,o),h=u.length,p=null,d=s.length,c=[];for(let e=0;e<h;++e){for(let r of u[e]){let e,{permutationIndices:a,expandDims:s}=lz.getEinsumPermutation(d,o[r]);lz.isIdentityPermutation(a)?e=t[r]:(e=SQ({inputs:{x:t[r]},backend:n,attrs:{perm:a}}),c.push(e));let i=e.shape.slice();for(let e=0;e<s.length;++e)i.splice(s[e],0,1);ha.arraysEqual(e.shape,i)||(e=SG({inputs:{x:e},backend:n,attrs:{shape:i}}),c.push(e)),null===p?p=e:(p=SV({inputs:{a:e,b:p},backend:n}),c.push(p))}e<h-1&&(l[e]>=0&&(p=SJ({inputs:{x:p},backend:n,attrs:{axis:l[e]-(s.length-d),keepDims:!1}}),c.push(p)),d--)}for(let e of c)e!==p&&n.disposeIntermediateTensorInfo(e);return p}},{kernelName:"Elu",backendName:"webgl",kernelFunc:C3},{kernelName:n$,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e,{dy:r,y:a}=t,s=tU.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new SA(C4,r.shape,a.shape):new S$("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,a.shape);return n.runWebGLProgram(s,[r,a],r.dtype)}},{kernelName:nE,backendName:"webgl",kernelFunc:C5},{kernelName:"Erf",backendName:"webgl",kernelFunc:C6},{kernelName:"Exp",backendName:"webgl",kernelFunc:C8},{kernelName:nA,backendName:"webgl",kernelFunc:C7},{kernelName:nR,backendName:"webgl",kernelFunc:Te},{kernelName:"FFT",backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:r}=t;return Tn(r,!1,n)}},{kernelName:nF,backendName:"webgl",kernelFunc:Ta},{kernelName:n_,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{let{image:n}=e,r=new Ts(n.shape);return t.runWebGLProgram(r,[n],n.dtype)}},{kernelName:nD,backendName:"webgl",kernelFunc:To},{kernelName:nO,backendName:"webgl",kernelFunc:Tl},{kernelName:at,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{pixels:a}=t,{numChannels:s}=r,i="undefined"!=typeof HTMLVideoElement&&a instanceof HTMLVideoElement,o="undefined"!=typeof HTMLImageElement&&a instanceof HTMLImageElement,[u,h]=i?[a.videoWidth,a.videoHeight]:[a.width,a.height],p=[h,u],d=[h,u,s];if(o||i){let e=tU.getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==l||e!==Tp)&&(Tp=e,l=document.createElement("canvas").getContext("2d",{willReadFrequently:Tp})),l.canvas.width=u,l.canvas.height=h,l.drawImage(a,0,0,u,h),a=l.canvas}let c=n.makeTensorInfo(p,"int32");n.texData.get(c.dataId).usage=L.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(c.dataId),a);let f=tU.getBool("WEBGL_PACK")?new Th(d):new Tu(d),m=n.runWebGLProgram(f,[c],"int32");return n.disposeData(c.dataId),m}},{kernelName:aa,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s,filter:i,bias:o,preluActivationWeights:l}=n,{strides:u,pad:h,dataFormat:p,dilations:d,dimRoundingMode:c,activation:f,leakyreluAlpha:m}=a,g=lz.convertConv2DDataFormat(p),y=lz.computeConv2DInfo(s.shape,i.shape,u,d,h,c,!1,g),x=[],b=null!=o,w=null!=l,v="leakyrelu"===f,k=()=>{let e=[s,i],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){let t=SG({inputs:{x:e},backend:r,attrs:{shape:[e.shape[0],1,1]}});return x.push(t),t}return e};if(b&&e.push(t(o,p)),w&&e.push(t(l,p)),v){let t=r.makeTensorInfo([],"float32",ha.createScalarValue(m,"float32"));e.push(t),x.push(t)}return e};if(1===y.filterHeight&&1===y.filterWidth&&1===y.dilationHeight&&1===y.dilationWidth&&1===y.strideHeight&&1===y.strideWidth&&("SAME"===y.padInfo.type||"VALID"===y.padInfo.type))t=CM({x:s,filter:i,convInfo:y,backend:r,bias:o,activation:f,preluActivationWeights:l,leakyreluAlpha:m});else if(y.strideWidth<=2&&"channelsLast"===g&&tU.getBool("WEBGL_EXP_CONV")){let e=new C_(y,b,f?SB(f,!0):null,w,v),n=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],a=k();t=r.runWebGLProgram(e,a,"float32",n)}else if(tU.getBool("WEBGL_CONV_IM2COL"))t=CL({x:s,filter:i,convInfo:y,backend:r,bias:o,activation:f,preluActivationWeights:l,leakyreluAlpha:m});else{let e=new CR(y,b,f?SB(f,!1):null,w,v),n=k();t=r.runWebGLProgram(e,n,"float32")}let N=SG({inputs:{x:t},backend:r,attrs:{shape:y.outShape}});return x.push(t),x.forEach(e=>r.disposeIntermediateTensorInfo(e)),N}},{kernelName:as,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s,filter:i,bias:o,preluActivationWeights:l}=n,{strides:u,pad:h,dilations:p,dimRoundingMode:d,activation:c,leakyreluAlpha:f}=a,m=[],g=p;null==g&&(g=[1,1]),ha.assert(lz.eitherStridesOrDilationsAreOne(u,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${g}'`);let y=lz.computeConv2DInfo(s.shape,i.shape,u,g,h,d,!0),x=tU.getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels==1,b=c?SB(c,x):null,w=[s,i],v=null!=o,k=null!=l,N="leakyrelu"===c;if(v&&w.push(o),k&&w.push(l),N){let e=r.makeTensorInfo([],"float32",ha.createScalarValue(f,"float32"));w.push(e),m.push(e)}t=x?new CJ(y,v,b,k,N):new CZ(y,v,b,k,N);let I=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],S=r.runWebGLProgram(t,w,"float32",I);return m.forEach(e=>r.disposeIntermediateTensorInfo(e)),S}},{kernelName:nz,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=a.shape,i=s[s.length-1],o=ha.sizeFromShape(r.shape),[l,u,h,p]=lz.prepareAndValidate(r,a),d=SG({inputs:{x:a},backend:n,attrs:{shape:[u,i]}}),c=SG({inputs:{x:r},backend:n,attrs:{shape:[ha.sizeFromShape(r.shape)/h,h]}});if(n.shouldExecuteOnCPU([r,a])||"string"===r.dtype){let e=IT(n.readSync(a.dataId),n.bufferSync(r),r.dtype,u,i,h,p,r.shape,o);return n.makeTensorInfo(l,r.dtype,e.values)}let f=new Td(i,p,[u,h],r.shape),m=n.runWebGLProgram(f,[c,d],c.dtype),g=SG({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(m),g}},{kernelName:nL,backendName:"webgl",kernelFunc:Tf},{kernelName:nP,backendName:"webgl",kernelFunc:Tm},{kernelName:nB,backendName:"webgl",kernelFunc:Tg},{kernelName:nW,backendName:"webgl",kernelFunc:SR},{kernelName:nU,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:r}=t;return Tn(r,!0,n)}},{kernelName:nj,backendName:"webgl",kernelFunc:CE},{kernelName:nV,backendName:"webgl",kernelFunc:Ty},{kernelName:nG,backendName:"webgl",kernelFunc:Tx},{kernelName:nH,backendName:"webgl",kernelFunc:Tb},{kernelName:nq,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r,i=n.makeTensorInfo([],"float32",ha.createScalarValue(s,"float32")),o=tU.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new SA(SD,a.shape,i.shape):new S$(S_,a.shape,i.shape),l=n.runWebGLProgram(o,[a,i],"float32");return n.disposeIntermediateTensorInfo(i),l}},{kernelName:nK,backendName:"webgl",kernelFunc:Tw},{kernelName:nX,backendName:"webgl",kernelFunc:Tv},{kernelName:nY,backendName:"webgl",kernelFunc:function(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=I_(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}},{kernelName:"Log",backendName:"webgl",kernelFunc:Tk},{kernelName:nZ,backendName:"webgl",kernelFunc:TN},{kernelName:nJ,backendName:"webgl",kernelFunc:TI},{kernelName:nQ,backendName:"webgl",kernelFunc:TS},{kernelName:n0,backendName:"webgl",kernelFunc:TC},{kernelName:"LRN",backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r,u=tU.getBool("WEBGL_PACK_NORMALIZATION")?new T$(a.shape,s,i,o,l):new TT(a.shape,s,i,o,l);return n.runWebGLProgram(u,[a],a.dtype)}},{kernelName:n1,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:h}=r,p=new TE(a.shape,o,l,u,h);return n.runWebGLProgram(p,[a,s,i],a.dtype)}},{kernelName:"Max",backendName:"webgl",kernelFunc:TA},{kernelName:n2,backendName:"webgl",kernelFunc:TR},{kernelName:n3,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;NT(a,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;ha.assert(lz.eitherStridesOrDilationsAreOne(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);let u=lz.computePool2DInfo(a.shape,s,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&ha.arraysEqual(u.inShape,u.outShape))return SR({inputs:{x:a},backend:n});let h=new Ci(u,"max",!1);return n.runWebGLProgram(h,[a],a.dtype)}},{kernelName:n5,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=r,h=new Co(lz.computePool3DInfo(a.shape,s,i,[1,1,1],o,u,l),"max",!1);return n.runWebGLProgram(h,[a],a.dtype)}},{kernelName:n6,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r,h=lz.computePool3DInfo(s.shape,i,o,[1,1,1],l,u),p=new Co(h,"max",!0),d=n.runWebGLProgram(p,[s],s.dtype),c=new T_(h),f=n.runWebGLProgram(c,[a,d],s.dtype);return n.disposeIntermediateTensorInfo(d),f}},{kernelName:n4,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t;NT([s,i],"maxPoolGrad");let{filterSize:o,strides:l,pad:u,dimRoundingMode:h}=r,p=lz.computePool2DInfo(s.shape,o,l,1,u,h),d=new Ci(p,"max",!0),c=n.runWebGLProgram(d,[s],s.dtype),f=new TF(p),m=n.runWebGLProgram(f,[a,c],s.dtype);return n.disposeIntermediateTensorInfo(c),m}},{kernelName:n8,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let r,a,{x:s}=e,{filterSize:i,strides:o,pad:l,includeBatchInIndex:u}=t;ha.assert(4===s.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);let h=[1,1];ha.assert(lz.eitherStridesOrDilationsAreOne(o,h),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);let p=lz.computePool2DInfo(s.shape,i,o,h,l),[d,c]=(r=new Ci(p,"max",!1),a=n.runWebGLProgram(r,[s],"float32"),r=new Ci(p,"max",!0,!0,u),[a,n.runWebGLProgram(r,[s],"float32")]);return[d,c]}},{kernelName:n7,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{var r,a;let s,i,o,l,u,{x:h}=e,{keepDims:p,axis:d}=t,c=h.shape.length,f=ha.parseAxisParam(d,h.shape),m=f,g=lz.getAxesPermutation(m,c),y=null!=g,x=n.shouldExecuteOnCPU([h]),b=[],w=h;if(y){if(x){let e=n.texData.get(w.dataId).values,t=Array(c);for(let e=0;e<t.length;e++)t[e]=h.shape[g[e]];let r=I9(e,h.shape,h.dtype,g,t);w=n.makeTensorInfo(t,h.dtype),n.texData.get(w.dataId).values=r}else w=SZ(h,g,n);b.push(w),m=lz.getInnerMostAxes(m.length,c)}lz.assertAxesAreInnerMostDims("sum",m,c);let[v,k]=lz.computeOutAndReduceShapes(w.shape,m),N=v;p&&(N=lz.expandShapeToKeepDim(v,f));let I=(r=w,a=N,s=ha.sizeFromShape(k),i=ha.sizeFromShape(r.shape),l=SK(o=SG({inputs:{x:r},attrs:{shape:[i/s,s]},backend:n}),"float32","mean",n),u=SG({inputs:{x:l},attrs:{shape:a},backend:n}),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u);for(let e of b)n.disposeIntermediateTensorInfo(e);return I}},{kernelName:"Min",backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{axis:i,keepDims:o}=a,l=s.shape.length,u=ha.parseAxisParam(i,s.shape),h=u,p=lz.getAxesPermutation(h,l),d=s;null!=p&&(d=SQ({inputs:{x:s},backend:r,attrs:{perm:p}}),h=lz.getInnerMostAxes(h.length,s.shape.length)),lz.assertAxesAreInnerMostDims("min",h,l);let[c,f]=lz.computeOutAndReduceShapes(d.shape,h),m=SG({inputs:{x:d},backend:r,attrs:{shape:[-1,ha.sizeFromShape(f)]}}),g=SK(m,m.dtype,"min",r);return t=o?SG({inputs:{x:g},backend:r,attrs:{shape:lz.expandShapeToKeepDim(c,u)}}):SG({inputs:{x:g},backend:r,attrs:{shape:c}}),r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),null!=p&&r.disposeIntermediateTensorInfo(d),t}},{kernelName:n9,backendName:"webgl",kernelFunc:TD},{kernelName:re,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{paddings:a,mode:s}=n,i=tU.getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new TM(r.shape,a,s):new TO(r.shape,a,s);return t.runWebGLProgram(i,[r],r.dtype)}},{kernelName:"Mod",backendName:"webgl",kernelFunc:TL},{kernelName:rt,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r,l=o?a:TU({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),u=new Tz(l.shape[0],l.shape[1],s),h=n.runWebGLProgram(u,[l],"int32",[[i]]);return o||n.disposeIntermediateTensorInfo(l),h}},{kernelName:rn,backendName:"webgl",kernelFunc:SV},{kernelName:"Neg",backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r}=e,{x:a}=n;if(r.shouldExecuteOnCPU([a])){let[e,t]=IP(r.texData.get(a.dataId).values,a.shape,a.dtype);return r.makeTensorInfo(t,a.dtype,e)}return t=tU.getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Sx(a.shape,TV):new Su(a.shape,Tj),r.runWebGLProgram(t,[a],a.dtype)}},{kernelName:ra,backendName:"webgl",kernelFunc:function(e){lz.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,{selectedIndices:u}=TG(n.readSync(a.dataId),n.readSync(s.dataId),i,o,l);return n.makeTensorInfo([u.length],"int32",new Int32Array(u))}},{kernelName:rs,backendName:"webgl",kernelFunc:function(e){lz.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,{selectedIndices:h,validOutputs:p}=TH(n.readSync(a.dataId),n.readSync(s.dataId),i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},{kernelName:ri,backendName:"webgl",kernelFunc:function(e){lz.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,{selectedIndices:h,selectedScores:p}=Tq(n.readSync(a.dataId),n.readSync(s.dataId),i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([p.length],"float32",new Float32Array(p))]}},{kernelName:rr,backendName:"webgl",kernelFunc:Cx},{kernelName:rl,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r,u=ha.sizeFromShape(a.shape),h=new TK(u,i,o,l),p=SG({inputs:{x:a},backend:n,attrs:{shape:[u]}}),d=n.runWebGLProgram(h,[p],s);n.disposeIntermediateTensorInfo(p);let c=SG({inputs:{x:d},backend:n,attrs:{shape:[...a.shape,i]}});return n.disposeIntermediateTensorInfo(d),c}},{kernelName:ro,backendName:"webgl",kernelFunc:function e(t){let{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw Error("onesLike is not supported under string dtype");if("complex64"!==a.dtype)return Ta({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:r});{let t=Cb({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),s=CE({inputs:{input:a},backend:r}),i=TX({inputs:{x:s},backend:r}),o=SF({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}}},{kernelName:ru,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return C7({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach(e=>{ha.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),ha.assert(i===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=CA({inputs:t.map(e=>{let t=C7({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t}),backend:n,attrs:{axis:a}});return o.forEach(e=>n.disposeIntermediateTensorInfo(e)),l}},{kernelName:rh,backendName:"webgl",kernelFunc:TJ},{kernelName:"Pow",backendName:"webgl",kernelFunc:TQ},{kernelName:rp,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=tU.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new SA(SM,r.shape,a.shape):new S$(SO,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],"float32")}},{kernelName:rd,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{axis:i,keepDims:o}=a,l=s.shape.length,u=[],h=ha.parseAxisParam(i,s.shape),p=h,d=lz.getAxesPermutation(p,l),c=s;if(null!=d&&(c=SQ({inputs:{x:s},backend:r,attrs:{perm:d}}),p=lz.getInnerMostAxes(p.length,l),u.push(c)),lz.assertAxesAreInnerMostDims("prod",p,l),r.shouldExecuteOnCPU([c])){let e=r.texData.get(c.dataId).values,{outVals:n,outShape:a,outDtype:s}=IW(c.shape,c.dtype,e,p);t=r.makeTensorInfo(a,s,n)}else{let[e,n]=lz.computeOutAndReduceShapes(c.shape,p),a=SG({inputs:{x:c},backend:r,attrs:{shape:[-1,ha.sizeFromShape(n)]}}),i=SK(a,aO(s.dtype),"prod",r);t=SG({inputs:{x:i},backend:r,attrs:{shape:e}}),u.push(a),u.push(i)}if(o){u.push(t);let e=lz.expandShapeToKeepDim(t.shape,h);t=SG({inputs:{x:t},backend:r,attrs:{shape:e}})}return u.forEach(e=>r.disposeIntermediateTensorInfo(e)),t}},{kernelName:rc,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=r,l=a.map(e=>n.readSync(e.dataId)),u=a.map(e=>e.shape),h=n.readSync(s.dataId),p=n.readSync(i.dataId),[d,c,f]=IU(l,u,h,s.shape,s.dtype,p,i.shape,o),m=d.map(e=>n.makeTensorInfo([e.length],"int32",e)),g=n.makeTensorInfo(f,s.dtype,c);return m.concat([g])}},{kernelName:rf,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:s}=t,i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,h]=Ij(i,r.shape,r.dtype,o,a.shape,l,s.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([h.length],r.dtype,h)]}},{kernelName:rm,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.readSync(a.dataId),h=n.readSync(s.dataId),p=n.readSync(i.dataId),d=o.map(e=>n.readSync(e.dataId)),c=o.map(e=>e.shape),[f,m]=IV(u,a.shape,h,s.shape,s.dtype,p,i.shape,d,c,l);return n.makeTensorInfo(f,s.dtype,m)}},{kernelName:rg,backendName:"webgl",kernelFunc:T0},{kernelName:ry,backendName:"webgl",kernelFunc:Cb},{kernelName:nC,backendName:"webgl",kernelFunc:TP},{kernelName:rx,backendName:"webgl",kernelFunc:T1},{kernelName:rb,backendName:"webgl",kernelFunc:T2},{kernelName:rS,backendName:"webgl",kernelFunc:T3},{kernelName:rw,backendName:"webgl",kernelFunc:SG},{kernelName:rN,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,h=tU.getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new T5(a.shape,l,u,s,i):new T4(a.shape,l,u,s,i);return n.runWebGLProgram(h,[a],"float32")}},{kernelName:rI,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new T6(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}},{kernelName:rv,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,h=tU.getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new T7(a.shape,l,u,s,i):new T8(a.shape,l,u,s,i);return n.runWebGLProgram(h,[a],a.dtype)}},{kernelName:rk,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new T9(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}},{kernelName:rC,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,i=a.shape.length,o=ha.parseAxisParam(s,a.shape);if(0===i)return SR({inputs:{x:a},backend:n});let l=tU.getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new $t(a.shape,o):new $e(a.shape,o);return n.runWebGLProgram(l,[a],a.dtype)}},{kernelName:an,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:a,fillValue:s,center:i}=t,o=new $n(r.shape,s),[l,u]=lz.getImageCenter(i,r.shape[1],r.shape[2]),h=[[l,u,Math.sin(a),Math.cos(a)]];return n.runWebGLProgram(o,[r],r.dtype,h)}},{kernelName:rT,backendName:"webgl",kernelFunc:$r},{kernelName:r$,backendName:"webgl",kernelFunc:$a},{kernelName:rE,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{indices:s,updates:i}=n,{shape:o}=a,{sliceRank:l,numUpdates:u,sliceSize:h,strides:p,outputSize:d}=lz.calculateShapes(i,s,o),c=[d/h,h];if(0===d)return r.makeTensorInfo(o,s.dtype);let f=SG({inputs:{x:s},backend:r,attrs:{shape:[u,l]}}),m=SG({inputs:{x:i},backend:r,attrs:{shape:[u,h]}}),g=r.makeTensorInfo([],"float32",new Float32Array([0]));t=tU.getBool("WEBGL_PACK")?new $i(u,l,f.shape.length,m.shape.length,p,c):new $s(u,l,f.shape.length,m.shape.length,p,c);let y=r.runWebGLProgram(t,[m,f,g],m.dtype),x=SG({inputs:{x:y},backend:r,attrs:{shape:o}});return r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(g),x}},{kernelName:rR,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=new $o(a.shape[0],a.shape[1],s.shape[1],i),l=[[a.shape[1]]];return n.runWebGLProgram(o,[a,s],"int32",l)}},{kernelName:rF,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,i=new $l(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(i,[r,a,s],aD(a.dtype,s.dtype))}},{kernelName:r_,backendName:"webgl",kernelFunc:$u},{kernelName:rL,backendName:"webgl",kernelFunc:$h},{kernelName:rM,backendName:"webgl",kernelFunc:$p},{kernelName:"Sin",backendName:"webgl",kernelFunc:$d},{kernelName:rO,backendName:"webgl",kernelFunc:$c},{kernelName:rD,backendName:"webgl",kernelFunc:Cm},{kernelName:rU,backendName:"webgl",kernelFunc:TU},{kernelName:rz,backendName:"webgl",kernelFunc:$f},{kernelName:rB,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;ha.assert(a.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let o=s.reduce((e,t)=>e*t),l=[[0,0]];l.push(...i);for(let e=1+s.length;e<a.shape.length;++e)l.push([0,0]);let u=[],h=TJ({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),p=lz.getReshaped(h.shape,s,o,!1),d=lz.getPermuted(p.length,s.length,!1),c=lz.getReshapedPermuted(h.shape,s,o,!1),f=SG({inputs:{x:h},backend:n,attrs:{shape:p}}),m=SQ({inputs:{x:f},backend:n,attrs:{perm:d}}),g=SG({inputs:{x:m},backend:n,attrs:{shape:c}});return u.push(h),u.push(f),u.push(m),u.forEach(e=>n.disposeIntermediateTensorInfo(e)),g}},{kernelName:rj,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(1!==s.shape.length)throw Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(2!==r.shape.length)throw Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(1!==a.shape.length)throw Error(`Values must be a vector, saw:
         ${a.shape}`);if(0!==i.shape.length)throw Error(`Default value must be a scalar, saw:
        ${i.shape}`);let o=n.readSync(r.dataId),l=n.readSync(a.dataId),u=n.readSync(s.dataId),h=n.readSync(i.dataId)[0],[p,d,c,f,m]=IZ(o,r.shape,r.dtype,l,a.dtype,u,h);return[n.makeTensorInfo(d,r.dtype,p),n.makeTensorInfo([d[0]],a.dtype,c),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(e=>Number(e)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}},{kernelName:rV,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(2!==r.shape.length)throw Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==a.shape.length)throw Error(`Input shape should be a vector but received shape ${a.shape}`);if(1!==s.shape.length)throw Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.readSync(a.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(s.dataId)),[u,h,p]=IJ(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(h,r.dtype,u),n.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}},{kernelName:rG,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw Error(`Indices should be a vector but received shape
              ${a.shape}`);if(1!==s.shape.length)throw Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,h]=IQ(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(h,r.dtype,u)}},{kernelName:rH,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw Error(`Indices should be a vector but received shape
             ${a.shape}`);if(1!==s.shape.length)throw Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,h]=IQ(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(h,r.dtype,u)}},{kernelName:rq,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:h,strides:p,outputSize:d}=lz.calculateShapes(s,a,o);if("string"===s.dtype){let e=Iq(n.bufferSync(a),n.bufferSync(s),o,d,h,u,l,p,ha.decodeString(n.readSync(i.dataId)[0]),!1);return n.makeTensorInfo(o,e.dtype,e.values)}let c=new $s(u,l,a.shape.length,s.shape.length,p,[d,1],!1),f=n.runWebGLProgram(c,[s,a,i],s.dtype),m=SG({inputs:{x:f},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(f),m}},{kernelName:rW,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=ha.parseAxisParam(i,a.shape)[0],l=lz.prepareSplitSize(a,s,o),u=Array(a.shape.length).fill(0),h=a.shape.slice();return l.map(e=>{let t=[...h];t[o]=e;let r=Cm({inputs:{x:a},backend:n,attrs:{begin:u,size:t}});return u[o]+=e,r})}},{kernelName:rP,backendName:"webgl",kernelFunc:$g},{kernelName:rX,backendName:"webgl",kernelFunc:$y},{kernelName:rK,backendName:"webgl",kernelFunc:$b},{kernelName:rY,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;if("string"!==a.dtype)throw Error("Input must be of datatype string");let s=n.readSync(a.dataId),i=I1(lz.fromUint8ToStringArray(s),"string",r);return n.makeTensorInfo(a.shape,"string",i)}},{kernelName:ae,backendName:"webgl",kernelFunc:function({inputs:e,attrs:t,backend:n}){let{x:r}=e,a=Sh+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,s=new Su(r.shape,a);return n.runWebGLProgram(s,[r],r.dtype)}},{kernelName:rZ,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{begin:i,end:o,strides:l,beginMask:u,endMask:h,ellipsisMask:p,newAxisMask:d,shrinkAxisMask:c}=a,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:x,begin:b,end:w,strides:v}=vs.sliceInfo(s.shape,i,o,l,u,h,p,d,c);if(g)t=SG({inputs:{x:s},backend:r,attrs:{shape:m}});else if(y||x){ha.assert(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);let e=vs.computeOutShape(b,w,v),n=Cm({inputs:{x:s},backend:r,attrs:{begin:b,size:e}});t=SG({inputs:{x:n},backend:r,attrs:{shape:m}}),r.disposeIntermediateTensorInfo(n)}else if(r.shouldExecuteOnCPU([s])){let e=r.readSync(s.dataId),n=I2(f,sW(s.shape,s.dtype,e),v,b);t=r.makeTensorInfo(m,s.dtype,n.values)}else{let e=new $w(b,v,f);t=r.runWebGLProgram(e,[s],s.dtype)}let k=SG({inputs:{x:t},backend:r,attrs:{shape:m}});return r.disposeIntermediateTensorInfo(t),k}},{kernelName:rJ,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:h,dataSplits:p}=t,[d,c]=I3(n.readSync(h.dataId),n.readSync(p.dataId),a,s,i,o,l,u);return[n.makeTensorInfo([d.length],"string",d),n.makeTensorInfo(p.shape,"int32",c)]}},{kernelName:rQ,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if("string"!==s.dtype)throw Error("Input must be of datatype string");if(1!==s.shape.length)throw Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==i.shape.length)throw Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let[o,l,u]=I4(n.readSync(s.dataId),n.readSync(i.dataId)[0],a),h=l.length;return[n.makeTensorInfo([h,2],"int32",o),n.makeTensorInfo([h],"string",l),n.makeTensorInfo([2],"int32",new Int32Array(u))]}},{kernelName:r0,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if("string"!==s.dtype)throw Error("Input must be of datatype string");if(a<=0)throw Error("Number of buckets must be at least 1");let i=I5(n.readSync(s.dataId),a);return n.makeTensorInfo(s.shape,"int32",i)}},{kernelName:"Sub",backendName:"webgl",kernelFunc:TW},{kernelName:"Sum",backendName:"webgl",kernelFunc:SJ},{kernelName:"Tan",backendName:"webgl",kernelFunc:$v},{kernelName:r1,backendName:"webgl",kernelFunc:$k},{kernelName:rA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{tensor:a,indices:s,updates:i}=t,{}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:h,outputSize:p}=lz.calculateShapes(i,s,a.shape),d=[p/u,u];if(0===p)return n.makeTensorInfo(a.shape,s.dtype);let c=SG({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),f=SG({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),m=SG({inputs:{x:a},backend:n,attrs:{shape:d}}),g=new $s(l,o,c.shape.length,f.shape.length,h,d,!1,!0),y=n.runWebGLProgram(g,[f,c,m],m.dtype),x=SG({inputs:{x:y},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),x}},{kernelName:r2,backendName:"webgl",kernelFunc:$I},{kernelName:r3,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r,o=tU.getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=tU.getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=a.shape,h=u[u.length-1];if(n.shouldExecuteOnCPU([a])||h<o||s>l){let[e,t]=I7(n.readSync(a.dataId),u,a.dtype,s,i);return[n.makeTensorInfo(e.shape,e.dtype,e.values),n.makeTensorInfo(t.shape,t.dtype,t.values)]}if(0===s)return u[u.length-1]=0,[n.makeTensorInfo(u,a.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===h)return[a,Ta({attrs:{shape:u,dtype:"int32",value:0},backend:n})];let p=n.texData.get(a.dataId),d=null!==p&&p.isPacked,c=d?n.unpackTensor(a):a,f=ha.sizeFromShape(u)/h,m=SG({inputs:{x:c},attrs:{shape:[f,h]},backend:n});d&&$T(n,c);let g=$$(s),y=$$(h),x=null,b=()=>null===x?[m,m]:[m,x],w=(e,t,r)=>{let a=b(),s=new $S(r),i=[[h],[+(null===x)],[-1/0],[e],[t]],o=x;x=n.runWebGLProgram(s,a,"int32",i),$T(n,o)};for(let e=1;e<g;e*=2){let t=2*e;for(let n=e;n>=1;n/=2)w(t,n,[f,y])}for(let e=y;e>g;e/=2){let t=b(),r=new $C([f,e/2]),a=[[h],[+(null===x)],[g]],s=x;x=n.runWebGLProgram(r,t,"int32",a),$T(n,s);let i=g/2,o=2*i;for(let e=i;e>=1;e/=2)w(o,e,x.shape)}let v=x;x=Cm({inputs:{x:x},backend:n,attrs:{begin:0,size:[f,s]}}),$T(n,v);let k=Tf({inputs:{x:m,indices:x},backend:n,attrs:{axis:1,batchDims:1}});$T(n,m);let N=u.slice(0,-1);N.push(s),v=x,x=SG({inputs:{x:x},attrs:{shape:N},backend:n}),$T(n,v);let I=k;return k=SG({inputs:{x:k},attrs:{shape:N},backend:n}),$T(n,I),[k,x]}},{kernelName:r4,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[h,p,d,c]=a.shape,[f,m]=null!=u?u:[p,d],g=new $E(p,d,i,o,l,[h,f,m,c]);return n.runWebGLProgram(g,[a,s],"float32")}},{kernelName:r5,backendName:"webgl",kernelFunc:SQ},{kernelName:r6,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;NT(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let{outputValues:i,outputShape:o,indices:l}=Se(r.readSync(s.dataId),a,s.shape,s.dtype);return[r.makeTensorInfo(o,s.dtype,i),r.makeTensorInfo([l.length],"int32",l)]}},{kernelName:r8,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a.shape.length,o=a.shape[s],l=Array(i-1),u=0;for(let e=0;e<i;e++)e!==s&&(l[u++]=a.shape[e]);let h=[],p=Array(i).fill(0),d=a.shape.slice();d[s]=1;let c=Array(o);for(let e=0;e<c.length;e++){p[s]=e;let t=Cm({inputs:{x:a},backend:n,attrs:{begin:p,size:d}}),r=SG({inputs:{x:t},backend:n,attrs:{shape:l}});c[e]=r,h.push(t)}return h.forEach(e=>n.disposeIntermediateTensorInfo(e)),c}},{kernelName:r7,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r,o=a.shape.length,l=[],u=0,h=lz.getAxesPermutation([u],o),p=a;null!=h&&(p=SQ({inputs:{x:a},backend:n,attrs:{perm:h}}),l.push(p),u=lz.getInnerMostAxes(1,o)[0]);let d=lz.segment_util.computeOutShape(p.shape,u,i),c=ha.sizeFromShape([p.shape[u]]),f=SG({inputs:{x:p},backend:n,attrs:{shape:[-1,c]}});l.push(f);let m=aO(a.dtype),g=(e,t,r,a,s)=>{let i=e.shape[0],o=e.shape[1],u=lz.segment_util.segOpComputeOptimalWindowSize(o,s),h=new $A({windowSize:u,inSize:o,batchSize:i,numSegments:s},t),p=n.compileAndRun(h,[e,r],a);if(l.push(p),p.shape[1]===s)return p;let d=T0({backend:n,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),c=$I({inputs:{x:d},backend:n,attrs:{reps:[o/u]}});return l.push(d),l.push(c),g(p,t,c,a,s)},y=SG({inputs:{x:g(f,"unsortedSegmentSum",s,m,i)},backend:n,attrs:{shape:d}}),x=y;return null!=h&&(l.push(y),x=SQ({inputs:{x:x},backend:n,attrs:{perm:lz.getUndoAxesPermutation(h)}})),l.forEach(e=>n.disposeIntermediateTensorInfo(e)),x}},{kernelName:r9,backendName:"webgl",kernelFunc:TX}])ad(e);e.i(48890),e.i(50248),e.i(32712),e.s(["GPGPUContext",()=>Im,"MathBackendWebGL",()=>SN,"forceHalfFloat",()=>SC,"gpgpu_util",0,SI,"setWebGLContext",()=>kB,"webgl_util",0,SS],60253),e.i(60253),e.i(77134);class $R{static model=null;static localLLMActive=!1;static async initURLPredictor(){if(!this.model)try{let e=new fU(void 0);e.add(y2.dense({units:8,inputShape:[5],activation:"relu"})),e.add(y2.dense({units:4,activation:"softmax"})),this.model=e,console.log("Comet Browser Intelligence: URL Predictor Online.")}catch(e){console.warn("TF.js initialization failed, falling back to heuristics.")}}static async predictUrl(e,t){if(!e||e.length<2)return null;let n=e.toLowerCase().replace(/^(https?:\/\/)?(www\.)?/,""),r=t.find(e=>{let t=e.toLowerCase().replace(/^(https?:\/\/)?(www\.)?/,"");return t.startsWith(n)&&t!==n});return r||(!e.includes(".")&&e.length>2?`${e}.com`:null)}static scanForCartItems(e){let t,n=/<script type="application\/ld\+json">([\s\S]*?)<\/script>/g;for(;null!==(t=n.exec(e));)try{let e=JSON.parse(t[1]),n=Array.isArray(e)?e.find(e=>"Product"===e["@type"]):"Product"===e["@type"]?e:null;if(n&&n.name){let e=n.offers?.price||n.offers?.[0]?.price,t=n.offers?.priceCurrency||n.offers?.[0]?.priceCurrency||"$";if(e)return{item:n.name,price:`${t}${e}`,site:window.location.hostname}}}catch(e){}let r=e.match(/<meta property="og:title" content="(.*?)"/)?.[1],a=e.match(/<meta property="product:price:amount" content="(.*?)"/)?.[1],s=e.match(/<meta property="product:price:currency" content="(.*?)"/)?.[1]||"$";if(r&&a)return{item:r,price:`${s}${a}`,site:window.location.hostname};let i=e.match(/<h1[^>]*>(.*?)<\/h1>/)?.[1]?.replace(/<[^>]*>/g,"").trim(),o=e.match(/([$â‚¬Â£Â¥])\s?(\d+[.,]\d{2})/);return o&&i&&i.length<100?{item:i,price:o[0],site:window.location.hostname}:null}static async summarizeLocal(e){return`[Local AI Response] Summarized ${e.length} characters of data. Core themes: Productivity, Infrastructure, Efficiency.`}}let $F=(0,Q.default)("chevron-left",[["path",{d:"m15 18-6-6 6-6",key:"1wnfg3"}]]),$_=(0,Q.default)("rotate-cw",[["path",{d:"M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8",key:"1p45f6"}],["path",{d:"M21 3v5h-5",key:"1q7to0"}]]),$D=(0,Q.default)("folder-open",[["path",{d:"m6 14 1.5-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-1.54 6a2 2 0 0 1-1.95 1.5H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H18a2 2 0 0 1 2 2v2",key:"usdka0"}]]),$O=(0,Q.default)("shield-check",[["path",{d:"M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",key:"oel41y"}],["path",{d:"m9 12 2 2 4-4",key:"dzmm74"}]]),$M=(0,Q.default)("triangle-alert",[["path",{d:"m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",key:"wmoenq"}],["path",{d:"M12 9v4",key:"juzpu7"}],["path",{d:"M12 17h.01",key:"p32p05"}]]),$L=(0,Q.default)("bookmark",[["path",{d:"m19 21-7-4-7 4V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v16z",key:"1fy3hk"}]]),$z=(0,Q.default)("cloud-download",[["path",{d:"M12 13v8l-4-4",key:"1f5nwf"}],["path",{d:"m12 21 4-4",key:"1lfcce"}],["path",{d:"M4.393 15.269A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.436 8.284",key:"ui1hmy"}]]),$P=(0,Q.default)("shopping-cart",[["circle",{cx:"8",cy:"21",r:"1",key:"jimo8o"}],["circle",{cx:"19",cy:"21",r:"1",key:"13723u"}],["path",{d:"M2.05 2.05h2l2.66 12.42a2 2 0 0 0 2 1.58h9.78a2 2 0 0 0 1.95-1.57l1.65-7.43H5.12",key:"9zh506"}]]),$B=(0,Q.default)("scan-line",[["path",{d:"M3 7V5a2 2 0 0 1 2-2h2",key:"aa7l1z"}],["path",{d:"M17 3h2a2 2 0 0 1 2 2v2",key:"4qcy5o"}],["path",{d:"M21 17v2a2 2 0 0 1-2 2h-2",key:"6vwrx8"}],["path",{d:"M7 21H5a2 2 0 0 1-2-2v-2",key:"ioqczr"}],["path",{d:"M7 12h10",key:"b7w52i"}]]);function $W(){let e=(0,U.useAppStore)(),[t,n]=(0,W.useState)(!1),[r,a]=(0,W.useState)(!1),[s,i]=(0,W.useState)(!1),[o,l]=(0,W.useState)(!1),[u,h]=(0,W.useState)(null),[p,d]=(0,W.useState)(!1),[c,f]=(0,W.useState)(null);(0,W.useEffect)(()=>{let t=window.document.documentElement;if(t.classList.remove("light","dark"),"system"===e.theme){let e=window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light";t.classList.add(e)}else t.classList.add(e.theme)},[e.theme]),(0,W.useEffect)(()=>{$R.initURLPredictor()},[]),(0,W.useEffect)(()=>{let t=setTimeout(async()=>{p&&e.currentUrl.length>2?h(await $R.predictUrl(e.currentUrl,e.history)):h(null)},150);return()=>clearTimeout(t)},[e.currentUrl,p,e.history]);let m=()=>{let t=e.currentUrl.trim();if(t){if(t.startsWith("/")){switch(t.split(" ")[0]){case"/settings":e.toggleSidebar();break;case"/student":e.setStudentMode(!e.studentMode);break;case"/store":e.setActiveView("webstore");break;case"/pdf":e.setActiveView("pdf");break;case"/browser":e.setActiveView("browser");break;case"/landing":case"/web":e.setActiveView("landing");break;case"/code":e.setCodingMode(!e.isCodingMode)}e.setCurrentUrl("");return}t.includes(".")&&!t.includes(" ")?t.startsWith("http")||(t=`https://${t}`):t=`${H[e.selectedEngine].url}${encodeURIComponent(t)}`,e.setActiveView("browser"),e.updateTab(e.activeTabId,{url:t,title:t.split("/")[2]||"New Tab"}),e.setCurrentUrl(t),h(null),d(!1),e.addToHistory(t)}},g=async()=>{if(!window.electronAPI)return;let t=await window.electronAPI.capturePageHtml(),n=e.tabs.find(t=>t.id===e.activeTabId);n&&(await window.electronAPI.saveOfflinePage({url:n.url,title:n.title,html:t}),e.savePageOffline(n.url,n.title,t))},y=async()=>{if(!window.electronAPI)return;let t=await window.electronAPI.capturePageHtml(),n=$R.scanForCartItems(t);n&&(e.addToUnifiedCart({...n,url:e.tabs.find(t=>t.id===e.activeTabId)?.url||""}),l(!0))},x=(0,W.useCallback)(()=>{if(!window.electronAPI)return;let t=e.isSidebarCollapsed?80:e.sidebarWidth,n="left"===e.sidebarSide?t:0,r=window.innerWidth-t;"browser"===e.activeView?window.electronAPI.setBrowserViewBounds({x:Math.round(n),y:112,width:Math.round(r),height:window.innerHeight-112}):window.electronAPI.setBrowserViewBounds({x:0,y:0,width:0,height:0})},[e.isSidebarCollapsed,e.sidebarWidth,e.sidebarSide,e.activeView]);return((0,W.useEffect)(()=>(x(),window.addEventListener("resize",x),()=>window.removeEventListener("resize",x)),[x]),(0,W.useEffect)(()=>{let t=()=>{navigator.clipboard.readText().then(t=>{t&&e.addClipboardItem(t)})};return window.addEventListener("focus",t),()=>window.removeEventListener("focus",t)},[]),"landing"===e.activeView)?(0,B.jsx)(eJ.default,{}):(0,B.jsxs)("div",{className:`flex h-screen w-full bg-deep-space-bg overflow-hidden relative font-sans text-white transition-all duration-700 ${e.isVibrant?"bg-vibrant-mesh":""}`,children:[(0,B.jsxs)("aside",{style:{width:e.isSidebarCollapsed?80:e.sidebarWidth,order:"left"===e.sidebarSide?-1:1},className:`z-50 glass-vibrant border-white/5 transition-all duration-500 ease-in-out flex flex-col ${"left"===e.sidebarSide?"border-r":"border-l"}`,children:[(0,B.jsx)("div",{className:"p-6 flex-1 overflow-hidden",children:(0,B.jsx)(ed,{studentMode:e.studentMode,toggleStudentMode:()=>e.setStudentMode(!e.studentMode),isCollapsed:e.isSidebarCollapsed,toggleCollapse:e.toggleSidebar,selectedEngine:e.selectedEngine,setSelectedEngine:e.setSelectedEngine,theme:e.theme,setTheme:e.setTheme,side:e.sidebarSide,backgroundImage:"",setBackgroundImage:()=>{},backend:"firebase",setBackend:()=>{},mysqlConfig:{},setMysqlConfig:()=>{}})}),!e.isSidebarCollapsed&&(0,B.jsxs)("div",{className:"p-4 grid grid-cols-2 gap-2 border-t border-white/5 bg-black/10",children:[(0,B.jsxs)("button",{onClick:()=>e.setActiveView("webstore"),className:`flex items-center gap-2 p-3 rounded-2xl transition-all ${"webstore"===e.activeView?"bg-deep-space-accent-neon/10 text-deep-space-accent-neon":"hover:bg-white/5 text-white/40"}`,children:[(0,B.jsx)(ef,{size:18}),(0,B.jsx)("span",{className:"text-xs font-bold uppercase tracking-widest",children:"Store"})]}),(0,B.jsxs)("button",{onClick:()=>e.setActiveView("pdf"),className:`flex items-center gap-2 p-3 rounded-2xl transition-all ${"pdf"===e.activeView?"bg-deep-space-accent-neon/10 text-deep-space-accent-neon":"hover:bg-white/5 text-white/40"}`,children:[(0,B.jsx)(eb,{size:18}),(0,B.jsx)("span",{className:"text-xs font-bold uppercase tracking-widest",children:"Docs"})]})]})]}),(0,B.jsxs)("main",{className:"flex-1 flex flex-col relative overflow-hidden bg-black/5",children:[!e.isCodingMode&&"browser"===e.activeView&&(0,B.jsxs)("div",{className:"h-10 flex items-center px-4 gap-1 bg-black/40 border-b border-white/5 overflow-x-auto custom-scrollbar no-scrollbar",children:[e.tabs.map(t=>(0,B.jsxs)("div",{onClick:()=>e.setActiveTab(t.id),className:`group flex items-center h-8 px-4 rounded-t-xl min-w-[140px] max-w-[200px] cursor-pointer transition-all border-t border-x ${e.activeTabId===t.id?"bg-white/10 border-white/10 text-white":"bg-transparent border-transparent text-white/30 hover:bg-white/5"}`,children:[(0,B.jsx)(ej.Globe,{size:12,className:"mr-2 flex-shrink-0"}),(0,B.jsx)("span",{className:"text-[10px] font-bold truncate flex-1",children:t.title}),(0,B.jsx)("button",{onClick:n=>{n.stopPropagation(),e.removeTab(t.id)},className:"ml-2 p-0.5 rounded-full hover:bg-white/20 opacity-0 group-hover:opacity-100 transition-opacity",children:(0,B.jsx)(eh,{size:10,className:"rotate-45"})})]},t.id)),(0,B.jsx)("button",{onClick:()=>e.addTab(),className:"p-1.5 rounded-lg text-white/20 hover:bg-white/10 hover:text-white transition-all ml-2",children:(0,B.jsx)(eh,{size:14})})]}),(0,B.jsxs)("div",{className:"h-9 flex items-center px-6 gap-4 bg-black/20 border-b border-white/5 overflow-x-auto no-scrollbar",children:[(0,B.jsxs)("div",{className:"flex items-center gap-1.5 text-deep-space-accent-neon mr-4",children:[(0,B.jsx)($L,{size:12}),(0,B.jsx)("span",{className:"text-[10px] font-black uppercase tracking-widest opacity-60",children:"Library"})]}),e.bookmarks.map(t=>(0,B.jsxs)("button",{onClick:()=>{e.setCurrentUrl(t.url),m()},className:"flex items-center gap-2 px-3 py-1 rounded-lg hover:bg-white/5 transition-all group",children:[(0,B.jsx)(ej.Globe,{size:10,className:"text-white/20 group-hover:text-deep-space-accent-neon"}),(0,B.jsx)("span",{className:"text-[10px] font-medium text-white/40 group-hover:text-white truncate max-w-[120px]",children:t.title})]},t.id)),(0,B.jsx)("button",{onClick:()=>{let t=e.tabs.find(t=>t.id===e.activeTabId);t&&e.addBookmark(t.url,t.title)},className:"ml-auto p-1.5 rounded-lg text-white/20 hover:bg-white/10 hover:text-white transition-all",children:(0,B.jsx)(eh,{size:12})})]}),(0,B.jsxs)("header",{className:"h-[72px] flex items-center px-6 gap-6 border-b border-white/5 bg-black/20 backdrop-blur-3xl z-40",children:[(0,B.jsxs)("div",{className:"flex items-center gap-1.5",children:[(0,B.jsx)("button",{onClick:()=>window.electronAPI?.goBack(),className:"p-2 rounded-xl hover:bg-white/10 text-white/40 hover:text-white transition-all",children:(0,B.jsx)($F,{size:20})}),(0,B.jsx)("button",{onClick:()=>window.electronAPI?.goForward(),className:"p-2 rounded-xl hover:bg-white/10 text-white/40 hover:text-white transition-all",children:(0,B.jsx)(eG,{size:20})}),(0,B.jsx)("button",{onClick:()=>window.electronAPI?.reload(),className:"p-2 rounded-xl hover:bg-white/10 text-white/40 hover:text-white transition-all",children:(0,B.jsx)($_,{size:18})})]}),(0,B.jsxs)("div",{className:"flex-1 relative max-w-3xl mx-auto group",children:[(0,B.jsx)("div",{className:"absolute inset-y-0 left-4 flex items-center pointer-events-none",children:e.showSiteWarnings&&!e.currentUrl.startsWith("https")?(0,B.jsx)($M,{size:14,className:"text-yellow-500 animate-pulse"}):(0,B.jsx)($O,{size:14,className:"text-deep-space-accent-neon"})}),(0,B.jsx)("input",{type:"text",value:e.currentUrl,onChange:t=>{e.setCurrentUrl(t.target.value),d(!0)},onKeyDown:t=>{"Enter"===t.key&&m(),"Tab"===t.key&&u&&(t.preventDefault(),e.setCurrentUrl(u),h(null))},onBlur:()=>setTimeout(()=>h(null),200),placeholder:"Search safely or enter URL...",className:"w-full bg-black/40 border border-white/10 rounded-2xl py-2.5 pl-11 pr-4 text-sm text-white focus:outline-none focus:ring-1 focus:ring-deep-space-accent-neon/30 transition-all placeholder:text-white/20 font-medium"}),u&&(0,B.jsxs)("div",{className:"absolute left-11 top-1/2 -translate-y-1/2 text-white/20 pointer-events-none text-sm font-medium",children:[(0,B.jsx)("span",{className:"invisible",children:e.currentUrl}),(0,B.jsx)("span",{children:u.slice(e.currentUrl.length)}),(0,B.jsx)("span",{className:"ml-2 text-[8px] bg-white/5 px-1.5 py-0.5 rounded uppercase tracking-widest text-white/40 border border-white/5",children:"Tab to prefill"})]})]}),(0,B.jsxs)("div",{className:"flex items-center gap-2",children:[(0,B.jsx)("button",{onClick:g,className:"p-2.5 rounded-xl text-white/30 hover:bg-white/5 hover:text-deep-space-accent-neon transition-all",title:"Save Page Offline",children:(0,B.jsx)($z,{size:18})}),(0,B.jsxs)("button",{onClick:()=>l(!o),className:`p-2.5 rounded-xl transition-all relative ${o?"bg-deep-space-accent-neon/10 text-deep-space-accent-neon":"text-white/30 hover:bg-white/5 hover:text-white"}`,children:[(0,B.jsx)($P,{size:18}),e.unifiedCart.length>0&&(0,B.jsx)("span",{className:"absolute top-1.5 right-1.5 w-2 h-2 bg-deep-space-accent-neon rounded-full shadow-[0_0_8px_rgba(0,255,255,0.6)]"})]}),(0,B.jsx)("button",{onClick:()=>n(!t),className:`p-2.5 rounded-xl transition-all ${t?"bg-deep-space-accent-neon/10 text-deep-space-accent-neon":"text-white/30 hover:bg-white/5 hover:text-white"}`,children:(0,B.jsx)(eS,{size:18})}),(0,B.jsx)("button",{onClick:()=>window.electronAPI?.openDevTools(),className:"p-2.5 rounded-xl text-white/30 hover:bg-white/5 hover:text-red-400 transition-all",title:"Open DevTools",children:(0,B.jsx)(ez,{size:18})}),(0,B.jsx)("button",{onClick:()=>i(!0),className:"p-2.5 rounded-xl text-white/30 hover:bg-white/5 hover:text-white transition-all",title:"Browser Settings",children:(0,B.jsx)(et,{size:18})}),(0,B.jsx)("div",{className:"w-[1px] h-8 bg-white/5 mx-2"}),(0,B.jsx)("button",{onClick:()=>window.electronAPI?.shareDeviceFolder(),className:"p-2.5 rounded-xl text-white/30 hover:bg-white/5 hover:text-white transition-all",title:"Share Device Folder",children:(0,B.jsx)($D,{size:18})}),(0,B.jsx)("button",{className:`p-2.5 rounded-xl transition-all ${e.isCodingMode?"bg-deep-space-accent-neon/10 text-deep-space-accent-neon":"text-white/30 hover:bg-white/5 hover:text-white"}`,onClick:()=>e.setCodingMode(!e.isCodingMode),title:"Developer Mode",children:(0,B.jsx)(ez,{size:18})})]})]}),(0,B.jsxs)("div",{className:"flex-1 relative",children:[(0,B.jsxs)(V.AnimatePresence,{mode:"wait",children:["browser"===e.activeView&&(0,B.jsx)(j.motion.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},className:"absolute inset-0",children:(0,B.jsxs)("div",{className:`h-full flex ${e.studentMode?"p-4 gap-4":""}`,children:[(0,B.jsx)("div",{className:`flex-[3] relative ${e.studentMode?"rounded-2xl overflow-hidden border border-white/10 shadow-3xl":""}`,children:(0,B.jsx)(G,{omnibarUrl:e.tabs.find(t=>t.id===e.activeTabId)?.url||"https://www.google.com",onUrlChange:t=>e.updateTab(e.activeTabId,{url:t})})}),e.studentMode&&(0,B.jsxs)("div",{className:"flex-1 glass-vibrant shadow-3xl rounded-3xl p-6 flex flex-col border border-white/5 bg-white/[0.02]",children:[(0,B.jsxs)("div",{className:"flex items-center gap-3 mb-6",children:[(0,B.jsx)(e_.Sparkles,{size:20,className:"text-deep-space-accent-neon"}),(0,B.jsx)("h3",{className:"text-[11px] font-black uppercase tracking-[0.3em] text-white/70",children:"Context Intelligence"})]}),(0,B.jsx)("textarea",{className:"flex-1 bg-transparent text-white/80 text-sm leading-relaxed resize-none focus:outline-none placeholder:text-white/5 custom-scrollbar font-medium",placeholder:"Insights reflect current tab content..."})]})]})},"browser"),"webstore"===e.activeView&&(0,B.jsx)(ey,{onClose:()=>e.setActiveView("browser")},"webstore"),"pdf"===e.activeView&&(0,B.jsx)(eI,{},"pdf"),e.isCodingMode&&(0,B.jsx)(j.motion.div,{initial:{scale:.98,opacity:0},animate:{scale:1,opacity:1},exit:{scale:1.02,opacity:0},className:"absolute inset-0 z-50",children:(0,B.jsx)(eW,{})},"coding")]}),(0,B.jsxs)(V.AnimatePresence,{children:[t&&(0,B.jsx)(j.motion.div,{initial:{opacity:0,x:"right"===e.sidebarSide?-20:20},animate:{opacity:1,x:0},exit:{opacity:0,x:"right"===e.sidebarSide?-20:20},className:`absolute top-4 ${"right"===e.sidebarSide?"left-4":"right-4"} bottom-4 w-80 z-50 shadow-3xl`,children:(0,B.jsx)(e$,{})},"clipboard-manager"),r&&(0,B.jsx)(eD,{onClose:()=>a(!1)},"phone-camera"),s&&(0,B.jsx)(eZ,{onClose:()=>i(!1)},"settings-panel"),o&&(0,B.jsxs)(j.motion.div,{initial:{opacity:0,scale:.95,y:10},animate:{opacity:1,scale:1,y:0},exit:{opacity:0,scale:.95,y:10},className:"absolute top-20 right-6 w-96 glass-vibrant z-50 rounded-[2rem] p-8 shadow-3xl bg-black/40 border border-white/10",children:[(0,B.jsxs)("div",{className:"flex items-center justify-between mb-8",children:[(0,B.jsxs)("div",{children:[(0,B.jsx)("h3",{className:"text-xl font-black uppercase tracking-tighter",children:"Unified Cart"}),(0,B.jsx)("p",{className:"text-[10px] text-white/30 font-bold uppercase tracking-widest",children:"Cross-Site AI Manager"})]}),(0,B.jsx)("button",{onClick:y,className:"p-3 bg-deep-space-accent-neon/10 text-deep-space-accent-neon rounded-2xl hover:bg-deep-space-accent-neon/20 transition-all",children:(0,B.jsx)($B,{size:18})})]}),(0,B.jsx)("div",{className:"space-y-4 max-h-[400px] overflow-y-auto custom-scrollbar pr-2",children:0===e.unifiedCart.length?(0,B.jsxs)("div",{className:"py-12 text-center",children:[(0,B.jsx)($P,{size:40,className:"mx-auto text-white/10 mb-4"}),(0,B.jsx)("p",{className:"text-white/30 text-xs",children:"No items detected by BrowserAI yet."})]}):e.unifiedCart.map(t=>(0,B.jsxs)("div",{className:"p-4 rounded-2xl bg-white/[0.03] border border-white/5 flex gap-4 group",children:[(0,B.jsx)("div",{className:"w-12 h-12 rounded-xl bg-white/5 flex items-center justify-center text-lg",children:"ðŸ›ï¸"}),(0,B.jsxs)("div",{className:"flex-1 min-w-0",children:[(0,B.jsx)("p",{className:"text-xs font-bold text-white truncate",children:t.item}),(0,B.jsx)("p",{className:"text-[10px] text-white/40 uppercase tracking-widest",children:t.site}),(0,B.jsx)("p",{className:"text-deep-space-accent-neon font-black mt-1",children:t.price})]}),(0,B.jsx)("button",{onClick:()=>e.removeFromCart(t.id),className:"opacity-0 group-hover:opacity-100 p-2 text-white/20 hover:text-red-400 transition-all",children:(0,B.jsx)(eR,{size:14})})]},t.id))}),e.unifiedCart.length>0&&(0,B.jsx)("button",{className:"w-full mt-8 py-4 bg-deep-space-accent-neon text-deep-space-bg font-black rounded-2xl text-[10px] uppercase tracking-widest shadow-[0_0_20px_rgba(0,255,255,0.3)] hover:scale-[1.02] transition-all",children:"Checkout All via Comet Pay"})]},"unified-cart"),(0,B.jsx)(V.AnimatePresence,{children:e.studentMode&&(0,B.jsxs)(j.motion.div,{initial:{opacity:0,x:-50},animate:{opacity:1,x:0},exit:{opacity:0,x:-50},className:"fixed bottom-12 left-1/2 -translate-x-1/2 px-6 py-4 glass-vibrant rounded-full border border-deep-space-accent-neon/30 flex items-center gap-6 shadow-2xl z-50 bg-black/60 shadow-deep-space-accent-neon/10",children:[(0,B.jsxs)("div",{className:"flex items-center gap-3 border-r border-white/10 pr-6",children:[(0,B.jsx)(e_.Sparkles,{size:18,className:"text-deep-space-accent-neon animate-pulse"}),(0,B.jsx)("span",{className:"text-[10px] font-black uppercase tracking-[0.2em]",children:"AI Intelligence Active"})]}),(0,B.jsxs)("button",{onClick:y,className:"flex items-center gap-2 text-white/60 hover:text-deep-space-accent-neon transition-all",children:[(0,B.jsx)($B,{size:16}),(0,B.jsx)("span",{className:"text-[10px] font-bold uppercase",children:"Scan Page"})]}),(0,B.jsxs)("button",{className:"flex items-center gap-2 text-white/60 hover:text-deep-space-accent-neon transition-all",children:[(0,B.jsx)(el,{size:16}),(0,B.jsx)("span",{className:"text-[10px] font-bold uppercase",children:"Search Concept"})]}),(0,B.jsxs)("button",{onClick:g,className:"flex items-center gap-2 text-white/60 hover:text-deep-space-accent-neon transition-all",children:[(0,B.jsx)($z,{size:16}),(0,B.jsx)("span",{className:"text-[10px] font-bold uppercase",children:"Go Offline"})]})]},"ai-scan-widget")})]})]})]})]})}e.s(["default",()=>$W],34437)}]);